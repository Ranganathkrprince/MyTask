package com.niftem.app.implementation;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.RandomAccessFile;
import java.io.StringWriter;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import javax.transaction.Transactional;
import javax.xml.bind.DatatypeConverter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import com.niftem.app.entity.AcademicYear;
import com.niftem.app.entity.Batch;
import com.niftem.app.entity.Colleges;
import com.niftem.app.entity.Courses;
import com.niftem.app.entity.CoursesRegistration;
import com.niftem.app.entity.Degree;
import com.niftem.app.entity.Department;
import com.niftem.app.entity.EvaluationDetails;
import com.niftem.app.entity.EvaluationType;
import com.niftem.app.entity.EvaluatorList;
import com.niftem.app.entity.EvaluatorSelection;
import com.niftem.app.entity.ExamAnnouncement;
import com.niftem.app.entity.ExamBarcodes;
import com.niftem.app.entity.ExternalMarks;
import com.niftem.app.entity.GradeReport;
import com.niftem.app.entity.GradeReportLog;
import com.niftem.app.entity.MidTermMarks;
import com.niftem.app.entity.OrderTransaction;
import com.niftem.app.entity.ProgrammeYear;
import com.niftem.app.entity.Programmes;
import com.niftem.app.entity.PublishResult;
import com.niftem.app.entity.RegistrationType;
import com.niftem.app.entity.Section;
import com.niftem.app.entity.SemesterProgressReport;
import com.niftem.app.entity.Semster;
import com.niftem.app.entity.Studentadmission;
import com.niftem.app.entity.Studentpersonal;
import com.niftem.app.entity.SupplementaryRegistration;
import com.niftem.app.entity.User;
import com.niftem.app.model.BookletStaffRequest;
import com.niftem.app.model.BookletUploadRequest;
import com.niftem.app.model.CoursesRegistrationRequest;
import com.niftem.app.model.EvaluationDetailsRequest;
import com.niftem.app.model.EvaluatorSelectionRequest;
import com.niftem.app.model.GradeReportRequest;
import com.niftem.app.model.LoadAlertRequest;
import com.niftem.app.model.PhotoCopyRequest;
import com.niftem.app.model.PublishResultRequest;
import com.niftem.app.repository.ExternalMarksRepository;
import com.niftem.app.repository.PublishResultRepository;
import com.niftem.app.service.PostExamService;
import com.niftem.app.util.AutoManager;
import com.niftem.app.util.EmailSending;

@Service
@Transactional
public class PostExamImp extends AutoManager implements PostExamService {
	private static Logger logger = LoggerFactory.getLogger("master-log");
	
	@Autowired
	private ExternalMarksRepository ExternalMarksRepository;
	
	@Autowired
	private EmailSending emailSending;
	
	@Autowired
	private PublishResultRepository publishResult;
	

	@Override
	public Map<String, Object> generateGradeReport(GradeReportRequest request) {
	Map<String, Object> info = new LinkedHashMap<>();
		try {
			logger.info("Inside generateGradeReport");
	
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),
					false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!programyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			
			List<RegistrationType> RegistrationType = super.registrationType.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (RegistrationType.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType id not present");
				return info;
			}

			Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(), false,true);
			if (!courses.isPresent()) {
				info.put("status", "2");
				info.put("message", "courses not  present");
				return info;

			}
			
			String sectionval  = "";
			List<Long> list = new ArrayList();
			
			if(request.getSection().size()>0) {		
				for(int i =0 ; i<request.getSection().size() ; i++) {
					Optional<Section> sections  = super.section.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSection().get(i));					
					  if(!sections.isPresent()) {
						  info.put("status", "2"); 
						  info.put("message","Section not present");
						  return info;
					}
						
					list.add(sections.get().getId());
					sectionval = sectionval+request.getSection().get(i)+",";
				}	
				sectionval =  sectionval.substring(0, sectionval.length() -1);
				sectionval = " AND s.section IN ( "+sectionval+" )";
			}else {
				List<Section> slist  = super.section.findByExIsDeleteAndExIsActive(false, true);				
				for(Section sec : slist) {
					list.add(sec.getId());
				}
			}
			
			User userresult = null;
			String ExIsReGenerated = "Generated";
			if (request.getUser() == null || request.getUser().equals("")) {
				userresult = null;
			} else {
				List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
				userresult = user.get(0);
			}
	
			
			if (request.getExamAnnouncement()==null || request.getExamAnnouncement().equals("NA")) {				
				return  generateMigGradereport (request);
								
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement	.findByExIsDeleteAndExIsActiveAndId(false, true, request.getExamAnnouncement());
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "Examannouncement  not present");
				return info;
			}
						
			List<GradeReportLog> duplicate = super.GradeReportLog.findByExamAnnouncementIdAndAcademicYearIdAndCollegesIdAndProgrammesIdAndExReportTypeAndDegreeIdAndCoursesIdAndSemesterIdAndExReportCategoryAndDepartmentIdAndSectionIdIn(
							request.getExamAnnouncement(), request.getAcademicYear(), request.getColleges(),
							request.getProgrammes(), "gradeReport", request.getDegree(), request.getCourses(),
							request.getSemester(), "Generate", request.getDepartment(),list);
			if (duplicate.size() > 0) {
				if (request.getExRemark() == null || request.getExRemark().equalsIgnoreCase("null")|| request.getExRemark().equals("") || request.getExRemark().trim().isEmpty()) {
					info.put("status", "2");
					info.put("message", "Please provide valid reason for regenerating grade report");
					return info;
				}
				ExIsReGenerated = "ReGenerated";
			}

			
			List<Object[]> examAttendance = super.accademicdao.getExamdetails(false, request.getAcademicYear(),
					request.getColleges(), request.getCourses(), request.getDegree(), request.getExamAnnouncement(),
					request.getProgrammes(), request.getRegistrationType(), request.getDepartment(),sectionval);
			if (examAttendance.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Exam attendance not created");
				return info;
			}

			logger.info("examAttendance"+examAttendance.size());

			  
			List<MidTermMarks> internal = super.midtermmarksMarks
					.findByCollegesIdAndDegreeIdAndProgrammesIdAndCoursesIdAndSemesterIdAndExIsActiveAndExIsDeleteAndProgrammeYearIdAndDepartmentId(
							request.getColleges(), request.getDegree(), request.getProgrammes(), request.getCourses(),
							request.getSemester(), true, false, request.getProgrammeYear(), request.getDepartment());
			if (internal.size() <= 0) {
				info.put("status", "2");
				info.put("message", "MidTerm Marks not uploded");
				return info;
			}
			List<ExamBarcodes> ormmarks = super.exambarcode
					.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndSemesterIdAndAcademicYearIdAndRegistrationTypeIdAndDepartmentId(
							true, request.getColleges(), request.getCourses(), request.getDegree(),
							request.getExamAnnouncement(), request.getProgrammes(), request.getSemester(),
							request.getAcademicYear(), request.getRegistrationType(), request.getDepartment());
			logger.info("ormmarks"+ormmarks.size());

			if (ormmarks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Attendence not created");
				return info;
			}
			
			
			logger.info("dddddddddddddddddddd",courses.get().getCoursesType().size());
			
		
			
		if(courses.get().getCoursesType().size()==1) {

				  if(courses.get().getCoursesType().get(0).getId() == 1) {
					  // theory courses  need to update with diffrent way 
					 
					  return createTherorygradeReport(examAttendance , degree , collage , Prog ,result ,
				  courses , sem , academicYear , programyear , RegistrationType ,userresult ,
				  duplicate , ExIsReGenerated , request.getExRemark(),dept);
				  }
		  
		  
		  if(courses.get().getCoursesType().get(0).getId() == 2) { 
			  // practical courses need to update with diffrent way
			
			  return createPracticalgradeReport(examAttendance , degree , collage , Prog ,result ,
		  courses , sem , academicYear , programyear , RegistrationType ,userresult ,
		  duplicate , ExIsReGenerated , request.getExRemark(),dept); }
		 
		  }
	
			Date date = new Date();

			Set<Section> hSet = new HashSet<Section>(); 
			for (Object[] exam : examAttendance) { 
				Section sectionValue=null ;

				if(exam[1].toString()== null || exam[1].toString().equals("") || exam[1].toString().equals("NA")) {
					sectionValue=null;
				}else {
					long section_id = Long.parseLong(exam[1].toString());
					Optional<Section> userSection = super.section.findByExIsDeleteAndExIsActiveAndId( false,true,section_id);	
					if(userSection.isPresent()) {
						sectionValue=userSection.get();
					}else {
						sectionValue=null;
					}	
					hSet.add(sectionValue);
				}
				
				// mendetory field need to insert
				Optional<Studentadmission> student = super.studentadmission
						.findByExRollNoAndExIsDeleteAndExIsActive(exam[0].toString(), false, true);
				List<GradeReport> gradereport = super.gradeReport
						.findByExRollNoAndCollegesIdAndCoursesIdAndProgrammesIdAndSemesterIdAndExamAnnouncementIdAndProgrammeYearIdAndRegistrationTypeIdAndDepartmentIdAndDegreeId(
								exam[0].toString(), request.getColleges(), request.getCourses(),
								request.getProgrammes(), request.getSemester(), request.getExamAnnouncement(),
								request.getProgrammeYear(), request.getRegistrationType(), request.getDepartment(),
								request.getDegree());
				if (gradereport.size() <= 0) {
					List<ExamBarcodes> validate = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentId(
									true, request.getColleges(), request.getCourses(), request.getDegree(),
									request.getExamAnnouncement(), request.getProgrammes(), request.getSemester(),
									exam[0].toString(), request.getProgrammeYear(), request.getAcademicYear(),
									request.getDepartment());
						
					if(validate.size()>0 && validate.get(0).getExIsAttendance()==null  )
					{
						info.put("status", "2");
						info.put("message", "External Marks not uploaded");
						return info;
						
					}
					
					if(validate.size()>0 &&  validate.get(0).getExIsPracticalAttendance()==null )
					{
						info.put("status", "2");
						info.put("message", "External Practical Marks not uploaded");
						return info;
						
					}
					
					
					
					GradeReport GradeReport = new GradeReport();
					GradeReport.setColleges(collage.get());
					GradeReport.setDegree(degree.get());
					GradeReport.setProgrammes(Prog.get());
					GradeReport.setDepartment(dept.get());

					GradeReport.setExamAnnouncement(result.get());
					GradeReport.setAcademicYear(academicYear.get());
					GradeReport.setProgrammeYear(programyear.get());
					GradeReport.setSemester(sem.get());
					GradeReport.setRegistrationType(RegistrationType.get(0));
					GradeReport.setExRollNo(exam[0].toString());
					GradeReport.setStudentadmission(student.get());
					GradeReport.setSection(sectionValue);

					GradeReport.setCourses(courses.get());
					GradeReport.setExCoursesCode(courses.get().getExCoursesCode());
					GradeReport.setExCoursesName(courses.get().getExName());
					GradeReport.setExCreateDate(date);
					GradeReport.setExRollNo(exam[0].toString());

					GradeReport.setUser(userresult);
					GradeReport.setExIsActive(true);
					GradeReport.setExIsDelete(false);
					// checl ExamBarcodes EndTerm Marks uploded or not
					List<ExamBarcodes> validateomr = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentIdAndExIsPracticalAttendanceAndExIsAttendance(
									true, request.getColleges(), request.getCourses(), request.getDegree(),
									request.getExamAnnouncement(), request.getProgrammes(), request.getSemester(),
									exam[0].toString(), request.getProgrammeYear(), request.getAcademicYear(),
									request.getDepartment(), true, true);
						
					
					if (validateomr.size() > 0) {
						// need to calculate grade report
						List<MidTermMarks> ispresent = super.midtermmarksMarks
								.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
										exam[0].toString(), request.getCourses(), request.getSemester(),
										request.getDegree(), request.getProgrammes(), true, false,
										request.getDepartment());
						Double internalTotal = 0.0;
						Double practicalinternalmarks = 0.0;

						if (ispresent.size() > 0) {
							double midtermWeightage = super.commonHelper
									.converToWeightageMarks(ispresent.get(0).getExMidTermMarks());
							practicalinternalmarks = (ispresent.get(0).getExPracticalRecordMarks() ==null ? 0 : ispresent.get(0).getExPracticalRecordMarks())
									+ (ispresent.get(0).getExPracticalLearning()==null ?0 : ispresent.get(0).getExPracticalLearning());
							GradeReport.setExMidTermMarks(midtermWeightage);
							GradeReport.setExQuizMarks(ispresent.get(0).getExQuizMarks());
							GradeReport.setExAssignmentMarks(ispresent.get(0).getExAssignmentMarks());
							GradeReport.setExAttendenceMarks(ispresent.get(0).getExAttendenceMarks());
							internalTotal = (midtermWeightage)
									+ (ispresent.get(0).getExQuizMarks() == null ? 0.0
											: ispresent.get(0).getExQuizMarks())
									+ (ispresent.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresent.get(0).getExAssignmentMarks())
									+ (ispresent.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresent.get(0).getExAttendenceMarks())
									+ (ispresent.get(0).getExCaseStudy() == null ? 0.0
									: ispresent.get(0).getExCaseStudy());
							GradeReport.setExPracticalInternalMarks(practicalinternalmarks);
							
							//fpor checking
							System.out.println(">>>>>>>>>>>>>>>sysytemm" + practicalinternalmarks);
							
							//fore checking
						} else {
							logger.info("MidTerm Marks not uploaded for " + exam[0].toString());
							continue;
						}

						// check Attendence SA
						Double EndtermWeightag = 0.0, PracticalExternalMarks = 0.0, grandtotal = 0.0;
						if (!commonHelper.checkAttendenceSA(ispresent)) {
							PracticalExternalMarks = (validateomr.get(0).getExLabExperiment() == null ? 0.0
									: validateomr.get(0).getExLabExperiment())
									+ (validateomr.get(0).getExViva() == null ? 0.0 : validateomr.get(0).getExViva());
									

							// true - no shortage of attendence
							GradeReport.setExPracticalExternalMarks(
									validateomr.get(0).getExLabExperiment() + validateomr.get(0).getExViva());

							EndtermWeightag = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							GradeReport.setExEndTermMarks(EndtermWeightag);
							Double theorygrandtotal = (EndtermWeightag == null ? 0 : EndtermWeightag)
									+ (internalTotal == 0 ? 0 : internalTotal);
							Double practicalgrandtotal = practicalinternalmarks + PracticalExternalMarks;
							int totalcerdits = (int) (courses.get().getCreditHours().getExCreditHourPractical()
									+ courses.get().getCreditHours().getExCreditHourLecture());

							Double practicalcredi = (practicalgrandtotal
									* courses.get().getCreditHours().getExCreditHourPractical()) / totalcerdits;
							Double theorycredi = (theorygrandtotal
									* (courses.get().getCreditHours().getExCreditHourLecture()))
									/ totalcerdits;

							GradeReport.setExGrandTotal(
									(double) (super.commonHelper.roundOffInt(practicalcredi + theorycredi)));
							double newInput = super.commonHelper.roundOff(practicalcredi + theorycredi);

							String exLetterGrades = super.commonHelper.getLetterGrade(practicalcredi + theorycredi , request.getRegistrationType());
							
							if(courses.get().getExIsSatisfactory()==true) {								
								String stastexLetterGrades = super.commonHelper.getLetterGradeSatisfactory(practicalcredi + theorycredi);
								GradeReport.setExLetterGrades(stastexLetterGrades);	
							}							
							else {
								
								//====== important start :- letter grade and point grade settings(if theory <40 and practical<50 letter grade=f and point grade=0
							GradeReport.setExLetterGrades(exLetterGrades);
							}
							double finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);
							GradeReport.setExGradePoint(finalgradepoint);

							Boolean passfail = commonHelper.checkPassOrFailedforTP(newInput, EndtermWeightag,
									internalTotal, practicalgrandtotal);
							if (passfail) {
								GradeReport.setExRemark("Pass");
								GradeReport.setExCoursesStatus(1);
							} else {
								GradeReport.setExRemark("Fail");
								//
								GradeReport.setExLetterGrades("F");
								GradeReport.setExGradePoint(0.0);
								//
								GradeReport.setExCoursesStatus(0);
							}
							
							Double prctical = courses.get().getCreditHours().getExCreditHourPractical(); 							
							GradeReport.setExCreditPoint(finalgradepoint * (courses.get().getCreditHours().getExCreditHourLecture()+ prctical));
					
						} else {
							// student has SA
							if (ispresent.size() <= 0) {
								GradeReport.setExRemark("");
							} else {
								GradeReport.setExRemark(ispresent.get(0).getExMidTermRemarks());
							}

							GradeReport.setExCoursesStatus(0);
							GradeReport.setExEndTermMarks(0.0);
							GradeReport.setExMidTermMarks(0.0);
							GradeReport.setExGradePoint(0.0);
							GradeReport.setExQuizMarks(0.0);
							GradeReport.setExAssignmentMarks(0.0);
							GradeReport.setExAttendenceMarks(0.0);
							GradeReport.setExCaseStudy(0.0);
						}

					} else {
						// student is absent
						GradeReport.setExRemark("Incomplete");
						GradeReport.setExCoursesStatus(0);
						GradeReport.setExEndTermMarks(0.0);
						GradeReport.setExMidTermMarks(0.0);
						GradeReport.setExGradePoint(0.0);
						GradeReport.setExQuizMarks(0.0);
						GradeReport.setExAssignmentMarks(0.0);
						GradeReport.setExAttendenceMarks(0.0);
						GradeReport.setExCaseStudy(0.0);
					}
					// Update status for last semester
					super.gradeReport.updateStatus(false, true, request.getSemester(), request.getProgrammes(), request.getCourses(), student.get().getId(), request.getColleges());
					super.gradeReport.save(GradeReport);
					logger.info("Grade Report created for  " + exam[0].toString());
				} else {

					// checl ExamBarcodes EndTerm uploded or not
					Double finalgradepoint = 0.0, PracticalExternalMarks = 0.0, practicalinternalmarks = 0.0,
							Endterm = 0.0, quizMarks = 0.0, asst = 0.0, atte = 0.0, grand_total = 0.0,
							grade_point = 0.0, midtermWeightage = 0.0, internalTotal = 0.0, creditpoint = 0.0 , casestudy = 0.0;
					Boolean passorfail = false;
					String remark = "", exLetterGrades = "";
					int course_status = 0;
					List<ExamBarcodes> validateomr = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentId(
									true, request.getColleges(), request.getCourses(), request.getDegree(),
									request.getExamAnnouncement(), request.getProgrammes(), request.getSemester(),
									exam[0].toString(), request.getProgrammeYear(), request.getAcademicYear(),
									request.getDepartment());
					if (validateomr.size() > 0) {
						// need to calculate grade report
						List<MidTermMarks> ispresentr = super.midtermmarksMarks
								.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
										exam[0].toString(), request.getCourses(), request.getSemester(),
										request.getDegree(), request.getProgrammes(), true, false,
										request.getDepartment());
						if (!commonHelper.checkAttendenceSA(ispresentr)) {
							Endterm = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							midtermWeightage = super.commonHelper
									.converToWeightageMarks(ispresentr.get(0).getExMidTermMarks());

							quizMarks = ispresentr.get(0).getExQuizMarks() == null ? 0.0
									: ispresentr.get(0).getExQuizMarks();
							asst = ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
									: ispresentr.get(0).getExAssignmentMarks();
							atte = ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
									: ispresentr.get(0).getExAttendenceMarks();
							casestudy = ispresentr.get(0).getExCaseStudy() == null ? 0.0
									: ispresentr.get(0).getExCaseStudy();

							internalTotal = (midtermWeightage)
									+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
											: ispresentr.get(0).getExQuizMarks())
									+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresentr.get(0).getExAssignmentMarks())
									+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresentr.get(0).getExAttendenceMarks())
									+	(ispresentr.get(0).getExCaseStudy() == null ? 0.0
											: ispresentr.get(0).getExCaseStudy());

							if (ispresentr.size() > 0) {
								practicalinternalmarks = ispresentr.get(0).getExPracticalRecordMarks()
										+ ispresentr.get(0).getExPracticalLearning();

								//for checking
								System.out.println("sfsfsffsfsffs>>>>>>>>>>>>"+practicalinternalmarks );
								//for checking
								
								internalTotal = (midtermWeightage)
										+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
												: ispresentr.get(0).getExQuizMarks())
										+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
												: ispresentr.get(0).getExAssignmentMarks())
										+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
												: ispresentr.get(0).getExAttendenceMarks())
										+	(ispresentr.get(0).getExCaseStudy() == null ? 0.0
												: ispresentr.get(0).getExCaseStudy());
							}

							Endterm = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							double midtermWeight = super.commonHelper
									.converToWeightageMarks(ispresentr.get(0).getExMidTermMarks());
							internalTotal = (midtermWeight)
									+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
											: ispresentr.get(0).getExQuizMarks())
									+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresentr.get(0).getExAssignmentMarks())
									+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresentr.get(0).getExAttendenceMarks())
									+	(ispresentr.get(0).getExCaseStudy() == null ? 0.0
											: ispresentr.get(0).getExCaseStudy());

							PracticalExternalMarks = (validateomr.get(0).getExLabExperiment() == null ? 0.0
									: validateomr.get(0).getExLabExperiment())
									+ (validateomr.get(0).getExViva() == null ? 0.0 : validateomr.get(0).getExViva());
									

							Double theorygrandtotal = (Endterm == null ? 0 : Endterm)
									+ (internalTotal == 0 ? 0 : internalTotal);
							Double practicalgrandtotal = practicalinternalmarks + PracticalExternalMarks;
							int totalcerdits = (int) (courses.get().getCreditHours().getExCreditHourPractical()
									+ courses.get().getCreditHours().getExCreditHourLecture());
							logger.info("theorygrandtotal" + theorygrandtotal);

							logger.info("practicalgrandtotal" + practicalgrandtotal);

							Double practicalcredi = (practicalgrandtotal
									* courses.get().getCreditHours().getExCreditHourPractical()) / totalcerdits;
							Double theorycredi = (theorygrandtotal
									* (courses.get().getCreditHours().getExCreditHourLecture()))
									/ totalcerdits;

							grand_total = practicalcredi + theorycredi;
							double newInput = super.commonHelper.roundOff(grand_total);
							logger.info("grand_total" + grand_total);

							grade_point = ((double) (super.commonHelper.roundOffInt(newInput)));
							exLetterGrades = super.commonHelper.getLetterGrade(grand_total , request.getRegistrationType());
							finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);

							
							if(courses.get().getExIsSatisfactory()==true) {								
								exLetterGrades= super.commonHelper.getLetterGradeSatisfactory(practicalcredi + theorycredi);
							}								
							
							Boolean passfail = commonHelper.checkPassOrFailedforTP(newInput, Endterm, internalTotal,
									practicalgrandtotal);
							logger.info("passfail :" + passfail + "grade_point : " + finalgradepoint + "Endterm :"
									+ Endterm + " Midterm : " + midtermWeightage);
							if (passfail) {
								course_status = 1;
								remark = "Pass";
							
							} else {
								course_status = 0;
								remark = "Fail";
								//
								finalgradepoint=0.0;
								exLetterGrades="F";
								//
							}
							Double prctical = courses.get().getCreditHours().getExCreditHourPractical(); 													
							creditpoint = finalgradepoint * (prctical+ courses.get().getCreditHours().getExCreditHourLecture());
						} else {
							remark = "I";
							if (ispresentr.size() <= 0) {
								remark = "";
							} else {
								remark = ispresentr.get(0).getExMidTermRemarks();
							}
						}
					} else {
						// student is absent
						course_status = 0;
						remark = "Incomplete";
					}
					int retval = super.gradeReport.updateGradeReport(course_status, remark, Endterm, midtermWeightage,
							(double) (super.commonHelper.roundOffInt(grand_total)), finalgradepoint, date, creditpoint,
							request.getSemester(), request.getProgrammes(), request.getExamAnnouncement(),
							request.getCourses(), exam[0].toString(), request.getColleges(), userresult,
							request.getDepartment(), quizMarks, asst, atte, exLetterGrades , casestudy,PracticalExternalMarks,practicalinternalmarks);
					logger.info("Grade Report updated for  " + exam[0].toString());
				}
			}
			// grade report log
			String ExReportType = "GradeReport";
			Boolean gradeReortLog = gradeReortLoger(result.get(), academicYear.get(), collage.get(), degree.get(),
					courses.get(), Prog.get(), sem.get(), request.getExRemark(), userresult, ExIsReGenerated,
					ExReportType, RegistrationType.get(0), dept.get(), programyear.get(),hSet,courses.get().getBatch());
			if (gradeReortLog == true) {
				info.put("status", "1");
				info.put("message", "Grade report generated successfully.");
				info.put("generatedCount", duplicate.size() <= 0 ? 1 : duplicate.size() + 1);
				return info;
			} else {
				info.put("status", "3");
				info.put("message", "Grade report not generated");
				return info;
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}

	private Map<String, Object> generateMigGradereport(GradeReportRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			logger.info("Inside generateGradeReport");
	
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),
					false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear
					.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			
			List<RegistrationType> RegistrationType = super.registrationType
					.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (RegistrationType.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType id not present");
				return info;
			}

			Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(), false,
					true);
			if (!courses.isPresent()) {
				info.put("status", "2");
				info.put("message", "courses not  present");
				return info;

			}
			
			String sectionval  = "";
			List<Long> list = new ArrayList();
			
			if(request.getSection().size()>0) {		
				for(int i =0 ; i<request.getSection().size() ; i++) {
				//	Integer number = (Integer) request.getSection().get(i);
				//	Long sec = new Long(number);
					Optional<Section> section  = super.section.findByExIsDeleteAndExIsActiveAndId( false, true,request.getSection().get(i));
					if(!section.isPresent()) {
						info.put("status", "2");
						info.put("message", "Section not present.");
						return info;
					}		
					list.add(section.get().getId());
					sectionval = sectionval+request.getSection().get(i)+",";
				}	
				sectionval =  sectionval.substring(0, sectionval.length() -1);
				sectionval = " AND s.section IN ( "+sectionval+" )";
			}else {
				List<Section> slist  = super.section.findByExIsDeleteAndExIsActive(false, true);				
				for(Section sec : slist) {
					list.add(sec.getId());
				}
			}
			
			User userresult = null;
			String ExIsReGenerated = "Generated";
			if (request.getUser() == null || request.getUser().equals("")) {
				userresult = null;
			} else {
				List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
				userresult = user.get(0);
			}					
			List<GradeReportLog> duplicate = super.GradeReportLog
					.findByExamAnnouncementIdAndAcademicYearIdAndCollegesIdAndProgrammesIdAndExReportTypeAndDegreeIdAndCoursesIdAndSemesterIdAndExReportCategoryAndDepartmentIdAndSectionIdIn(
							request.getExamAnnouncement(), request.getAcademicYear(), request.getColleges(),
							request.getProgrammes(), "gradeReport", request.getDegree(), request.getCourses(),
							request.getSemester(), "Generate", request.getDepartment(),list);
			if (duplicate.size() > 0) {
				if (request.getExRemark() == null || request.getExRemark().equalsIgnoreCase("null")
						|| request.getExRemark().equals("") || request.getExRemark().trim().isEmpty()) {
					info.put("status", "2");
					info.put("message", "Please provide valid reason for regenerating grade report");
					return info;
				}
				ExIsReGenerated = "ReGenerated";
			}
		
			List<Object[]> examAttendance = super.accademicdao.getMigExamdetails(false, request.getAcademicYear(),
					request.getColleges(), request.getCourses(), request.getDegree(),
					request.getProgrammes(), request.getRegistrationType(), request.getDepartment(),sectionval);
			if (examAttendance.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Exam attendance not created");
				return info;
			}

			 
			  
			List<MidTermMarks> internal = super.midtermmarksMarks
					.findByCollegesIdAndDegreeIdAndProgrammesIdAndCoursesIdAndSemesterIdAndExIsActiveAndExIsDeleteAndProgrammeYearIdAndDepartmentId(
							request.getColleges(), request.getDegree(), request.getProgrammes(), request.getCourses(),
							request.getSemester(), true, false, request.getProgrammeYear(), request.getDepartment());
			if (internal.size() <= 0) {
				info.put("status", "2");
				info.put("message", "MidTerm Marks not uploded");
				return info;
			}
			List<ExamBarcodes> ormmarks = super.exambarcode.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndProgrammesIdAndSemesterIdAndAcademicYearIdAndRegistrationTypeIdAndDepartmentId(
							true, request.getColleges(), request.getCourses(), request.getDegree(),
							 request.getProgrammes(), request.getSemester(),
							request.getAcademicYear(), request.getRegistrationType(), request.getDepartment());
			if (ormmarks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "EndTerm marks not uploded");
				return info;
			}
		if(courses.get().getCoursesType().size()==1) {
				  if(courses.get().getCoursesType().get(0).getId() == 1) {
					  // theory courses  need to update with diffrent way yyyttttrrreewyt					 
					  return createMigTherorygradeReport(examAttendance , degree , collage , Prog ,
				  courses , sem , academicYear , programyear , RegistrationType ,userresult ,
				  duplicate , ExIsReGenerated , request.getExRemark(),dept);
				  }		  		  
		  if(courses.get().getCoursesType().get(0).getId() == 2) { 
			  // practical courses need to update with diffrent way
			 return createMigPracticalgradeReport(examAttendance , degree , collage , Prog , courses , sem , academicYear , programyear , RegistrationType ,userresult , duplicate , ExIsReGenerated , request.getExRemark(),dept); }
		 
		  }
			Date date = new Date();

			Set<Section> hSet = new HashSet<Section>(); 
			for (Object[] exam : examAttendance) { 
				Section sectionValue=null ;

				if(exam[1].toString()== null || exam[1].toString().equals("") || exam[1].toString().equals("NA")) {
					sectionValue=null;
				}else {
					long section_id = Long.parseLong(exam[1].toString());
					Optional<Section> userSection = super.section.findByExIsDeleteAndExIsActiveAndId( false,true,section_id);	
					if(userSection.isPresent()) {
						sectionValue=userSection.get();
					}else {
						sectionValue=null;
					}	
					hSet.add(sectionValue);
				}
				
				// mendetory field need to insert
				Optional<Studentadmission> student = super.studentadmission
						.findByExRollNoAndExIsDeleteAndExIsActive(exam[0].toString(), false, true);
				List<GradeReport> gradereport = super.gradeReport.findByExRollNoAndCollegesIdAndCoursesIdAndProgrammesIdAndSemesterIdAndProgrammeYearIdAndRegistrationTypeIdAndDepartmentIdAndDegreeIdAndAcademicYearId(
								exam[0].toString(), request.getColleges(), request.getCourses(),
								request.getProgrammes(), request.getSemester(),
								request.getProgrammeYear(), request.getRegistrationType(), request.getDepartment(),
								request.getDegree() , request.getAcademicYear());
				if (gradereport.size() <= 0) {
					GradeReport GradeReport = new GradeReport();
					GradeReport.setColleges(collage.get());
					GradeReport.setDegree(degree.get());
					GradeReport.setProgrammes(Prog.get());
					GradeReport.setDepartment(dept.get());

					GradeReport.setExamAnnouncement(null);
					GradeReport.setAcademicYear(academicYear.get());
					GradeReport.setProgrammeYear(programyear.get());
					GradeReport.setSemester(sem.get());
					GradeReport.setRegistrationType(RegistrationType.get(0));
					GradeReport.setExRollNo(exam[0].toString());
					GradeReport.setStudentadmission(student.get());
					GradeReport.setSection(sectionValue);

					GradeReport.setCourses(courses.get());
					GradeReport.setExCoursesCode(courses.get().getExCoursesCode());
					GradeReport.setExCoursesName(courses.get().getExName());
					GradeReport.setExCreateDate(date);
					GradeReport.setExRollNo(exam[0].toString());

					GradeReport.setUser(userresult);
					GradeReport.setExIsActive(true);
					GradeReport.setExIsDelete(false);
					// checl ExamBarcodes EndTerm Marks uploded or not
					List<ExamBarcodes> validateomr = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentIdAndExIsPracticalAttendanceAndExIsAttendanceAndRegistrationTypeId(
									true, request.getColleges(), request.getCourses(), request.getDegree(),
									 request.getProgrammes(), request.getSemester(),
									exam[0].toString(), request.getProgrammeYear(), request.getAcademicYear(),
									request.getDepartment(), true, true , request.getRegistrationType());

					if (validateomr.size() > 0) {
						// need to calculate grade report
						List<MidTermMarks> ispresent = super.midtermmarksMarks
								.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
										exam[0].toString(), request.getCourses(), request.getSemester(),
										request.getDegree(), request.getProgrammes(), true, false,
										request.getDepartment());
						Double internalTotal = 0.0;
						Double practicalinternalmarks = 0.0;

						if (ispresent.size() > 0) {
							double midtermWeightage = super.commonHelper
									.converToWeightageMarks(ispresent.get(0).getExMidTermMarks());
							practicalinternalmarks = ispresent.get(0).getExPracticalRecordMarks()
									+ ispresent.get(0).getExPracticalLearning();
							GradeReport.setExMidTermMarks(midtermWeightage);
							GradeReport.setExQuizMarks(ispresent.get(0).getExQuizMarks());
							GradeReport.setExAssignmentMarks(ispresent.get(0).getExAssignmentMarks());
							GradeReport.setExAttendenceMarks(ispresent.get(0).getExAttendenceMarks());
							internalTotal = (midtermWeightage)
									+ (ispresent.get(0).getExQuizMarks() == null ? 0.0
											: ispresent.get(0).getExQuizMarks())
									+ (ispresent.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresent.get(0).getExAssignmentMarks())
									+ (ispresent.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresent.get(0).getExAttendenceMarks());

							GradeReport.setExPracticalInternalMarks(practicalinternalmarks);

						} else {
							logger.info("MidTerm Marks not uploaded for " + exam[0].toString());
							continue;
						}

						// check Attendence SA
						Double EndtermWeightag = 0.0, PracticalExternalMarks = 0.0, grandtotal = 0.0;
						if (!commonHelper.checkAttendenceSA(ispresent)) {
							PracticalExternalMarks = (validateomr.get(0).getExLabExperiment() == null ? 0.0
									: validateomr.get(0).getExLabExperiment())
									+ (validateomr.get(0).getExViva() == null ? 0.0 : validateomr.get(0).getExViva());

							// true - no shortage of attendence
							GradeReport.setExPracticalExternalMarks(
									validateomr.get(0).getExLabExperiment() + validateomr.get(0).getExViva());

							EndtermWeightag = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							GradeReport.setExEndTermMarks(EndtermWeightag);
							Double theorygrandtotal = (EndtermWeightag == null ? 0 : EndtermWeightag)
									+ (internalTotal == 0 ? 0 : internalTotal);
							Double practicalgrandtotal = practicalinternalmarks + PracticalExternalMarks;
							int totalcerdits = (int) (courses.get().getCreditHours().getExCreditHourPractical()
									+ courses.get().getCreditHours().getExCreditHourLecture());

							Double practicalcredi = (practicalgrandtotal*courses.get().getCreditHours().getExCreditHourPractical()) / totalcerdits;
							Double theorycredi = (theorygrandtotal* (courses.get().getCreditHours().getExCreditHourLecture() ))/ totalcerdits;

							GradeReport.setExGrandTotal((double) (super.commonHelper.roundOffInt(practicalcredi + theorycredi)));
							
							double newInput = super.commonHelper.roundOff(practicalcredi + theorycredi);

							String exLetterGrades = super.commonHelper.getLetterGrade(practicalcredi + theorycredi , request.getRegistrationType());
							
						
							double finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);
							

							Boolean passfail = commonHelper.checkPassOrFailedforTP(newInput, EndtermWeightag,
									internalTotal, practicalgrandtotal);
							if (passfail) {
								GradeReport.setExRemark("Pass");
								GradeReport.setExCoursesStatus(1);
							} else {
								GradeReport.setExRemark("Fail");
								GradeReport.setExCoursesStatus(0);
								exLetterGrades = "F";
								finalgradepoint = 0.0;
							}
							GradeReport.setExGradePoint(finalgradepoint);
							if(courses.get().getExIsSatisfactory()==true) {								
								String stastexLetterGrades = super.commonHelper.getLetterGradeSatisfactory(practicalcredi + theorycredi);
								GradeReport.setExLetterGrades(stastexLetterGrades);	
							}							
							else { 
								 if(EndtermWeightag !=null && EndtermWeightag == 0) {
									 exLetterGrades = "I";
								 }
							GradeReport.setExLetterGrades(exLetterGrades);
							}
							
							
							Double prctical = courses.get().getCreditHours().getExCreditHourPractical(); 							
							GradeReport.setExCreditPoint(finalgradepoint * (courses.get().getCreditHours().getExCreditHourLecture()+ prctical));
						
						} else {
							// student has SA
							if (ispresent.size() <= 0) {
								GradeReport.setExRemark("");
							} else {
								GradeReport.setExRemark(ispresent.get(0).getExMidTermRemarks());
							}

							GradeReport.setExCoursesStatus(0);
							GradeReport.setExEndTermMarks(0.0);
							GradeReport.setExMidTermMarks(0.0);
							GradeReport.setExGradePoint(0.0);
							GradeReport.setExQuizMarks(0.0);
							GradeReport.setExAssignmentMarks(0.0);
							GradeReport.setExAttendenceMarks(0.0);
						}

					} else {
						// student is absent
						GradeReport.setExRemark("Incomplete");
						GradeReport.setExCoursesStatus(0);
						GradeReport.setExEndTermMarks(0.0);
						GradeReport.setExMidTermMarks(0.0);
						GradeReport.setExGradePoint(0.0);
						GradeReport.setExQuizMarks(0.0);
						GradeReport.setExAssignmentMarks(0.0);
						GradeReport.setExAttendenceMarks(0.0);
					}
					super.gradeReport.updateStatus(false, true, sem.get().getId(), Prog.get().getId(), courses.get().getId(), student.get().getId(), collage.get().getId());
					super.gradeReport.save(GradeReport);
					logger.info("Grade Report created for  " + exam[0].toString());
				} else {

					// checl ExamBarcodes EndTerm uploded or not
					Double finalgradepoint = 0.0, PracticalExternalMarks = 0.0, practicalinternalmarks = 0.0,
							Endterm = 0.0, quizMarks = 0.0, asst = 0.0, atte = 0.0, grand_total = 0.0,
							grade_point = 0.0, midtermWeightage = 0.0, internalTotal = 0.0, creditpoint = 0.0;
					Boolean passorfail = false;
					String remark = "", exLetterGrades = "";
					int course_status = 0;
					List<ExamBarcodes> validateomr = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentIdAndRegistrationTypeId(
									true, request.getColleges(), request.getCourses(), request.getDegree(),
								 request.getProgrammes(), request.getSemester(),
									exam[0].toString(), request.getProgrammeYear(), request.getAcademicYear(),
									request.getDepartment() , request.getRegistrationType());
					if (validateomr.size() > 0) {
						// need to calculate grade report
						List<MidTermMarks> ispresentr = super.midtermmarksMarks
								.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
										exam[0].toString(), request.getCourses(), request.getSemester(),
										request.getDegree(), request.getProgrammes(), true, false,
										request.getDepartment());
						if (!commonHelper.checkAttendenceSA(ispresentr)) {
							Endterm = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							midtermWeightage = super.commonHelper
									.converToWeightageMarks(ispresentr.get(0).getExMidTermMarks());

							quizMarks = ispresentr.get(0).getExQuizMarks() == null ? 0.0
									: ispresentr.get(0).getExQuizMarks();
							asst = ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
									: ispresentr.get(0).getExAssignmentMarks();
							atte = ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
									: ispresentr.get(0).getExAttendenceMarks();

							internalTotal = (midtermWeightage)
									+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
											: ispresentr.get(0).getExQuizMarks())
									+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresentr.get(0).getExAssignmentMarks())
									+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresentr.get(0).getExAttendenceMarks());

							if (ispresentr.size() > 0) {
								practicalinternalmarks = ispresentr.get(0).getExPracticalRecordMarks()
										+ ispresentr.get(0).getExPracticalLearning();

								internalTotal = (midtermWeightage)
										+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
												: ispresentr.get(0).getExQuizMarks())
										+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
												: ispresentr.get(0).getExAssignmentMarks())
										+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
												: ispresentr.get(0).getExAttendenceMarks());
							}

							Endterm = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							double midtermWeight = super.commonHelper
									.converToWeightageMarks(ispresentr.get(0).getExMidTermMarks());
							internalTotal = (midtermWeight)
									+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
											: ispresentr.get(0).getExQuizMarks())
									+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresentr.get(0).getExAssignmentMarks())
									+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresentr.get(0).getExAttendenceMarks());

							PracticalExternalMarks = (validateomr.get(0).getExLabExperiment() == null ? 0.0
									: validateomr.get(0).getExLabExperiment())
									+ (validateomr.get(0).getExViva() == null ? 0.0 : validateomr.get(0).getExViva());

							Double theorygrandtotal = (Endterm == null ? 0 : Endterm)
									+ (internalTotal == 0 ? 0 : internalTotal);
							Double practicalgrandtotal = practicalinternalmarks + PracticalExternalMarks;
						
							logger.info("theorygrandtotal" + theorygrandtotal);

							logger.info("practicalgrandtotal" + practicalgrandtotal);

							int totalcerdits = (int) (courses.get().getCreditHours().getExCreditHourPractical()
									+ courses.get().getCreditHours().getExCreditHourLecture());

							Double practicalcredi = (practicalgrandtotal*courses.get().getCreditHours().getExCreditHourPractical()) / totalcerdits;
							Double theorycredi = (theorygrandtotal* (courses.get().getCreditHours().getExCreditHourLecture() ))/ totalcerdits;

							grand_total = practicalcredi + theorycredi;
							double newInput = super.commonHelper.roundOff(grand_total);
							logger.info("grand_total" + grand_total);

							grade_point = ((double) (super.commonHelper.roundOffInt(newInput)));
							exLetterGrades = super.commonHelper.getLetterGrade(grand_total ,  request.getRegistrationType());
							finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);																					
							logger.info(exam[0].toString()+"+lllljjjjj"+grand_total+"jjjllllllll" + exLetterGrades);													
							Boolean passfail = commonHelper.checkPassOrFailedforTP(newInput, Endterm, internalTotal,
									practicalgrandtotal);
							
							logger.info(exam[0].toString()+" passfail :" + passfail );
							logger.info(exam[0].toString()+" newInput :" + newInput );
							logger.info(exam[0].toString()+" Endterm :" + Endterm );
							logger.info(exam[0].toString()+" internalTotal :" + internalTotal );
							logger.info(exam[0].toString()+" practicalgrandtotal :" + practicalgrandtotal );
							
							logger.info("passfail :" + passfail + "grade_point : " + finalgradepoint + "Endterm :"
									+ Endterm + " Midterm : " + midtermWeightage);
							if (passfail) {
								course_status = 1;
								remark = "Pass";
							} else {
								course_status = 0;
								remark = "Fail";
								exLetterGrades = "F";
								finalgradepoint = 0.0;
								 if(Endterm !=null && Endterm == 0) {
									 exLetterGrades = "I";
								 }
							}
							if(courses.get().getExIsSatisfactory()==true) {								
								exLetterGrades= super.commonHelper.getLetterGradeSatisfactory(practicalcredi + theorycredi);
							}
							
							Double prctical = courses.get().getCreditHours().getExCreditHourPractical(); 													
							creditpoint = finalgradepoint * (prctical+ courses.get().getCreditHours().getExCreditHourLecture());
						} else {
							remark = "I";
							if (ispresentr.size() <= 0) {
								remark = "";
							} else {
								remark = ispresentr.get(0).getExMidTermRemarks();
							}
						}
					} else {
						// student is absent
						course_status = 0;
						remark = "Incomplete";
					} //gradereport
					int retval = super.gradeReport.updateMigGradeReport(course_status, remark,exLetterGrades ,
							(double) (super.commonHelper.roundOffInt(grand_total)), finalgradepoint,date,
							creditpoint, userresult,Endterm,midtermWeightage,gradereport.get(0).getId());
					
					logger.info("Grade Report updated for1111  " + exam[0].toString());
				}
			}
			// grade report log
			String ExReportType = "GradeReport";
			Boolean gradeReortLog = gradeReortLoger(null, academicYear.get(), collage.get(), degree.get(),
					courses.get(), Prog.get(), sem.get(), request.getExRemark(), userresult, ExIsReGenerated,
					ExReportType, RegistrationType.get(0), dept.get(), programyear.get(),hSet,courses.get().getBatch());
			if (gradeReortLog == true) {
				info.put("status", "1");
				info.put("message", "Grade report generated successfully.");
				info.put("generatedCount", duplicate.size() <= 0 ? 1 : duplicate.size() + 1);
				return info;
			} else {
				info.put("status", "3");
				info.put("message", "Grade report not generated");
				return info;
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}

	

	private Map<String, Object> createMigPracticalgradeReport(List<Object[]> examAttendance, Optional<Degree> degree,
			Optional<Colleges> collage, Optional<Programmes> prog, Optional<Courses> courses, Optional<Semster> sem,
			Optional<AcademicYear> academicYear, Optional<ProgrammeYear> programyear,
			List<RegistrationType> registrationType, User userresult,
			List<com.niftem.app.entity.GradeReportLog> duplicate, String exIsReGenerated, String exRemark,
			Optional<Department> dept) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			String exLetterGrades = "";
			Double midtermmarks = 0.0, endterm = 0.0;
			Date date = new Date();
			
			Set<Section> hSet = new HashSet<Section>(); 

			for (Object[] exam : examAttendance) {
				Section sectionValue=null ;

				if(exam[1].toString()== null || exam[1].toString().equals("") || exam[1].toString().equals("NA")) {
					sectionValue=null;
				}else {
					long section_id = Long.parseLong(exam[1].toString());
					Optional<Section> userSection = super.section.findByExIsDeleteAndExIsActiveAndId(false,true,section_id);	
					if(userSection.isPresent()) {
						sectionValue=userSection.get();
					}else {
						sectionValue=null;
					}	
					hSet.add(sectionValue);
				}
				
								
				
				Optional<Studentadmission> student = super.studentadmission
						.findByExRollNoAndExIsDeleteAndExIsActive(exam[0].toString(), false, true);
				List<MidTermMarks> ispresent = super.midtermmarksMarks
						.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
								exam[0].toString(), courses.get().getId(), sem.get().getId(), degree.get().getId(),
								prog.get().getId(), true, false, dept.get().getId());
				List<ExamBarcodes> validateomr = super.exambarcode
						.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentIdAndExIsPracticalAttendanceAndRegistrationTypeId(
								true, collage.get().getId(), courses.get().getId(), degree.get().getId(),
								 prog.get().getId(), sem.get().getId(), exam[0].toString(),
								programyear.get().getId(), academicYear.get().getId(), dept.get().getId(), true , registrationType.get(0).getId());
				List<GradeReport> gradereport = super.gradeReport
						.findByExRollNoAndCollegesIdAndCoursesIdAndProgrammesIdAndSemesterIdAndProgrammeYearIdAndRegistrationTypeIdAndDepartmentIdAndDegreeIdAndAcademicYearId(
								exam[0].toString(), collage.get().getId(), courses.get().getId(), prog.get().getId(),
								sem.get().getId(),  programyear.get().getId(),
								registrationType.get(0).getId(), dept.get().getId(), degree.get().getId() , academicYear.get().getId());
				if (gradereport.size() <= 0) {
					GradeReport GradeReport = new GradeReport();
					GradeReport.setColleges(collage.get());
					GradeReport.setDegree(degree.get());
					GradeReport.setProgrammes(prog.get());
					GradeReport.setDepartment(dept.get());
					GradeReport.setSection(sectionValue);

					GradeReport.setExamAnnouncement(null);
					GradeReport.setAcademicYear(academicYear.get());
					GradeReport.setProgrammeYear(programyear.get());
					GradeReport.setSemester(sem.get());
					GradeReport.setRegistrationType(registrationType.get(0));
					GradeReport.setExRollNo(exam[0].toString());
					GradeReport.setStudentadmission(student.get());

					GradeReport.setCourses(courses.get());
					GradeReport.setExCoursesCode(courses.get().getExCoursesCode());
					GradeReport.setExCoursesName(courses.get().getExName());
					GradeReport.setExCreateDate(date);

					GradeReport.setUser(userresult);
					GradeReport.setExIsActive(true);
					GradeReport.setExIsDelete(false);

					if (ispresent.get(0).getExPracticalRecordMarks() != null
							&& ispresent.get(0).getExPracticalLearning() != null) {
						midtermmarks = ispresent.get(0).getExPracticalRecordMarks()
								+ ispresent.get(0).getExPracticalLearning();
					}
					GradeReport.setExPracticalInternalMarks(midtermmarks);
					if (validateomr.size() > 0) {
						endterm = (validateomr.get(0).getExLabExperiment() == null ? 0.0
								: validateomr.get(0).getExLabExperiment())
								+ (validateomr.get(0).getExViva() == null ? 0.0 : validateomr.get(0).getExViva());
						GradeReport.setExPracticalExternalMarks(endterm);

						Double total = midtermmarks + endterm;
						double grandtotal = total == null ? 0.0 : total;
						
						GradeReport.setExGrandTotal((double) (super.commonHelper.roundOffInt(grandtotal)));
						double newInput = super.commonHelper.roundOff(grandtotal);

						 exLetterGrades = super.commonHelper.getLetterGrade(grandtotal ,registrationType.get(0).getId());
										
												
						if (grandtotal >= 50.0) {
							GradeReport.setExRemark("Pass");
							GradeReport.setExCoursesStatus(1);
						} else {
							GradeReport.setExRemark("Fail");
							GradeReport.setExCoursesStatus(0);
							exLetterGrades = "F";
						}
						
						if(courses.get().getExIsSatisfactory()==true) {								
							String stastexLetterGrades = super.commonHelper.getLetterGradeSatisfactory(grandtotal);
							GradeReport.setExLetterGrades(stastexLetterGrades);	
						}							
						else {
						GradeReport.setExLetterGrades(exLetterGrades);
						}
						double finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);
						GradeReport.setExGradePoint(finalgradepoint);
						
						Double prctical = courses.get().getCreditHours().getExCreditHourPractical(); 
						
						GradeReport.setExCreditPoint(finalgradepoint* prctical);
					} else {
						GradeReport.setExRemark("InComplete");
						GradeReport.setExCoursesStatus(0);
						GradeReport.setExGradePoint(0.0);
						GradeReport.setExLetterGrades("I");
					}
					
					super.gradeReport.updateStatus(false, true, sem.get().getId(), prog.get().getId(), courses.get().getId(), student.get().getId(), collage.get().getId());
				
					super.gradeReport.save(GradeReport);

				} else {
					int course_status = 0;
					String remark1 = "";
					Double grandtotal = 0.0;
					Double creditpoint = 0.0 ,finalgradepoint=0.0;
					if (ispresent.get(0).getExPracticalRecordMarks() != null
							&& ispresent.get(0).getExPracticalLearning() != null) {
						midtermmarks = ispresent.get(0).getExPracticalRecordMarks()
								+ ispresent.get(0).getExPracticalLearning();
					}
					if (validateomr.size() > 0) {
						endterm = (validateomr.get(0).getExLabExperiment() == null ? 0.0
								: validateomr.get(0).getExLabExperiment())
								+ (validateomr.get(0).getExViva() == null ? 0.0 : validateomr.get(0).getExViva());
						Double total = midtermmarks + endterm;
					
						
						
						grandtotal=	(double) (super.commonHelper.roundOffInt(total));
					
						
						 exLetterGrades = super.commonHelper.getLetterGrade(grandtotal ,  registrationType.get(0).getId());

							 finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);
						
						
							 if(courses.get().getExIsSatisfactory()==true) {								
									exLetterGrades= super.commonHelper.getLetterGradeSatisfactory(grandtotal);
								}							

						if (grandtotal >= 50.0) {
							course_status = 1;
							remark1 = "Pass";
						} else {
							course_status = 0;
							remark1 = "Fail";
							exLetterGrades = "F";
							if(grandtotal == 0  || grandtotal == 0.0) {
								exLetterGrades = "I";
							}														
							finalgradepoint = 0.0;
						}
						Double prctical = courses.get().getCreditHours().getExCreditHourPractical(); 						
						creditpoint = (finalgradepoint* prctical);
					} else {
						remark1 = "InComplete";
						exLetterGrades = "I";
						

					}
					
					int retval =super.gradeReport.updateMigGradeReport(course_status, remark1,exLetterGrades ,
							(double) (super.commonHelper.roundOffInt(grandtotal)), finalgradepoint,date,
							creditpoint, userresult,endterm,midtermmarks,gradereport.get(0).getId());
					logger.info(exam[0].toString() + " : Update query status : " + retval);

				}
				
			}
			String ExReportType = "GradeReport";
			Boolean gradeReortLog = gradeReortLoger(null, academicYear.get(), collage.get(), degree.get(),
					courses.get(), prog.get(), sem.get(), exRemark, userresult, exIsReGenerated, ExReportType,
					registrationType.get(0), dept.get(), programyear.get(),hSet,courses.get().getBatch());
			if (gradeReortLog == true) {
				info.put("status", "1");
				info.put("message", "Grade Report genrated successfully.");
				info.put("genratedCount", duplicate.size() <= 0 ? 1 : duplicate.size() + 1);
				return info;
			} else {
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}
	

	private Map<String, Object> createMigTherorygradeReport(List<Object[]> examAttendance, Optional<Degree> degree,
			Optional<Colleges> collage, Optional<Programmes> prog, Optional<Courses> courses, Optional<Semster> sem,
			Optional<AcademicYear> academicYear, Optional<ProgrammeYear> programyear,
			List<RegistrationType> registrationType, User userresult,
			List<com.niftem.app.entity.GradeReportLog> duplicate, String exIsReGenerated, String exRemark,
			Optional<Department> dept) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Date date = new Date();
			Set<Section> hSet = new HashSet<Section>(); 

			for (Object[] exam : examAttendance) { // mendetory field need to insert
				Section sectionValue=null ;

				if(exam[1].toString()== null || exam[1].toString().equals("") || exam[1].toString().equals("NA")) {
					sectionValue=null;
				}else {
					long section_id = Long.parseLong(exam[1].toString());
					Optional<Section> userSection = super.section.findByExIsDeleteAndExIsActiveAndId( false,true,section_id);	
					if(userSection.isPresent()) {
						sectionValue=userSection.get();
					}else {
						sectionValue=null;
					}	
					hSet.add(sectionValue);
				}
						
				Optional<Studentadmission> student = super.studentadmission
						.findByExRollNoAndExIsDeleteAndExIsActive(exam[0].toString(), false, true);
				List<GradeReport> gradereport = super.gradeReport
						.findByExRollNoAndCollegesIdAndCoursesIdAndProgrammesIdAndSemesterIdAndProgrammeYearIdAndRegistrationTypeIdAndDepartmentIdAndDegreeIdAndAcademicYearId(
								exam[0].toString(), collage.get().getId(), courses.get().getId(), prog.get().getId(),
								sem.get().getId(),  programyear.get().getId(),
								registrationType.get(0).getId(), dept.get().getId(), degree.get().getId() , academicYear.get().getId());
				if (gradereport.size() <= 0) {

					GradeReport GradeReport = new GradeReport();
					GradeReport.setColleges(collage.get());
					GradeReport.setDegree(degree.get());
					GradeReport.setProgrammes(prog.get());
					GradeReport.setDepartment(dept.get());
					GradeReport.setSection(sectionValue);

					GradeReport.setExamAnnouncement(null);
					GradeReport.setAcademicYear(academicYear.get());
					GradeReport.setProgrammeYear(programyear.get());
					GradeReport.setSemester(sem.get());
					GradeReport.setRegistrationType(registrationType.get(0));
					GradeReport.setExRollNo(exam[0].toString());
					GradeReport.setStudentadmission(student.get());

					GradeReport.setCourses(courses.get());
					GradeReport.setExCoursesCode(courses.get().getExCoursesCode());
					GradeReport.setExCoursesName(courses.get().getExName());
					GradeReport.setExCreateDate(date);
					GradeReport.setExRollNo(exam[0].toString());

					GradeReport.setUser(userresult);
					GradeReport.setExIsActive(true);
					GradeReport.setExIsDelete(false);
					// checl ExamBarcodes EndTerm Marks uploded or not
					List<ExamBarcodes> validateomr = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentIdAndExIsAttendanceAndRegistrationTypeId(
									true, collage.get().getId(), courses.get().getId(), degree.get().getId(),
									 prog.get().getId(), sem.get().getId(), exam[0].toString(),
									programyear.get().getId(), academicYear.get().getId(), dept.get().getId(), true , registrationType.get(0).getId());

					if (validateomr.size() > 0) {
						// need to calculate grade report
						List<MidTermMarks> ispresent = super.midtermmarksMarks
								.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
										exam[0].toString(), courses.get().getId(), sem.get().getId(),
										degree.get().getId(), prog.get().getId(), true, false, dept.get().getId());
						Double internalTotal = 0.0;

						if (ispresent.size() > 0) {
							double midtermWeightage = super.commonHelper
									.converToWeightageMarks(ispresent.get(0).getExMidTermMarks());

							GradeReport.setExMidTermMarks(midtermWeightage);
							GradeReport.setExQuizMarks(ispresent.get(0).getExQuizMarks());
							GradeReport.setExAssignmentMarks(ispresent.get(0).getExAssignmentMarks());
							GradeReport.setExAttendenceMarks(ispresent.get(0).getExAttendenceMarks());
							internalTotal = (midtermWeightage)
									+ (ispresent.get(0).getExQuizMarks() == null ? 0.0
											: ispresent.get(0).getExQuizMarks())
									+ (ispresent.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresent.get(0).getExAssignmentMarks())
									+ (ispresent.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresent.get(0).getExAttendenceMarks());

						} else {
							logger.info("MidTerm Marks not uploaded for " + exam[0].toString());
							continue;
						}

						// check Attendence SA
						Double EndtermWeightag = 0.0;
						if (!commonHelper.checkAttendenceSA(ispresent)) { // true - no shortage of attendence

							EndtermWeightag = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							GradeReport.setExEndTermMarks(EndtermWeightag);
							Double grandtotal = (EndtermWeightag == null ? 0 : EndtermWeightag)
									+ (internalTotal == 0 ? 0 : internalTotal);
							GradeReport.setExGrandTotal((double) (super.commonHelper.roundOffInt(grandtotal)));
							double newInput = super.commonHelper.roundOff(grandtotal);

							String exLetterGrades = super.commonHelper.getLetterGrade(grandtotal , registrationType.get(0).getId());
							
							if(courses.get().getExIsSatisfactory()==true) {								
								String stastexLetterGrades = super.commonHelper.getLetterGradeSatisfactory(grandtotal);
								GradeReport.setExLetterGrades(stastexLetterGrades);	
							}else {
								 if(EndtermWeightag !=null && EndtermWeightag == 0) {
									 exLetterGrades = "I";
								 }
								 GradeReport.setExLetterGrades(exLetterGrades);
							}

							double finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);
							GradeReport.setExGradePoint(finalgradepoint);

							Boolean passfail = commonHelper.checkPassOrFailed(newInput, EndtermWeightag, internalTotal);
							if (passfail) {
								GradeReport.setExRemark("Pass");
								GradeReport.setExCoursesStatus(1);
							} else {
								GradeReport.setExRemark("Fail");
								GradeReport.setExCoursesStatus(0);
							}
							GradeReport.setExCreditPoint(
									finalgradepoint * (courses.get().getCreditHours().getExCreditHourLecture()));

						} else {
							// student has SA
							if (ispresent.size() <= 0) {
								GradeReport.setExRemark("");
							} else {
								GradeReport.setExRemark(ispresent.get(0).getExMidTermRemarks());
							}
                    		GradeReport.setExCoursesStatus(0);
							GradeReport.setExEndTermMarks(0.0);
							GradeReport.setExMidTermMarks(0.0);
							GradeReport.setExGradePoint(0.0);
							GradeReport.setExQuizMarks(0.0);
							GradeReport.setExAssignmentMarks(0.0);
							GradeReport.setExAttendenceMarks(0.0);
						}

					} else {
						// student is absent
						GradeReport.setExRemark("Absent");
						GradeReport.setExCoursesStatus(0);
						GradeReport.setExEndTermMarks(0.0);
						GradeReport.setExMidTermMarks(0.0);
						GradeReport.setExGradePoint(0.0);
						GradeReport.setExQuizMarks(0.0);
						GradeReport.setExAssignmentMarks(0.0);
						GradeReport.setExAttendenceMarks(0.0);
					}
				
					super.gradeReport.updateStatus(false, true, sem.get().getId(), prog.get().getId(), courses.get().getId(), student.get().getId(), collage.get().getId());
					super.gradeReport.save(GradeReport);
					logger.info("Grade Report created for  " + exam[0].toString());
				} else {

					// checl ExamBarcodes EndTerm uploded or not
					Double Endterm = 0.0, quizMarks = 0.0, asst = 0.0, atte = 0.0, grand_total = 0.0, grade_point = 0.0,
							midtermWeightage = 0.0, internalTotal = 0.0, creditpoint = 0.0;
					Boolean passorfail = false;
					String remark = "", exLetterGrades = "";
					int course_status = 0;
					List<ExamBarcodes> validateomr = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentIdAndExIsAttendanceAndRegistrationTypeId(
									true, collage.get().getId(), courses.get().getId(), degree.get().getId(),
									 prog.get().getId(), sem.get().getId(), exam[0].toString(),
									programyear.get().getId(), academicYear.get().getId(), dept.get().getId(), true , registrationType.get(0).getId());

					if (validateomr.size() > 0) {
						// need to calculate grade report
						List<MidTermMarks> ispresentr = super.midtermmarksMarks
								.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
										exam[0].toString(), courses.get().getId(), sem.get().getId(),
										degree.get().getId(), prog.get().getId(), true, false, dept.get().getId());
						if (!commonHelper.checkAttendenceSA(ispresentr)) {
							Endterm = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							midtermWeightage = super.commonHelper
									.converToWeightageMarks(ispresentr.get(0).getExMidTermMarks());

							quizMarks = ispresentr.get(0).getExQuizMarks() == null ? 0.0
									: ispresentr.get(0).getExQuizMarks();
							asst = ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
									: ispresentr.get(0).getExAssignmentMarks();
							atte = ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
									: ispresentr.get(0).getExAttendenceMarks();

							internalTotal = (midtermWeightage)
									+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
											: ispresentr.get(0).getExQuizMarks())
									+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresentr.get(0).getExAssignmentMarks())
									+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresentr.get(0).getExAttendenceMarks());

							grand_total = (Endterm == null ? 0 : Endterm) + (internalTotal == 0 ? 0 : internalTotal);
							if (ispresentr.size() > 0) {
								internalTotal = (midtermWeightage)
										+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
												: ispresentr.get(0).getExQuizMarks())
										+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
												: ispresentr.get(0).getExAssignmentMarks())
										+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
												: ispresentr.get(0).getExAttendenceMarks());
							}

							grand_total=((double) (super.commonHelper.roundOffInt(grand_total)));

							grade_point = commonHelper.roundOff(grand_total);
							exLetterGrades = super.commonHelper.getLetterGrade(grand_total,registrationType.get(0).getId());
							if(courses.get().getExIsSatisfactory()==true) {								
								exLetterGrades= super.commonHelper.getLetterGradeSatisfactory(grand_total);
							}							
							
							Endterm = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							double midtermWeight = super.commonHelper
									.converToWeightageMarks(ispresentr.get(0).getExMidTermMarks());
							internalTotal = (midtermWeight)
									+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
											: ispresentr.get(0).getExQuizMarks())
									+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresentr.get(0).getExAssignmentMarks())
									+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresentr.get(0).getExAttendenceMarks());
							Boolean passfail = commonHelper.checkPassOrFailed(grade_point, Endterm, internalTotal);
							logger.info("passfail :" + passfail + "grade_point : " + grade_point + "Endterm :" + Endterm
									+ " Midterm : " + midtermWeightage);
							if (passfail) {
								course_status = 1;
								remark = "Pass";
							} else {
								course_status = 0;
								remark = "Fail";
								 exLetterGrades = "F";
								 if(Endterm !=null && Endterm == 0) {
									 exLetterGrades = "I";
								 }
							}
							
						} else {
							remark = "SA";
							if (ispresentr.size() <= 0) {
								remark = "";
							} else {
								remark = ispresentr.get(0).getExMidTermRemarks();
							}
						}
					} else {
						// student is absent
						course_status = 0;
						remark = "Incomplete";
					}
				

					double finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);
					creditpoint = finalgradepoint * (courses.get().getCreditHours().getExCreditHourLecture());
					int retval = super.gradeReport.updateMigGradeReport(course_status, remark,exLetterGrades ,
							(double) (super.commonHelper.roundOffInt(grand_total)), finalgradepoint,date,
							creditpoint, userresult,Endterm,midtermWeightage,gradereport.get(0).getId());
					logger.info("Grade Report updated for  " + exam[0].toString());
				}
			}
			// grade report log
			String ExReportType = "GradeReport";
			Boolean gradeReortLog = gradeReortLoger(null, academicYear.get(), collage.get(), degree.get(),
					courses.get(), prog.get(), sem.get(), exRemark, userresult, exIsReGenerated, ExReportType,
					registrationType.get(0), dept.get(), programyear.get(),hSet,courses.get().getBatch());
			if (gradeReortLog == true) {
				info.put("status", "1");
				info.put("message", "Grade Report generated successfully.");
				info.put("generatedCount", duplicate.size() <= 0 ? 1 : duplicate.size() + 1);
				return info;
			} else {
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}

	

	private Map<String, Object> createTherorygradeReport(List<Object[]> examAttendance, Optional<Degree> degree,
			Optional<Colleges> collage, Optional<Programmes> prog, Optional<ExamAnnouncement> result,
			Optional<Courses> courses, Optional<Semster> sem, Optional<AcademicYear> academicYear,
			Optional<ProgrammeYear> programyear, List<RegistrationType> registrationType, User userresult,
			List<com.niftem.app.entity.GradeReportLog> duplicate, String exIsReGenerated, String exRemark,
			Optional<Department> dept) {
		// TODO Auto-generated method stub
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Date date = new Date();
			Set<Section> hSet = new HashSet<Section>(); 

			for (Object[] exam : examAttendance) { // mendetory field need to insert
				Section sectionValue=null ;

				if(exam[1].toString()== null || exam[1].toString().equals("") || exam[1].toString().equals("NA")) {
					sectionValue=null;
				}else {
					long section_id = Long.parseLong(exam[1].toString());
					Optional<Section> userSection = super.section.findByExIsDeleteAndExIsActiveAndId( false,true,section_id);	
					if(userSection.isPresent()) {
						sectionValue=userSection.get();
					}else {
						sectionValue=null;
					}	
					hSet.add(sectionValue);
				}
				
				
				
				Optional<Studentadmission> student = super.studentadmission
						.findByExRollNoAndExIsDeleteAndExIsActive(exam[0].toString(), false, true);
				List<GradeReport> gradereport = super.gradeReport
						.findByExRollNoAndCollegesIdAndCoursesIdAndProgrammesIdAndSemesterIdAndExamAnnouncementIdAndProgrammeYearIdAndRegistrationTypeIdAndDepartmentIdAndDegreeId(
								exam[0].toString(), collage.get().getId(), courses.get().getId(), prog.get().getId(),
								sem.get().getId(), result.get().getId(), programyear.get().getId(),
								registrationType.get(0).getId(), dept.get().getId(), degree.get().getId());
				if (gradereport.size() <= 0) {
					
					List<ExamBarcodes> validateomr = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentId(
									true, collage.get().getId(), courses.get().getId(), degree.get().getId(),
									result.get().getId(), prog.get().getId(), sem.get().getId(), exam[0].toString(),
									programyear.get().getId(), academicYear.get().getId(), dept.get().getId());
					if (validateomr.size() > 0 && validateomr.get(0). getExIsAttendance()==null) {
						info.put("status", "2");
						info.put("message", "External Marks not uploaded ");
						return info;
					
					}
					
					GradeReport GradeReport = new GradeReport();
					GradeReport.setColleges(collage.get());
					GradeReport.setDegree(degree.get());
					GradeReport.setProgrammes(prog.get());
					GradeReport.setDepartment(dept.get());
					GradeReport.setSection(sectionValue);

					GradeReport.setExamAnnouncement(result.get());
					GradeReport.setAcademicYear(academicYear.get());
					GradeReport.setProgrammeYear(programyear.get());
					GradeReport.setSemester(sem.get());
					GradeReport.setRegistrationType(registrationType.get(0));
					GradeReport.setExRollNo(exam[0].toString());
					GradeReport.setStudentadmission(student.get());

					GradeReport.setCourses(courses.get());
					GradeReport.setExCoursesCode(courses.get().getExCoursesCode());
					GradeReport.setExCoursesName(courses.get().getExName());
					GradeReport.setExCreateDate(date);
					GradeReport.setExRollNo(exam[0].toString());

					GradeReport.setUser(userresult);
					GradeReport.setExIsActive(true);
					GradeReport.setExIsDelete(false);
					// checl ExamBarcodes EndTerm Marks uploded or not
					List<ExamBarcodes> validate = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentIdAndExIsAttendance(
									true, collage.get().getId(), courses.get().getId(), degree.get().getId(),
									result.get().getId(), prog.get().getId(), sem.get().getId(), exam[0].toString(),
									programyear.get().getId(), academicYear.get().getId(), dept.get().getId(), true);
					if (validate.size() > 0) {
						// need to calculate grade report
						List<MidTermMarks> ispresent = super.midtermmarksMarks
								.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
										exam[0].toString(), courses.get().getId(), sem.get().getId(),
										degree.get().getId(), prog.get().getId(), true, false, dept.get().getId());
						Double internalTotal = 0.0;

						if (ispresent.size() > 0) {
							double midtermWeightage = super.commonHelper
									.converToWeightageMarks(ispresent.get(0).getExMidTermMarks());
							GradeReport.setExMidTermMarks(midtermWeightage);
							GradeReport.setExQuizMarks(ispresent.get(0).getExQuizMarks());
							GradeReport.setExAssignmentMarks(ispresent.get(0).getExAssignmentMarks());
							GradeReport.setExAttendenceMarks(ispresent.get(0).getExAttendenceMarks());
							GradeReport.setExCaseStudy((ispresent.get(0).getExCaseStudy()));
							internalTotal = (midtermWeightage)
									+ (ispresent.get(0).getExQuizMarks() == null ? 0.0
											: ispresent.get(0).getExQuizMarks())
									+ (ispresent.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresent.get(0).getExAssignmentMarks())
									+ (ispresent.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresent.get(0).getExAttendenceMarks()
									+ (ispresent.get(0).getExCaseStudy() == null ? 0.0
											: ispresent.get(0).getExCaseStudy()));

						} else {
							logger.info("MidTerm Marks not uploaded for " + exam[0].toString());
							continue;
						}

						// check Attendence SA
						Double EndtermWeightag = 0.0;
						if (!commonHelper.checkAttendenceSA(ispresent)) { // true - no shortage of attendence

							EndtermWeightag = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							GradeReport.setExEndTermMarks(EndtermWeightag);
							Double grandtotal = (EndtermWeightag == null ? 0 : EndtermWeightag)
									+ (internalTotal == 0 ? 0 : internalTotal);
							GradeReport.setExGrandTotal((double) (super.commonHelper.roundOffInt(grandtotal)));
							double newInput = super.commonHelper.roundOff(grandtotal);

							String exLetterGrades = super.commonHelper.getLetterGrade(grandtotal , registrationType.get(0).getId());
							
							if(courses.get().getExIsSatisfactory()==true) {								
								String stastexLetterGrades = super.commonHelper.getLetterGradeSatisfactory(grandtotal);
								GradeReport.setExLetterGrades(stastexLetterGrades);	
							}							
							else {
							GradeReport.setExLetterGrades(exLetterGrades);
							}

							double finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);
							GradeReport.setExGradePoint(finalgradepoint);

							Boolean passfail = commonHelper.checkPassOrFailed(newInput, EndtermWeightag, internalTotal);
							if (passfail) {
								GradeReport.setExRemark("Pass");
								GradeReport.setExCoursesStatus(1);
							} else {
								GradeReport.setExRemark("Fail");
								GradeReport.setExGradePoint(0.0);
								GradeReport.setExLetterGrades("F");
								GradeReport.setExCoursesStatus(0);
							}
							GradeReport.setExCreditPoint(
									finalgradepoint * (courses.get().getCreditHours().getExCreditHourLecture()));

						} else {
							// student has SA
							if (ispresent.size() <= 0) {
								GradeReport.setExRemark("");
							} else {
								GradeReport.setExRemark(ispresent.get(0).getExMidTermRemarks());
							}
                    		GradeReport.setExCoursesStatus(0);
							GradeReport.setExEndTermMarks(0.0);
							GradeReport.setExMidTermMarks(0.0);
							GradeReport.setExGradePoint(0.0);
							GradeReport.setExQuizMarks(0.0);
							GradeReport.setExAssignmentMarks(0.0);
							GradeReport.setExAttendenceMarks(0.0);
							GradeReport.setExCaseStudy(0.0);
						}

					} else {
						// student is absent
						GradeReport.setExRemark("Absent");
						GradeReport.setExCoursesStatus(0);
						GradeReport.setExEndTermMarks(0.0);
						GradeReport.setExMidTermMarks(0.0);
						GradeReport.setExGradePoint(0.0);
						GradeReport.setExQuizMarks(0.0);
						GradeReport.setExAssignmentMarks(0.0);
						GradeReport.setExAttendenceMarks(0.0);
						GradeReport.setExCaseStudy(0.0);
					}
					// Update status for last semester
					super.gradeReport.updateStatus(false, true, sem.get().getId(), prog.get().getId(), courses.get().getId(), student.get().getId(), collage.get().getId());
					super.gradeReport.save(GradeReport);
					logger.info("Grade Report created for  " + exam[0].toString());
				} else {

					// checl ExamBarcodes EndTerm uploded or not
					Double Endterm = 0.0, quizMarks = 0.0, asst = 0.0, atte = 0.0, grand_total = 0.0, grade_point = 0.0,
							midtermWeightage = 0.0, internalTotal = 0.0, creditpoint = 0.0 , casestudy = 0.0;
					Boolean passorfail = false;
					String remark = "", exLetterGrades = "";
					int course_status = 0;
					List<ExamBarcodes> validateomr = super.exambarcode
							.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentIdAndExIsAttendance(
									true, collage.get().getId(), courses.get().getId(), degree.get().getId(),
									result.get().getId(), prog.get().getId(), sem.get().getId(), exam[0].toString(),
									programyear.get().getId(), academicYear.get().getId(), dept.get().getId(), true);

					if (validateomr.size() > 0) {
						// need to calculate grade report
						List<MidTermMarks> ispresentr = super.midtermmarksMarks
								.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
										exam[0].toString(), courses.get().getId(), sem.get().getId(),
										degree.get().getId(), prog.get().getId(), true, false, dept.get().getId());
						if (!commonHelper.checkAttendenceSA(ispresentr)) {
							Endterm = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							midtermWeightage = super.commonHelper
									.converToWeightageMarks(ispresentr.get(0).getExMidTermMarks());

							quizMarks = ispresentr.get(0).getExQuizMarks() == null ? 0.0
									: ispresentr.get(0).getExQuizMarks();
							asst = ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
									: ispresentr.get(0).getExAssignmentMarks();
							atte = ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
									: ispresentr.get(0).getExAttendenceMarks();
							
							casestudy = ispresentr.get(0).getExCaseStudy() == null ? 0.0
									: ispresentr.get(0).getExCaseStudy();

							internalTotal = (midtermWeightage)
									+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
											: ispresentr.get(0).getExQuizMarks())
									+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresentr.get(0).getExAssignmentMarks())
									+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresentr.get(0).getExAttendenceMarks())
									+	(ispresentr.get(0).getExCaseStudy() == null ? 0.0
											: ispresentr.get(0).getExCaseStudy());

							grand_total = (Endterm == null ? 0 : Endterm) + (internalTotal == 0 ? 0 : internalTotal);
							if (ispresentr.size() > 0) {
								internalTotal = (midtermWeightage)
										+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
												: ispresentr.get(0).getExQuizMarks())
										+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
												: ispresentr.get(0).getExAssignmentMarks())
										+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
												: ispresentr.get(0).getExAttendenceMarks())
										+	(ispresentr.get(0).getExCaseStudy() == null ? 0.0
												: ispresentr.get(0).getExCaseStudy());
							}
							
							
							grand_total=((double) (super.commonHelper.roundOffInt(grand_total)));

							grade_point = commonHelper.roundOff(grand_total);
							exLetterGrades = super.commonHelper.getLetterGrade(grand_total , registrationType.get(0).getId());
							if(courses.get().getExIsSatisfactory()==true) {								
								exLetterGrades= super.commonHelper.getLetterGradeSatisfactory(grand_total);
							}							
							
							Endterm = super.commonHelper
									.converEndToWeightageMarks(validateomr.get(0).getExEndTermMarks() == null ? 0.0
											: validateomr.get(0).getExEndTermMarks());
							double midtermWeight = super.commonHelper
									.converToWeightageMarks(ispresentr.get(0).getExMidTermMarks());
							internalTotal = (midtermWeight)
									+ (ispresentr.get(0).getExQuizMarks() == null ? 0.0
											: ispresentr.get(0).getExQuizMarks())
									+ (ispresentr.get(0).getExAssignmentMarks() == null ? 0.0
											: ispresentr.get(0).getExAssignmentMarks())
									+ (ispresentr.get(0).getExAttendenceMarks() == null ? 0.0
											: ispresentr.get(0).getExAttendenceMarks())
									+	(ispresentr.get(0).getExCaseStudy() == null ? 0.0
									: ispresentr.get(0).getExCaseStudy());
							
							
							Boolean passfail = commonHelper.checkPassOrFailed(grade_point, Endterm, internalTotal);
							logger.info("passfail :" + passfail + "grade_point : " + grade_point + "Endterm :" + Endterm
									+ " Midterm : " + midtermWeightage);
							if (passfail) {
								course_status = 1;
								remark = "Pass";
							} else {
								course_status = 0;
								grade_point=0.0;
								remark = "Fail";
								exLetterGrades="F";
							}
						
							creditpoint = grade_point * (courses.get().getCreditHours().getExCreditHourLecture()
									+ courses.get().getCreditHours().getExCreditHourTutorials());
						} else {
							remark = "SA";
							if (ispresentr.size() <= 0) {
								remark = "";
							} else {
								remark = ispresentr.get(0).getExMidTermRemarks();
							}
						}
					} else {
						// student is absent
						course_status = 0;
						remark = "Incomplete";
					}				
					double finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);	
					creditpoint = finalgradepoint * (courses.get().getCreditHours().getExCreditHourLecture());
					int retval = super.gradeReport.updateGradeReport(course_status, remark, Endterm, midtermWeightage,
							grand_total, finalgradepoint, date, creditpoint, sem.get().getId(), prog.get().getId(),
							result.get().getId(), courses.get().getId(), exam[0].toString(), collage.get().getId(),
							userresult, dept.get().getId(), quizMarks, asst, atte, exLetterGrades , casestudy);
					logger.info("Grade Report updated for  " + exam[0].toString());
				}
			}
			
			// grade report log
			String ExReportType = "GradeReport";
			Boolean gradeReortLog = gradeReortLoger(result.get(), academicYear.get(), collage.get(), degree.get(),
					courses.get(), prog.get(), sem.get(), exRemark, userresult, exIsReGenerated, ExReportType,
					registrationType.get(0), dept.get(), programyear.get(),hSet,courses.get().getBatch());
			if (gradeReortLog == true) {
				info.put("status", "1");
				info.put("message", "Grade Report generated successfully.");
				info.put("generatedCount", duplicate.size() <= 0 ? 1 : duplicate.size() + 1);
				return info;
			} else {
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}

	private Map<String, Object> createPracticalgradeReport(List<Object[]> examAttendance, Optional<Degree> degree,
			Optional<Colleges> collage, Optional<Programmes> prog, Optional<ExamAnnouncement> result,
			Optional<Courses> courses, Optional<Semster> sem, Optional<AcademicYear> academicYear,
			Optional<ProgrammeYear> programyear, List<RegistrationType> registrationType, User userresult,
			List<com.niftem.app.entity.GradeReportLog> duplicate, String exIsReGenerated, String exRemark,
			Optional<Department> dept) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			String exLetterGrades = "";
			Double midtermmarks = 0.0, endterm = 0.0;
			Date date = new Date();
			
			Set<Section> hSet = new HashSet<Section>(); 

			for (Object[] exam : examAttendance) {
				Section sectionValue=null ;

				if(exam[1].toString()== null || exam[1].toString().equals("") || exam[1].toString().equals("NA")) {
					sectionValue=null;
				}else {
					long section_id = Long.parseLong(exam[1].toString());
					Optional<Section> userSection = super.section.findByExIsDeleteAndExIsActiveAndId(false,true,section_id);	
					if(userSection.isPresent()) {
						sectionValue=userSection.get();
					}else {
						sectionValue=null;
					}	
					hSet.add(sectionValue);
				}
				
				List<ExamBarcodes> validate = super.exambarcode
						.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentId(
								true, collage.get().getId(), courses.get().getId(), degree.get().getId(),
								result.get().getId(), prog.get().getId(), sem.get().getId(), exam[0].toString(),
								programyear.get().getId(), academicYear.get().getId(), dept.get().getId());
				if (validate.size() > 0 && validate.get(0). getExIsPracticalAttendance()==null) {
					info.put("status", "2");
					info.put("message", "ExternalPractical Marks not uploaded ");
					return info;
				
				}
				
				
				Optional<Studentadmission> student = super.studentadmission
						.findByExRollNoAndExIsDeleteAndExIsActive(exam[0].toString(), false, true);
				List<MidTermMarks> ispresent = super.midtermmarksMarks
						.findByExRollNoAndCoursesIdAndSemesterIdAndDegreeIdAndProgrammesIdAndExIsActiveAndExIsDeleteAndDepartmentId(
								exam[0].toString(), courses.get().getId(), sem.get().getId(), degree.get().getId(),
								prog.get().getId(), true, false, dept.get().getId());
				List<ExamBarcodes> validateomr = super.exambarcode
						.findByExIsActiveAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndAcademicYearIdAndDepartmentIdAndExIsPracticalAttendance(
								true, collage.get().getId(), courses.get().getId(), degree.get().getId(),
								result.get().getId(), prog.get().getId(), sem.get().getId(), exam[0].toString(),
								programyear.get().getId(), academicYear.get().getId(), dept.get().getId(), true);
				List<GradeReport> gradereport = super.gradeReport
						.findByExRollNoAndCollegesIdAndCoursesIdAndProgrammesIdAndSemesterIdAndExamAnnouncementIdAndProgrammeYearIdAndRegistrationTypeIdAndDepartmentIdAndDegreeId(
								exam[0].toString(), collage.get().getId(), courses.get().getId(), prog.get().getId(),
								sem.get().getId(), result.get().getId(), programyear.get().getId(),
								registrationType.get(0).getId(), dept.get().getId(), degree.get().getId());
				if (gradereport.size() <= 0) {
					GradeReport GradeReport = new GradeReport();
					GradeReport.setColleges(collage.get());
					GradeReport.setDegree(degree.get());
					GradeReport.setProgrammes(prog.get());
					GradeReport.setDepartment(dept.get());
					GradeReport.setSection(sectionValue);

					GradeReport.setExamAnnouncement(result.get());
					GradeReport.setAcademicYear(academicYear.get());
					GradeReport.setProgrammeYear(programyear.get());
					GradeReport.setSemester(sem.get());
					GradeReport.setRegistrationType(registrationType.get(0));
					GradeReport.setExRollNo(exam[0].toString());
					GradeReport.setStudentadmission(student.get());

					GradeReport.setCourses(courses.get());
					GradeReport.setExCoursesCode(courses.get().getExCoursesCode());
					GradeReport.setExCoursesName(courses.get().getExName());
					GradeReport.setExCreateDate(date);

					GradeReport.setUser(userresult);
					GradeReport.setExIsActive(true);
					GradeReport.setExIsDelete(false);

				//	if (ispresent.get(0).getExPracticalRecordMarks() != null
					///		&& ispresent.get(0).getExPracticalLearning() != null) {
					//	midtermmarks = ispresent.get(0).getExPracticalRecordMarks()
					//			+ ispresent.get(0).getExPracticalLearning();
					//}
					
					if (ispresent.get(0).getExPracticalRecordMarks() != null
							|| ispresent.get(0).getExPracticalLearning() != null) {
						midtermmarks = ispresent.get(0).getExPracticalRecordMarks()
								+ ispresent.get(0).getExPracticalLearning();
					}
					
					GradeReport.setExPracticalInternalMarks(midtermmarks);
					// checking
					
					System.out.println("<<<<<<<<midtermmarks"   + midtermmarks);
					
					// checkingggg......
					
					
					if (validateomr.size() > 0) {
						endterm = (validateomr.get(0).getExLabExperiment() == null ? 0.0
								: validateomr.get(0).getExLabExperiment())
								+ (validateomr.get(0).getExViva() == null ? 0.0 : validateomr.get(0).getExViva());
						GradeReport.setExPracticalExternalMarks(endterm);

						Double total = midtermmarks + endterm;
						double grandtotal = total == null ? 0.0 : total;
						
						GradeReport.setExGrandTotal((double) (super.commonHelper.roundOffInt(grandtotal)));
						double newInput = super.commonHelper.roundOff(grandtotal);

						 exLetterGrades = super.commonHelper.getLetterGrade(grandtotal, registrationType.get(0).getId());
							
							if(courses.get().getExIsSatisfactory()==true) {								
								String stastexLetterGrades = super.commonHelper.getLetterGradeSatisfactory(grandtotal);
								GradeReport.setExLetterGrades(stastexLetterGrades);	
							}							
							else {
							GradeReport.setExLetterGrades(exLetterGrades);
							}

						double finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);
						GradeReport.setExGradePoint(finalgradepoint);
						

						
						if (grandtotal >= 50.0) {
							GradeReport.setExRemark("Pass");
							GradeReport.setExCoursesStatus(1);
						} else {
							GradeReport.setExRemark("Fail");
							GradeReport.setExGradePoint(0.0);
							GradeReport.setExLetterGrades("F");
							GradeReport.setExCoursesStatus(0);
						}
						Double prctical = courses.get().getCreditHours().getExCreditHourPractical(); 						
						GradeReport.setExCreditPoint(finalgradepoint* prctical);
					} else {
						GradeReport.setExRemark("InComplete");
						GradeReport.setExCoursesStatus(0);
						GradeReport.setExGradePoint(0.0);
						GradeReport.setExLetterGrades("I");
					}
					// Update status for last semester
					super.gradeReport.updateStatus(false, true, sem.get().getId(), prog.get().getId(), courses.get().getId(), student.get().getId(), collage.get().getId());
					super.gradeReport.save(GradeReport);

				} else {
					int course_status = 0;
					String remark1 = "";
					Double grandtotal = 0.0;
					Double creditpoint = 0.0 ,finalgradepoint=0.0;
					//if (ispresent.get(0).getExPracticalRecordMarks() != null
					//		&& ispresent.get(0).getExPracticalLearning() != null) {
					//	midtermmarks = ispresent.get(0).getExPracticalRecordMarks()
					//			+ ispresent.get(0).getExPracticalLearning();
					//}
					
					if (ispresent.get(0).getExPracticalRecordMarks() != null
							|| ispresent.get(0).getExPracticalLearning() != null) {
						midtermmarks =( ispresent.get(0).getExPracticalRecordMarks() == null ? 0 : ispresent.get(0).getExPracticalRecordMarks())
								+ (ispresent.get(0).getExPracticalLearning()==null ? 0 : ispresent.get(0).getExPracticalLearning());
					}
					
					//for checkingggg
					
					System.out.println("checking internal marks " +midtermmarks);
					
					//for checking purpose
					
					
					if (validateomr.size() > 0) {
						endterm = (validateomr.get(0).getExLabExperiment() == null ? 0.0
								: validateomr.get(0).getExLabExperiment())
								+ (validateomr.get(0).getExViva() == null ? 0.0 : validateomr.get(0).getExViva());
						Double total = midtermmarks + endterm;
					
						
						
						grandtotal=	(double) (super.commonHelper.roundOffInt(total));
					
						
						 exLetterGrades = super.commonHelper.getLetterGrade(grandtotal, registrationType.get(0).getId());

							 finalgradepoint = super.commonHelper.getPointGrade(exLetterGrades);
						
						
							 if(courses.get().getExIsSatisfactory()==true) {								
									exLetterGrades= super.commonHelper.getLetterGradeSatisfactory(grandtotal);
								}							
						
						if (grandtotal >= 50.0) {
							course_status = 1;
							remark1 = "Pass";
						} else {
							course_status = 0;
							remark1 = "Fail";
							//====
							exLetterGrades = "F";
							finalgradepoint=0.0;
							//====
						}
						Double prctical = courses.get().getCreditHours().getExCreditHourPractical(); 						
						creditpoint = (finalgradepoint* prctical);
					} else {
						remark1 = "InComplete";
						exLetterGrades = "I";

					}
					int retval = super.gradeReport.updateGradeReport(course_status, remark1, exLetterGrades, grandtotal,
							finalgradepoint, date, creditpoint, midtermmarks, endterm, sem.get().getId(), prog.get().getId(),
							result.get().getId(), courses.get().getId(), exam[0].toString(), collage.get().getId(),
							userresult, dept.get().getId(), degree.get().getId());
					logger.info(exam[0].toString() + " : Update query status : " + retval);

				}
			}
			String ExReportType = "GradeReport";
			Boolean gradeReortLog = gradeReortLoger(result.get(), academicYear.get(), collage.get(), degree.get(),
					courses.get(), prog.get(), sem.get(), exRemark, userresult, exIsReGenerated, ExReportType,
					registrationType.get(0), dept.get(), programyear.get(),hSet,courses.get().getBatch());
			if (gradeReortLog == true) {
				info.put("status", "1");
				info.put("message", "Grade Report genrated successfully.");
				info.put("genratedCount", duplicate.size() <= 0 ? 1 : duplicate.size() + 1);
				return info;
			} else {
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}

	private Boolean gradeReortLoger(ExamAnnouncement examAnnouncement, AcademicYear academicYear, Colleges colleges,
			Degree degree, Courses courses, Programmes programmes, Semster semster, String exRemark, User userresult,
			String exIsReGenerated, String exReportType, RegistrationType registrationType, Department department,
			ProgrammeYear programmeYear, Set<Section> hSet, Batch batch) {
		try {
			Date date = new Date();
			List dataList = new LinkedList();
           
			GradeReportLog logs = new GradeReportLog();

			if(exReportType.equalsIgnoreCase("semesterReport")) {
				logs.setSection(null);
				logs.setExamAnnouncement(examAnnouncement);
				logs.setAcademicYear(academicYear);
				logs.setExCreateDate(date);
				logs.setColleges(colleges);
				logs.setRegistrationType(registrationType);
				logs.setDegree(degree);
				logs.setCourses(courses);
				logs.setProgrammes(programmes);
				logs.setSemester(semster);
				logs.setExReportType(exReportType);
				logs.setExReportCategory("Generate");
				logs.setExRemark(exRemark);
				logs.setUser(userresult);
				logs.setExIsReGenerated(exIsReGenerated);
				logs.setDepartment(department);
				logs.setProgrammeYear(programmeYear);
				logs.setExIsActive(true);
				logs.setExIsDelete(false);
				logs.setBatch(batch);
				super.GradeReportLog.save(logs);
	            }else {
			for(Section s:hSet) {
			logs.setSection(s);
			logs.setExamAnnouncement(examAnnouncement);
			logs.setAcademicYear(academicYear);
			logs.setExCreateDate(date);
			logs.setColleges(colleges);
			logs.setRegistrationType(registrationType);
			logs.setDegree(degree);
			logs.setCourses(courses);
			logs.setProgrammes(programmes);
			logs.setSemester(semster);
			logs.setExReportType(exReportType);
			logs.setExReportCategory("Generate");
			logs.setExRemark(exRemark);
			logs.setUser(userresult);
			logs.setExIsReGenerated(exIsReGenerated);
			logs.setDepartment(department);
			logs.setProgrammeYear(programmeYear);
			logs.setExIsActive(true);
			logs.setExIsDelete(false);
			super.GradeReportLog.save(logs);
            }
	            }
			return true;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());

			return false;
		}
	}

	@Override
	public Map<String, Object> getGradeReport(GradeReportRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),
					false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear
					.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement
					.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}
			List<RegistrationType> RegistrationType = super.registrationType
					.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (RegistrationType.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType id not present");
				return info;
			}

			Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(), false,
					true);
			if (!courses.isPresent()) {
				info.put("status", "2");
				info.put("message", "courses not  present");
				return info;

			}

			List<GradeReport> gradereport = super.gradeReport
					.findByCollegesIdAndCoursesIdAndProgrammesIdAndSemesterIdAndDegreeIdAndExamAnnouncementIdAndAcademicYearIdAndDepartmentIdAndRegistrationTypeId(
							request.getColleges(), request.getCourses(), request.getProgrammes(), request.getSemester(),
							request.getDegree(), request.getExamAnnouncement(), request.getAcademicYear(),
							request.getDepartment(), request.getRegistrationType());
			if (gradereport.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No records found");
				return info;
			}

			List dataList = new LinkedList();

			for (GradeReport e : gradereport) {
				Map<Object, Object> omrlist = new HashMap<Object, Object>();
				omrlist.put("id", e.getId());
				omrlist.put("exEndTermMarks", e.getExEndTermMarks());
				omrlist.put("exMidTermMarks", e.getExMidTermMarks());
				omrlist.put("exAssignmentMarks", e.getExAssignmentMarks());
				omrlist.put("exAttendenceMarks", e.getExAttendenceMarks());
				omrlist.put("exQuizMarks", e.getExQuizMarks());
				omrlist.put("exGrandTotal", e.getExGrandTotal());
				omrlist.put("exGradePoint", e.getExGradePoint() < 5 ? "Fail" : e.getExGradePoint());
				omrlist.put("exName", e.getStudentadmission().getExName());
				omrlist.put("exRollNo", e.getStudentadmission().getExRollNo());
				omrlist.put("studentadmissionId", e.getStudentadmission().getId());

				omrlist.put("exRemark", e.getExRemark());
				dataList.add(omrlist);

			}
			info.put("status", "1");
			info.put("message", "success");
			info.put("details", dataList);

			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> checkGradeReportStatus(GradeReportRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			logger.info("Inside checkGradeReportStatus");

			if (request.getReportType() == null || request.getReportType().equals("")) {
				info.put("status", "2");
				info.put("message", "ReportType is required");
				return info;
			}

			List<GradeReportLog> duplicate = null;
			// duplicate check in GradeReportLog for gradeReport
			if (request.getReportType().equalsIgnoreCase("GradeReport")) {
				if (request.getCourses() == null || request.getCourses().equals("")) {
					info.put("status", "2");
					info.put("message", "Courses  is required");
					return info;
				}
				Optional<Courses> course = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(), false,
						true);
				if (!course.isPresent()) {
					info.put("status", "2");
					info.put("message", "Course not present");
					return info;
				}
				List<Long> list = new ArrayList();
				if(request.getSection().size()>0) {		
					for(int i =0 ; i<request.getSection().size() ; i++) {
						Optional<Section> section  = super.section.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSection().get(i));
						if(!section.isPresent()) {
							info.put("status", "2");
							info.put("message", "Section not present");
							return info;
						}		
						list.add(section.get().getId());
					
					}	
				}else {
					List<Section> slist  =  super.section.findByExIsDeleteAndExIsActive(false, true);		
					for(Section sec : slist) {
						list.add(sec.getId());
					}
				}		
				duplicate = super.GradeReportLog
						.findByExamAnnouncementIdAndAcademicYearIdAndCollegesIdAndProgrammesIdAndExReportTypeAndDegreeIdAndCoursesIdAndSemesterIdAndExReportCategoryAndDepartmentIdAndSectionIdIn(
								request.getExamAnnouncement(), request.getAcademicYear(), request.getColleges(),
								request.getProgrammes(), "GradeReport", request.getDegree(), request.getCourses(),
								request.getSemester(), "Generate", request.getDepartment(),list);

			}
			// duplicate check in GradeReportLog for semesterReport
			if (request.getReportType().equalsIgnoreCase("SemesterReport")) {
				duplicate = super.GradeReportLog
						.findByExamAnnouncementIdAndAcademicYearIdAndCollegesIdAndProgrammesIdAndExReportTypeAndDegreeIdAndSemesterIdAndExReportCategoryAndDepartmentIdAndBatchId(
								request.getExamAnnouncement(), request.getAcademicYear(), request.getColleges(),
								request.getProgrammes(), "SemesterReport", request.getDegree(), request.getSemester(),
								"Generate", request.getDepartment() , request.getBatch());
			}

			if (duplicate.size() <= 0) {
				info.put("status", "1");
				info.put("message", "first Time Generating");
				return info;
			} else {
				info.put("status", "3");
				info.put("message", "regenerating");
				return info;
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}

	@Override
	public Map<String, Object> generateSemesterProgressReport(GradeReportRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			logger.info("Inside generate Semester Progress Report > " + request);

			Section sectionValue=null;
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),
					false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear
					.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			Optional<Batch> batch = super.batch.findByExIsDeleteAndExIsActiveAndId(false, true, request.getBatch());
			if (!batch.isPresent()) {
				info.put("status", "2");
				info.put("message", "Batch not present");
				return info;
			}

			User userresult = null;
			String ExIsReGenerated = "Generated";
			if (request.getUser() == null || request.getUser().equals("")) {
				userresult = null;
			} else {
				List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
				userresult = user.get(0);
			}
			List<RegistrationType> rtype = super.registrationType.findByIdAndExIsDeleteAndExIsActive(1L, false, true);
			if (rtype.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Regular Registration Type not present");
				return info;
			}
			
			if (request.getExamAnnouncement()==null || request.getExamAnnouncement().equals("NA")) {		
				return  generateMigSemesterReport(request);	
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false, true, request.getExamAnnouncement());
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "Examannouncement  not present");
				return info;
			}
			
			
			// check for all gradial courses GradeReport are genrated or not
			List<Courses> course = super.courses
					.findByExIsDeleteAndExIsActiveAndProgrammesIdAndSemesterIdAndProgrammeYearIdAndAcademicYearId(false,
							true, request.getProgrammes(), request.getSemester(), request.getProgrammeYear(),
							request.getAcademicYear());
			if (course.size() <= 0) {
				info.put("status", "2");
				info.put("message", "courses not mapped with program");
				return info;
			}

			List<GradeReport> gradereport = super.gradeReport.getGradeStudentList(request.getColleges(),
					request.getProgrammes(), request.getDegree(),  request.getSemester(),
					request.getProgrammeYear(), request.getAcademicYear(), rtype.get(0).getId(),
					request.getDepartment() , request.getBatch());
			if (gradereport.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Grade report not created");
				return info;
			}
			// duplicate check in GradeReportLog
			List<GradeReportLog> duplicate = super.GradeReportLog
					.findByExamAnnouncementIdAndAcademicYearIdAndCollegesIdAndProgrammesIdAndExReportTypeAndDegreeIdAndSemesterIdAndExReportCategoryAndDepartmentIdAndBatchId(
							request.getExamAnnouncement(), request.getAcademicYear(), request.getColleges(),
							request.getProgrammes(), "SemesterReport", request.getDegree(), request.getSemester(),
							"Generate", request.getDepartment() , request.getBatch());
			if (duplicate.size() > 0) {
				if (request.getExRemark() == null || request.getExRemark().equalsIgnoreCase("null")
						|| request.getExRemark().equals("") || request.getExRemark().trim().isEmpty()) {
					info.put("status", "2");
					info.put("message", "Please provide valid reason for regenerating Semester Progress report");
					return info;
				}
				ExIsReGenerated = "ReGenerated";
			}
			logger.info("gggggggg" + gradereport.size());
			Date date = new Date();
			for (GradeReport grade : gradereport) {
				
				logger.info("iiiiiiiiii" +grade.getExRollNo());
				if(grade.getCourses().getExIsSatisfactory()==false) {
				List<GradeReport> courselist = super.gradeReport.findByCollegesIdAndProgrammesIdAndDegreeIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndDepartmentIdAndExIsActiveAndExIsDeleteAndCoursesExIsSatisfactory(
								request.getColleges(), request.getProgrammes(), request.getDegree(),
								request.getSemester(), grade.getExRollNo(), request.getProgrammeYear(),
								 request.getDepartment() , true , false,false);
				double totalcredithours = 0;
				double totalcreditPoint = 0;
				for (GradeReport c : courselist) {
					if (c.getExRemark() != null && c.getExRemark().equalsIgnoreCase("Pass")) {
						totalcreditPoint = totalcreditPoint + (c.getExCreditPoint() == null ? 0 : c.getExCreditPoint());
					}
					if(c.getCourses().getExIsSatisfactory()==false) {

						Double prctical = c.getCourses().getCreditHours().getExCreditHourPractical(); 					
						totalcredithours = totalcredithours+ (prctical+ (c.getCourses().getCreditHours().getExCreditHourLecture() == null ? 0: c.getCourses().getCreditHours().getExCreditHourLecture()));
					}
				}

				double roundOff = 0;
				double cgpapoint = 0;
				double finalcgpapoint = 0;
				double cgpacredithour = 0;
				double finalcgpacredithour = 0;
				double regularcredithour = totalcredithours;

				List<SemesterProgressReport> totalcgpa = super.semesterProgressReport.getStudentCGPADetails(
						request.getColleges(), request.getDegree(), request.getProgrammes(), grade.getExRollNo(),
						request.getProgrammeYear(), request.getSemester(), request.getDepartment());
				logger.info(grade.getExRollNo() + "ssssssssssssssssssssssss" + totalcgpa.size());
				if (totalcgpa.size() > 0) {
					for (SemesterProgressReport tot : totalcgpa) {
						cgpapoint = tot.getExTotalGradePoint() == null ? 0 : tot.getExTotalGradePoint();
						finalcgpapoint = finalcgpapoint + cgpapoint;
						cgpacredithour = tot.getExTotalCreditHour() == null ? 0 : tot.getExTotalCreditHour();
						finalcgpacredithour = finalcgpacredithour + cgpacredithour;
					}
				}
				finalcgpapoint = finalcgpapoint + totalcreditPoint;
				finalcgpacredithour = finalcgpacredithour + totalcredithours;

				if (totalcredithours != 0) {
					roundOff = commonHelper.changeDecimal(totalcreditPoint / totalcredithours); // GPA in Point
				}
				finalcgpapoint = commonHelper.changeDecimal(finalcgpapoint); // Total credit Point for CGPA
				totalcreditPoint = commonHelper.changeDecimal(totalcreditPoint); // Total Credit Point for GPA
				double finalpoint = commonHelper.changeDecimal(finalcgpapoint / finalcgpacredithour); // CGPA In point

				List<SemesterProgressReport> checkrecord = super.semesterProgressReport
						.findByCollegesIdAndDegreeIdAndProgrammesIdAndSemesterIdAndExamAnnouncementIdAndAcademicYearIdAndProgrammeYearIdAndExRollNoAndDepartmentId(
								request.getColleges(), request.getDegree(), request.getProgrammes(),
								request.getSemester(), request.getExamAnnouncement(), request.getAcademicYear(),
								request.getProgrammeYear(), grade.getExRollNo(), request.getDepartment());
				if (checkrecord.size() <= 0) {

					SemesterProgressReport SemesterProgressReport = new SemesterProgressReport();
					SemesterProgressReport.setAcademicYear(academicYear.get());
					SemesterProgressReport.setColleges(collage.get());
					SemesterProgressReport.setDegree(degree.get());
					SemesterProgressReport.setExTotalCamuGradePoint(finalcgpapoint);
					SemesterProgressReport.setExamAnnouncement(result.get());
					SemesterProgressReport.setExCamuGradePointAv(finalpoint);
					SemesterProgressReport.setExRollNo(grade.getExRollNo());
					SemesterProgressReport.setExGradePointAv(roundOff);
					SemesterProgressReport.setExTotalCreditHour(regularcredithour);
					SemesterProgressReport.setExTotalGradePoint(totalcreditPoint);
					SemesterProgressReport.setProgrammes(Prog.get());
					SemesterProgressReport.setSemester(sem.get());
					SemesterProgressReport.setExCreateDate(date);
					SemesterProgressReport.setProgrammeYear(programyear.get());
					SemesterProgressReport.setStudentadmission(grade.getStudentadmission());
					SemesterProgressReport.setDepartment(dept.get());
					SemesterProgressReport.setUser(userresult);
					SemesterProgressReport.setSerialNumber("1"+gen());
					SemesterProgressReport.setExIsActive(true);
					SemesterProgressReport.setExIsDelete(false);
					super.semesterProgressReport.save(SemesterProgressReport);
				} else {
					int retval = super.semesterProgressReport.updateSemesterReport(finalpoint, roundOff,
							regularcredithour, totalcreditPoint, date, Prog.get(), sem.get(), programyear.get(),
							grade.getExRollNo(), academicYear.get(), collage.get(), degree.get(), result.get(),
							userresult, finalcgpapoint, dept.get());
					logger.info(grade.getExRollNo() + " : Update query status : " + retval);
				}

			}
			
			//return info;
		}
			String ExReportType = "SemesterReport";
			// GradeReportLog
			Boolean gradeReortLog = gradeReortLoger(result.get(), academicYear.get(), collage.get(), degree.get(), null,
					Prog.get(), sem.get(), request.getExRemark(), userresult, ExIsReGenerated, ExReportType, null,
					dept.get(), programyear.get(),null,batch.get());
			if (gradeReortLog == true) {
				info.put("status", "1");
				info.put("message", "Semester Progress Report genrated successfully.");
				info.put("genratedCount", duplicate.size() <= 0 ? 1 : duplicate.size() + 1);
			} else {
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}
	public int gen() {
	    Random r = new Random( System.currentTimeMillis() );
	    return 10000 + r.nextInt(20000);
	}
	@Override
	public Map<String, Object> getEvaluatedCoursestList(CoursesRegistrationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<GradeReport> gradereport = super.gradeReport
					.findByAcademicYearIdAndExamAnnouncementIdAndRegistrationTypeIdAndStudentadmissionId(
							request.getAcademicYear(), request.getExamAnnouncement(), 1L, request.getStudent());
			if (gradereport.size() <= 0) {
				info.put("status", "2");
				info.put("message", "semester Result Not Announced :");
				return info;
			}

			List dataList = new LinkedList();
			Boolean isRegistered = false;
			Boolean isPaid = false;
			for (GradeReport e : gradereport) {
				List coursestype = new LinkedList();
				List coursesTypeId = new LinkedList();
				isRegistered = false;
				isPaid = false;
				List<CoursesRegistration> spresent = super.coursesRegistration
						.findByStudentadmissionIdAndAcademicYearIdAndRegistrationIdAndExamAnnouncementIdAndCoursesId(
								request.getStudent(), request.getAcademicYear(), 3L, request.getExamAnnouncement(),
								e.getCourses().getId());
				if (spresent.size() > 0) {
					isRegistered = true;
					if (spresent.get(0).getExIsPaid() != null && spresent.get(0).getExIsPaid() == true) {
						isPaid = true;
					}
				}

				Map<String, Object> Coursesdata = new HashMap<String, Object>();
				Coursesdata.put("isPaid", isPaid);
				Coursesdata.put("isRegistered", isRegistered);
				Coursesdata.put("id", e.getCourses().getId());
				Coursesdata.put("exCoursesCode", e.getCourses().getExCoursesCode());
				Coursesdata.put("exName", e.getCourses().getExName());
				Coursesdata.put("creditHoursId", e.getCourses().getCreditHours().getId());
				Coursesdata.put("creditHours", e.getCourses().getCreditHours().getExCreditHourTitle());
				Coursesdata.put("academicYearId", e.getAcademicYear().getId());
				Coursesdata.put("academicYear", e.getAcademicYear().getExYear());
				for (int i = 0; i < e.getCourses().getCoursesType().size(); i++) {
					coursestype.add(e.getCourses().getCoursesType().get(i).getExName());
					coursesTypeId.add(e.getCourses().getCoursesType().get(i).getId());
				}
				Coursesdata.put("coursesType", coursestype);
				Coursesdata.put("coursesTypeId", coursesTypeId);
				dataList.add(Coursesdata);
			}
			info.put("status", "1");
			info.put("message", "success");
			info.put("details", dataList);

			info.put("programYear", gradereport.get(0).getProgrammeYear().getExName());
			info.put("programYearId", gradereport.get(0).getProgrammeYear().getId());
			info.put("degreeId", gradereport.get(0).getDegree().getId());
			info.put("degree", gradereport.get(0).getDegree().getExName());
			info.put("semesterId", gradereport.get(0).getSemester().getId());
			info.put("semester", gradereport.get(0).getSemester().getExName());
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> reEvaluation(CoursesRegistrationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear
					.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!programyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement
					.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}

			List<RegistrationType> registration = super.registrationType
					.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType not present");
				return info;
			}
			Optional<Studentadmission> studentadmission = super.studentadmission
					.findByExIsDeleteAndExIsActiveAndId(false, true, request.getStudent());
			if (!studentadmission.isPresent()) {
				info.put("status", "2");
				info.put("message", "student not present");
				return info;
			}

			if (request.getCourses().size() <= 0) {
				info.put("status", "2");
				info.put("message", "Please select Courses");
				return info;
			}
			List<Courses> coursesList = super.courses.findByExIsDeleteAndExIsActiveAndIdIn(false, true,
					request.getCourses());
			if (coursesList.size() <= 0) {
				info.put("status", "2");
				info.put("message", "selected Courses not Present");
				return info;
			}

			List<CoursesRegistration> spresent = super.coursesRegistration
					.findByStudentadmissionIdAndAcademicYearIdAndRegistrationIdAndExamAnnouncementId(
							request.getStudent(), request.getAcademicYear(), request.getRegistrationType(),
							request.getExamAnnouncement());
			List<Courses> newcourses = new ArrayList<Courses>();

			for (CoursesRegistration p : spresent) {
				newcourses.add(p.getCourses());
			}

			coursesList.removeAll(newcourses);
			System.out.println(">>>>>>Checking " + coursesList);
			if (coursesList.size() == 0) {
				info.put("status", "3");
				info.put("message", "Your Re-Evaluation Registration is done, please pay registration fee");
				return info;
			}
			Date date = new Date();
			List dataList = new LinkedList();
			for (int i = 0; i < coursesList.size(); i++) {
				CoursesRegistration data = new CoursesRegistration();
				data.setColleges(studentadmission.get().getColleges());
				data.setDegree(studentadmission.get().getDegree());
				data.setAcademicYear(academicYear.get());
				data.setProgrammes(studentadmission.get().getProgrammes());
				data.setDepartment(studentadmission.get().getDepartment());
				data.setStream(coursesList.get(i).getStream());
				data.setProgrammeYear(programyear.get());
				data.setSemester(sem.get());
				data.setExCreateDate(date);
				data.setExIsActive(true);
				data.setStudentadmission(studentadmission.get());
				data.setExIsRegistration(true);
				data.setExIsDelete(false);
				data.setExIsApproved(false);
				data.setExIsPaid(false);
				data.setExIsAttendence(false);
				data.setExIsEligible(false);
				data.setExSemesterStatus(false);
				data.setExSemesterStatus(false);
				data.setRegistration(registration.get(0));
				data.setCourses(coursesList.get(i));
				data.setExamAnnouncement(result.get());
				dataList.add(data);

			}
			coursesRegistration.saveAll(dataList);
			info.put("status", "1");
			info.put("message", "ReEvaluation registered successfully");
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getSupplementaryCourses(CoursesRegistrationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!programyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			if(sem.get().getExIdentifier() == 1 || sem.get().getExIdentifier() == 2) {
					info.put("status", "2");
					info.put("message", "No Supplymentry courses");
					return info;
			}
			int semester = sem.get().getExIdentifier();
			int sypplysem = semester-2;
			
			Optional<Semster> sypplysemid = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,Long.valueOf(sypplysem));
			if (!sypplysemid.isPresent()) {
				info.put("status", "2");
				info.put("message", "Supply semester not present");
				return info;
			}
			
			List<GradeReport> gradereport = super.gradeReport.getSujectR( request.getStudent());	
			
			//List<GradeReport> gradereport = super.gradeReport.findByRegistrationTypeIdAndStudentadmissionIdAndSemesterIdAndExCoursesStatus( 1L , request.getStudent() , sypplysemid.get().getId() ,0);	
			//List<GradeReport> gradereport = super.gradeReport.findByRegistrationTypeIdAndStudentadmissionIdAndSemesterIdAndExCoursesStatus( 1L , request.getStudent() ,request.getSemester() ,0);	
			if(gradereport.size() <=0) {
				info.put("status", "2");
				info.put("message", "you don't have any supplementary courses courses");
					return info;
			}
			
			List dataList = new LinkedList();
			Boolean isRegistered = false;
			Boolean isPaid = false;
			for (GradeReport e : gradereport) {
				 List<GradeReport> spresent12 = super.gradeReport.findByExCoursesStatusAndStudentadmissionIdAndCoursesId(1 ,request.getStudent() , e.getCourses().getId());
				 if(spresent12.size() <=0) {
				
				List coursestype = new LinkedList();
				List coursesTypeId = new LinkedList();					
				 isRegistered = false;
				 isPaid = false;					
				Map<String, Object> Coursesdata = new HashMap<String, Object>();							
				 List<CoursesRegistration> spresent = super.coursesRegistration.findByStudentadmissionIdAndAcademicYearIdAndRegistrationIdAndCoursesId(request.getStudent(), request.getAcademicYear(), 2L, e.getCourses().getId());
				 if(spresent.size() >0) {
					 isRegistered = true;
					 if(spresent.get(0).getExIsPaid() !=null && spresent.get(0).getExIsPaid() == true) {
						 isPaid = true;
					 }
				 }					 					
				Coursesdata.put("isPaid", isPaid);
				Coursesdata.put("isRegistered", isRegistered);
				Coursesdata.put("id", e.getCourses().getId());
				Coursesdata.put("exCoursesCode", e.getCourses().getExCoursesCode());
				Coursesdata.put("exName", e.getCourses().getExName());
				Coursesdata.put("creditHoursId", e.getCourses().getCreditHours().getId());
				Coursesdata.put("creditHours", e.getCourses().getCreditHours().getExCreditHourTitle());
				
				for (int i = 0; i < e.getCourses().getCoursesType().size(); i++) {
					coursestype.add(e.getCourses().getCoursesType().get(i).getExName());
					coursesTypeId.add(e.getCourses().getCoursesType().get(i).getId());
				}
				Coursesdata.put("coursesType", coursestype);
				Coursesdata.put("coursesTypeId", coursesTypeId);
				dataList.add(Coursesdata);
		}}
			info.put("status", "1");
			info.put("message", "success");
			info.put("details", dataList);	
			
			info.put("programYear",programyear.get().getExName());
			info.put("programYearId", programyear.get().getId());
			info.put("degreeId",gradereport.get(0).getDegree().getId());
			info.put("degree", gradereport.get(0).getDegree().getExName());
			info.put("semesterId",sem.get().getId());
			info.put("semester",sem.get().getExName());
			return info;
		}catch(Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> supplementaryRegistration(CoursesRegistrationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!programyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}

			List<RegistrationType> registration = super.registrationType.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType not present");
				return info;
			}
			Optional<Studentadmission> studentadmission = super.studentadmission.findByExIsDeleteAndExIsActiveAndId(false, true, request.getStudent());
			if (!studentadmission.isPresent()) {
				info.put("status", "2");
				info.put("message", "student not present");
				return info;
			}

			if (request.getCourses().size() <= 0) {
				info.put("status", "2");
				info.put("message", "Please select Courses");
				return info;
			}
			/// check validation
			
			for (int i = 0; i < request.getCourses().size(); i++) {
				Long coursel = Long.valueOf(request.getCourses().get(i));// new Long(courselist.get(i));
				Optional<Courses> res = courses.findByIdAndExIsDeleteAndExIsActive(coursel, false, true);
				if (!res.isPresent()) {
					info.put("status", "2");
					info.put("message", "Please provide valid courses list");
					return info;
				}
				// check selected courses ID belong to Same Examination ID
				if (res.get().getSemester().getId() == result.get().getSemester().getId()) {

				} else {
					info.put("status", "2");
					info.put("message", "Please register " + res.get().getExCoursesCode() + " courses with "
							+ res.get().getProgrammeYear().getExName() + " " + res.get().getSemester().getExName()
							+ "  ");
					return info;
				}			
			}		
			
			List<Courses> coursesList = super.courses.findByExIsDeleteAndExIsActiveAndIdIn(false, true,request.getCourses());
			if (coursesList.size() <= 0) {
				info.put("status", "2");
				info.put("message", "selected Courses not Present");
				return info;
			}

			List<CoursesRegistration> spresent = super.coursesRegistration
					.findByStudentadmissionIdAndAcademicYearIdAndRegistrationIdAndExamAnnouncementId(
							request.getStudent(), request.getAcademicYear(), request.getRegistrationType(),
							request.getExamAnnouncement());
			List<Courses> newcourses = new ArrayList<Courses>();

			for (CoursesRegistration p : spresent) {
				newcourses.add(p.getCourses());
			}

			coursesList.removeAll(newcourses);
			if (coursesList.size() == 0) {
				info.put("status", "3");
				info.put("message", "Your Supplementary Registration is done, please pay registration fee");
				return info;
			}
			Date date = new Date();
			List dataList = new LinkedList();
			for (int i = 0; i < coursesList.size(); i++) {
				CoursesRegistration data = new CoursesRegistration();
				data.setColleges(studentadmission.get().getColleges());
				data.setDegree(studentadmission.get().getDegree());
				data.setAcademicYear(academicYear.get());
				data.setProgrammes(studentadmission.get().getProgrammes());
				data.setDepartment(studentadmission.get().getDepartment());
				data.setStream(coursesList.get(i).getStream());
				data.setProgrammeYear(result.get().getProgrammeYear());
				data.setSemester(result.get().getSemester());
				data.setExCreateDate(date);
				data.setExIsActive(true);
				data.setStudentadmission(studentadmission.get());
				data.setExIsRegistration(true);
				data.setExIsDelete(false);
				data.setExIsApproved(false);
				data.setExIsAttendence(false);
				data.setExIsPaid(false);
				data.setExIsEligible(false);
				data.setExSemesterStatus(false);
				data.setExSemesterStatus(false);
				data.setRegistration(registration.get(0));
				data.setCourses(coursesList.get(i));
				data.setExamAnnouncement(result.get());
				dataList.add(data);

			}
			coursesRegistration.saveAll(dataList);
			// insert into spply table
			List supply = new LinkedList();
			for (int i = 0; i < coursesList.size(); i++) {
				SupplementaryRegistration data = new SupplementaryRegistration();
				data.setColleges(studentadmission.get().getColleges());
				data.setDegree(studentadmission.get().getDegree());
				data.setAcademicYear(academicYear.get());
				data.setProgrammeYear(programyear.get());
				data.setSemester(sem.get());
				data.setExCreateDate(date);
				data.setExIsActive(true);
				data.setStudentadmission(studentadmission.get());		
				data.setExIsDelete(false);				
				data.setRegistration(registration.get(0));
				data.setCourses(coursesList.get(i));
				data.setExamAnnouncement(result.get());
				supply.add(data);

			}
			supplyregister.saveAll(supply);
			
			info.put("status", "1");
			info.put("message", "supplementary registered successfully");
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> coursesListForPhotocopy(CoursesRegistrationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<GradeReport> gradereport = super.gradeReport
					.findByAcademicYearIdAndExamAnnouncementIdAndRegistrationTypeIdAndStudentadmissionId(
							request.getAcademicYear(), request.getExamAnnouncement(), 1L, request.getStudent());
			if (gradereport.size() <= 0) {
				info.put("status", "2");
				info.put("message", "semester Result Not Announced :");
				return info;
			}

			List dataList = new LinkedList();
			Boolean isRegistered = false;
			Boolean isPaid = false;
			for (GradeReport e : gradereport) {
				List coursestype = new LinkedList();
				List coursesTypeId = new LinkedList();
				isRegistered = false;
				isPaid = false;
				Map<String, Object> Coursesdata = new HashMap<String, Object>();
				List<CoursesRegistration> spresent = super.coursesRegistration
						.findByStudentadmissionIdAndAcademicYearIdAndRegistrationIdAndExamAnnouncementIdAndCoursesId(
								request.getStudent(), request.getAcademicYear(), 4L, request.getExamAnnouncement(),
								e.getCourses().getId());
				if (spresent.size() > 0) {
					isRegistered = true;
					if (spresent.get(0).getExIsPaid() != null && spresent.get(0).getExIsPaid() == true) {
						isPaid = true;
					}
				}
				Coursesdata.put("isPaid", isPaid);
				Coursesdata.put("isRegistered", isRegistered);
				Coursesdata.put("id", e.getCourses().getId());
				Coursesdata.put("exCoursesCode", e.getCourses().getExCoursesCode());
				Coursesdata.put("exName", e.getCourses().getExName());
				Coursesdata.put("creditHoursId", e.getCourses().getCreditHours().getId());
				Coursesdata.put("creditHours", e.getCourses().getCreditHours().getExCreditHourTitle());
				Coursesdata.put("academicYearId", e.getAcademicYear().getId());
				Coursesdata.put("academicYear", e.getAcademicYear().getExYear());
				for (int i = 0; i < e.getCourses().getCoursesType().size(); i++) {
					coursestype.add(e.getCourses().getCoursesType().get(i).getExName());
					coursesTypeId.add(e.getCourses().getCoursesType().get(i).getId());
				}
				Coursesdata.put("coursesType", coursestype);
				Coursesdata.put("coursesTypeId", coursesTypeId);
				dataList.add(Coursesdata);
			}
			info.put("status", "1");
			info.put("message", "success");
			info.put("details", dataList);

			info.put("programYear", gradereport.get(0).getProgrammeYear().getExName());
			info.put("programYearId", gradereport.get(0).getProgrammeYear().getId());
			info.put("degreeId", gradereport.get(0).getDegree().getId());
			info.put("degree", gradereport.get(0).getDegree().getExName());
			info.put("semesterId", gradereport.get(0).getSemester().getId());
			info.put("semester", gradereport.get(0).getSemester().getExName());
			info.put("academicYearId", gradereport.get(0).getAcademicYear().getId());
			info.put("academicYear", gradereport.get(0).getAcademicYear().getExYear());
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> photocopy(CoursesRegistrationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear
					.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!programyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement
					.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}

			List<RegistrationType> registration = super.registrationType
					.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType not present");
				return info;
			}
			Optional<Studentadmission> studentadmission = super.studentadmission
					.findByExIsDeleteAndExIsActiveAndId(false, true, request.getStudent());
			if (!studentadmission.isPresent()) {
				info.put("status", "2");
				info.put("message", "student not present");
				return info;
			}

			if (request.getCourses().size() <= 0) {
				info.put("status", "2");
				info.put("message", "Please select Courses");
				return info;
			}
			List<Courses> coursesList = super.courses.findByExIsDeleteAndExIsActiveAndIdIn(false, true,
					request.getCourses());
			if (coursesList.size() <= 0) {
				info.put("status", "2");
				info.put("message", "selected Courses not Present");
				return info;
			}

			List<CoursesRegistration> spresent = super.coursesRegistration
					.findByStudentadmissionIdAndAcademicYearIdAndRegistrationIdAndExamAnnouncementId(
							request.getStudent(), request.getAcademicYear(), request.getRegistrationType(),
							request.getExamAnnouncement());
			List<Courses> newcourses = new ArrayList<Courses>();

			for (CoursesRegistration p : spresent) {
				newcourses.add(p.getCourses());
			}

			coursesList.removeAll(newcourses);
			if (coursesList.size() == 0) {
				info.put("status", "3");
				info.put("message", "Your Photocopy Registration is done, please pay registration fee");
				return info;
			}
			Date date = new Date();
			List dataList = new LinkedList();
			for (int i = 0; i < coursesList.size(); i++) {
				CoursesRegistration data = new CoursesRegistration();
				data.setColleges(studentadmission.get().getColleges());
				data.setDegree(studentadmission.get().getDegree());
				data.setAcademicYear(academicYear.get());
				data.setProgrammes(studentadmission.get().getProgrammes());
				data.setDepartment(studentadmission.get().getDepartment());
				data.setStream(coursesList.get(i).getStream());
				data.setProgrammeYear(programyear.get());
				data.setSemester(sem.get());
				data.setExCreateDate(date);
				data.setExIsActive(true);
				data.setStudentadmission(studentadmission.get());
				data.setExIsRegistration(true);
				data.setExIsDelete(false);
				data.setExIsApproved(false);
				data.setExIsAttendence(false);
				data.setExIsEligible(false);
				data.setExIsPaid(false);
				data.setExSemesterStatus(false);
				data.setExSemesterStatus(false);
				data.setRegistration(registration.get(0));
				data.setCourses(coursesList.get(i));
				data.setExamAnnouncement(result.get());
				dataList.add(data);

			}
			coursesRegistration.saveAll(dataList);
			info.put("status", "1");
			info.put("message", "Photocopy registered successfully");
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getReRegistrationCourses(CoursesRegistrationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {

			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear
					.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!programyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			if (sem.get().getExIdentifier() == 1) {
				info.put("status", "2");
				info.put("message", "Supplementary courses not present for I semester");
				return info;
			}
			int semester = sem.get().getExIdentifier();
			int lastsem = semester - 1;

			Optional<Semster> lastsemid = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,
					Long.valueOf(lastsem));
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}

			List<GradeReport> gradereport = super.gradeReport
					.findByAcademicYearIdAndRegistrationTypeIdAndStudentadmissionIdAndSemesterIdAndExCoursesStatus(
							request.getAcademicYear(), 1L, request.getStudent(), lastsemid.get().getId(), 0);
			if (gradereport.size() <= 0) {
				info.put("status", "2");
				info.put("message", "you don't have any supplementary courses courses");
				return info;
			}

			List dataList = new LinkedList();
			Boolean isRegistered = false;
			Boolean isPaid = false;
			for (GradeReport e : gradereport) {
				List coursestype = new LinkedList();
				List coursesTypeId = new LinkedList();
				isRegistered = false;
				isPaid = false;
				Map<String, Object> Coursesdata = new HashMap<String, Object>();
				List<CoursesRegistration> spresent = super.coursesRegistration
						.findByStudentadmissionIdAndAcademicYearIdAndRegistrationIdAndCoursesId(request.getStudent(),
								request.getAcademicYear(), 2L, e.getCourses().getId());
				if (spresent.size() > 0) {
					isRegistered = true;
					if (spresent.get(0).getExIsPaid() != null && spresent.get(0).getExIsPaid() == true) {
						isPaid = true;
					}
				}
				Coursesdata.put("isPaid", isPaid);
				Coursesdata.put("isRegistered", isRegistered);
				Coursesdata.put("id", e.getCourses().getId());
				Coursesdata.put("exCoursesCode", e.getCourses().getExCoursesCode());
				Coursesdata.put("exName", e.getCourses().getExName());
				Coursesdata.put("creditHoursId", e.getCourses().getCreditHours().getId());
				Coursesdata.put("creditHours", e.getCourses().getCreditHours().getExCreditHourTitle());

				for (int i = 0; i < e.getCourses().getCoursesType().size(); i++) {
					coursestype.add(e.getCourses().getCoursesType().get(i).getExName());
					coursesTypeId.add(e.getCourses().getCoursesType().get(i).getId());
				}
				Coursesdata.put("coursesType", coursestype);
				Coursesdata.put("coursesTypeId", coursesTypeId);
				dataList.add(Coursesdata);
			}
			info.put("status", "1");
			info.put("message", "success");
			info.put("details", dataList);

			info.put("programYear", programyear.get().getExName());
			info.put("programYearId", programyear.get().getId());
			info.put("degreeId", gradereport.get(0).getDegree().getId());
			info.put("degree", gradereport.get(0).getDegree().getExName());
			info.put("semesterId", sem.get().getId());
			info.put("semester", sem.get().getExName());
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@SuppressWarnings("unchecked")
	@Override
	public Map<String, Object> reRegistration(CoursesRegistrationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear
					.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!programyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement
					.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}

			List<RegistrationType> registration = super.registrationType
					.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType not present");
				return info;
			}
			Optional<Studentadmission> studentadmission = super.studentadmission
					.findByExIsDeleteAndExIsActiveAndId(false, true, request.getStudent());
			if (!studentadmission.isPresent()) {
				info.put("status", "2");
				info.put("message", "student not present");
				return info;
			}

			if (request.getCourses().size() <= 0) {
				info.put("status", "2");
				info.put("message", "Please select Courses");
				return info;
			}
			List<Courses> coursesList = super.courses.findByExIsDeleteAndExIsActiveAndIdIn(false, true,
					request.getCourses());
			if (coursesList.size() <= 0) {
				info.put("status", "2");
				info.put("message", "selected Courses not Present");
				return info;
			}

			List<CoursesRegistration> spresent = super.coursesRegistration
					.findByStudentadmissionIdAndAcademicYearIdAndRegistrationIdAndExamAnnouncementId(
							request.getStudent(), request.getAcademicYear(), request.getRegistrationType(),
							request.getExamAnnouncement());
			List<Courses> newcourses = new ArrayList<Courses>();

			for (CoursesRegistration p : spresent) {
				newcourses.add(p.getCourses());
			}

			coursesList.removeAll(newcourses);
			if (coursesList.size() == 0) {
				info.put("status", "3");
				info.put("message", "Your Re-Registration is done, please pay registration fee");
				return info;
			}
			Date date = new Date();
			List dataList = new LinkedList();
			for (int i = 0; i < coursesList.size(); i++) {
				CoursesRegistration data = new CoursesRegistration();
				data.setColleges(studentadmission.get().getColleges());
				data.setDegree(studentadmission.get().getDegree());
				data.setAcademicYear(academicYear.get());
				data.setProgrammes(studentadmission.get().getProgrammes());
				data.setDepartment(studentadmission.get().getDepartment());
				data.setStream(coursesList.get(i).getStream());
				data.setProgrammeYear(programyear.get());
				data.setSemester(sem.get());
				data.setExCreateDate(date);
				data.setExIsActive(true);
				data.setStudentadmission(studentadmission.get());
				data.setExIsRegistration(true);
				data.setExIsDelete(false);
				data.setExIsApproved(false);
				data.setExIsAttendence(false);
				data.setExIsPaid(false);
				data.setExIsEligible(false);
				data.setExSemesterStatus(false);
				data.setExSemesterStatus(false);
				data.setRegistration(registration.get(0));
				data.setCourses(coursesList.get(i));
				data.setExamAnnouncement(result.get());
				dataList.add(data);

			}
			coursesRegistration.saveAll(dataList);
			info.put("status", "1");
			info.put("message", "Re-registered successfully");
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getTransacationDetails(LoadAlertRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List dataList = new LinkedList();
		//	System.out.println(">>.roll no" + request.getExRollNo());
			/*
			 * List<Studentpersonal> studentidres =
			 * super.studentpersonal.checkExRollNo(request.getExRollNo(), true, false);
			 * System.out.println(">>.roll no" + request.getExRollNo()); if
			 * (studentidres.size() <= 0) { info.put("status", "2"); info.put("message",
			 * "Student not Present"); return info; }
			 */

			List<OrderTransaction> data = super.transactionRepository.findByExRollNo(request.getExRollNo());
			if (data.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Record not Present");
				return info;
			}
			List paymentStatus = new ArrayList();

			paymentStatus.add("Success");
			paymentStatus.add("Failed");

			ArrayList<String> result = super.transactionRepository.findorderid(request.getExRollNo());
			for (String fee : result) {
				Map<Object, Object> orderdetails = new HashMap<Object, Object>();
				orderdetails.put("orderid", fee);
				List<OrderTransaction> fees = super.transactionRepository.findByOrderIdAndPaymentstatusIn(fee,
						paymentStatus);
				double totalfee = 0.0;
				for (OrderTransaction d : fees) {
					totalfee = totalfee + d.getTxnAmount();
				}
				if (fees.size() > 0) {
					orderdetails.put("amount", totalfee);
					orderdetails.put("bankReferenceNo", fees.get(0).getBankRefNum());
					orderdetails.put("paymentstatus", fees.get(0).getPaymentstatus());
					orderdetails.put("txndate", fees.get(0).getTxnDate().toString().replace("T", " "));
					orderdetails.put("txnreferenceno", fees.get(0).getMihpayId());
					orderdetails.put("registrationType", fees.get(0).getRegistration() == null ?"NA" :fees.get(0).getRegistration().getExName());
					dataList.add(orderdetails);
				}

			}
			info.put("status", "1");
			info.put("message", "success");
			info.put("studentid", request.getExRollNo());
			info.put("details", dataList);
			return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, Object> getTransacationDetails(String studentRollNo) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List dataList = new LinkedList();

			if (studentRollNo == null || studentRollNo.equals("")) {
				info.put("status", "2");
				info.put("message", "studentRollNo is required");
				return info;
			}
			
			/*
			 * List<Studentpersonal> studentidres =
			 * super.studentpersonal.checkExRollNo(studentRollNo,true,false);
			 * if(studentidres.size()<=0){ info.put("status", "2"); info.put("message",
			 * "Student not Present"); return info; }
			 */
		//	List<String> PaymentStatus=["Success","Failure"];
			List<OrderTransaction> data=super.transactionRepository.findByExRollNo(studentRollNo);
			if(data.size()<=0){
				info.put("status", "2");
				info.put("message", "Record not Present");
				return info;
				}
			List paymentStatus = new ArrayList();

			paymentStatus.add("Success");
			paymentStatus.add("Failed");
		
				ArrayList<String> result=super.transactionRepository.findorderid(studentRollNo);
				for( String fee :result){
					Map<Object, Object> orderdetails = new HashMap<Object, Object>();
					orderdetails.put("orderid", fee);
					List<OrderTransaction> fees=super.transactionRepository.findByOrderIdAndPaymentstatusIn(fee,paymentStatus);			    
					double totalfee=0.0;
					for( OrderTransaction d :fees){
					totalfee=totalfee+d.getTxnAmount();
			    	}	
					if(fees.size() >0) {
						orderdetails.put("amount", totalfee);
						orderdetails.put("bankNumber", fees.get(0).getBankRefNum());	
						orderdetails.put("registrationType", fees.get(0).getRegistration() == null ?"NA" :fees.get(0).getRegistration().getExName());
						orderdetails.put("paymentstatus",fees.get(0).getPaymentstatus() );	
						orderdetails.put("txndate",fees.get(0).getTxnDate().toString().replace("T", " "));	
						orderdetails.put("txnNumber",fees.get(0).getMihpayId());	
						dataList.add(orderdetails);						
					}

				
				}
			info.put("status", "1");
			info.put("message", "success");
			info.put("studentRollNo", studentRollNo);
			info.put("details", dataList);					
			return info;
		
			
		}catch(Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, Object> generateMigSemesterReport(GradeReportRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			logger.info("Inside generate Semester Progress Report > " + request);

			Section sectionValue=null;
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),
					false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}
			
			Optional<Batch> batch = super.batch.findByExIsDeleteAndExIsActiveAndId(false, true, request.getBatch());
			if (!batch.isPresent()) {
				info.put("status", "2");
				info.put("message", "Batch not present");
				return info;
			}
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear
					.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			
			User userresult = null;
			String ExIsReGenerated = "Generated";
			if (request.getUser() == null || request.getUser().equals("")) {
				userresult = null;
			} else {
				List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
				userresult = user.get(0);
			}
			List<RegistrationType> rtype = super.registrationType.findByIdAndExIsDeleteAndExIsActive(1L, false, true);
			if (rtype.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Regular Registration Type not present");
				return info;
			}
			// check for all gradial courses GradeReport are genrated or not
			List<Courses> course = super.courses
					.findByExIsDeleteAndExIsActiveAndProgrammesIdAndSemesterIdAndProgrammeYearIdAndAcademicYearId(false,
							true, request.getProgrammes(), request.getSemester(), request.getProgrammeYear(),
							request.getAcademicYear());
			if (course.size() <= 0) {
				info.put("status", "2");
				info.put("message", "courses not mapped with program");
				return info;
			}

			List<GradeReport> gradereport = super.gradeReport.getMIGGradeStudentList(request.getColleges(),
					request.getProgrammes(), request.getDegree(),  request.getSemester(),
					request.getProgrammeYear(), request.getAcademicYear(), rtype.get(0).getId(),
					request.getDepartment());
			if (gradereport.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Student not found");
				return info;
			}
			System.out.println("??????????????????????????????/"+gradereport.size());
			
			// duplicate check in GradeReportLog
			List<GradeReportLog> duplicate = super.GradeReportLog
					.findByAcademicYearIdAndCollegesIdAndProgrammesIdAndExReportTypeAndDegreeIdAndSemesterIdAndExReportCategoryAndDepartmentId(
							 request.getAcademicYear(), request.getColleges(),
							request.getProgrammes(), "SemesterReport", request.getDegree(), request.getSemester(),
							"Generate", request.getDepartment());
			if (duplicate.size() > 0) {
				if (request.getExRemark() == null || request.getExRemark().equalsIgnoreCase("null")
						|| request.getExRemark().equals("") || request.getExRemark().trim().isEmpty()) {
					info.put("status", "2");
					info.put("message", "Please provide valid reason for regenerating Semester Progress report");
					return info;
				}
				ExIsReGenerated = "ReGenerated";
			}
			Date date = new Date();
			for (GradeReport grade : gradereport) {
				List<GradeReport> courselist = super.gradeReport.findByCollegesIdAndProgrammesIdAndDegreeIdAndSemesterIdAndExRollNoAndProgrammeYearIdAndDepartmentIdAndExIsActiveAndExIsDeleteAndCoursesExIsSatisfactory(
								request.getColleges(), request.getProgrammes(), request.getDegree(),
								request.getSemester(), grade.getExRollNo(), request.getProgrammeYear(),
								 request.getDepartment(), true , false , false);
				double totalcredithours = 0;
				double totalcreditPoint = 0;
				for (GradeReport c : courselist) {
					if (c.getExRemark() != null && c.getExRemark().equalsIgnoreCase("Pass")) {
						
						totalcreditPoint = totalcreditPoint + (c.getExCreditPoint() == null ? 0 : c.getExCreditPoint());
					}
					Double prctical = c.getCourses().getCreditHours().getExCreditHourPractical(); 					
					totalcredithours = totalcredithours+ (prctical+ (c.getCourses().getCreditHours().getExCreditHourLecture() == null ? 0: c.getCourses().getCreditHours().getExCreditHourLecture()));
				
					}

				double roundOff = 0;
				double cgpapoint = 0;
				double finalcgpapoint = 0;
				double cgpacredithour = 0;
				double finalcgpacredithour = 0;
				double regularcredithour = totalcredithours;
				List<SemesterProgressReport> totalcgpa = super.semesterProgressReport.getStudentMIGCGPADetails(
						request.getColleges(), request.getDegree(), request.getProgrammes(), grade.getExRollNo(),
						request.getSemester(), request.getDepartment() );
				logger.info(grade.getExRollNo() + "ssssssssssssssssssssssss" + totalcgpa.size());
				if (totalcgpa.size() > 0) {
					for (SemesterProgressReport tot : totalcgpa) {
						cgpapoint = tot.getExTotalGradePoint() == null ? 0 : tot.getExTotalGradePoint();
						finalcgpapoint = finalcgpapoint + cgpapoint;
						cgpacredithour = tot.getExTotalCreditHour() == null ? 0 : tot.getExTotalCreditHour();
						finalcgpacredithour = finalcgpacredithour + cgpacredithour;
					}
				}//else {
					finalcgpapoint = finalcgpapoint + totalcreditPoint;
					finalcgpacredithour = finalcgpacredithour + totalcredithours;					
				//}
					logger.info("total aaaaaaaaafinalcgpapoint"+finalcgpapoint);
					logger.info("total finalcgpacredithour"+finalcgpacredithour);

				if (totalcredithours != 0) {
					roundOff = commonHelper.changeDecimal(totalcreditPoint / totalcredithours); // GPA in Point
				}
				finalcgpapoint = commonHelper.changeDecimal(finalcgpapoint); // Total credit Point for CGPA
				totalcreditPoint = commonHelper.changeDecimal(totalcreditPoint); // Total Credit Point for GPA
				double finalpoint = commonHelper.changeDecimal(finalcgpapoint / finalcgpacredithour); // CGPA In point

				List<SemesterProgressReport> checkrecord = super.semesterProgressReport
						.findByCollegesIdAndDegreeIdAndProgrammesIdAndSemesterIdAndAcademicYearIdAndProgrammeYearIdAndExRollNoAndDepartmentId(
								request.getColleges(), request.getDegree(), request.getProgrammes(),
								request.getSemester(),  request.getAcademicYear(),
								request.getProgrammeYear(), grade.getExRollNo(), request.getDepartment());
				if (checkrecord.size() <= 0) {

					SemesterProgressReport SemesterProgressReport = new SemesterProgressReport();
					SemesterProgressReport.setAcademicYear(academicYear.get());
					SemesterProgressReport.setColleges(collage.get());
					SemesterProgressReport.setDegree(degree.get());
					SemesterProgressReport.setExTotalCamuGradePoint(finalcgpapoint);
			//		SemesterProgressReport.setExamAnnouncement(result.get());
					SemesterProgressReport.setExCamuGradePointAv(finalpoint);
					SemesterProgressReport.setExRollNo(grade.getExRollNo());
					SemesterProgressReport.setExGradePointAv(roundOff);
					SemesterProgressReport.setExTotalCreditHour(regularcredithour);
					SemesterProgressReport.setExTotalGradePoint(totalcreditPoint);
					SemesterProgressReport.setProgrammes(Prog.get());
					SemesterProgressReport.setSemester(sem.get());
					SemesterProgressReport.setExCreateDate(date);
					SemesterProgressReport.setProgrammeYear(programyear.get());
					SemesterProgressReport.setStudentadmission(grade.getStudentadmission());
					SemesterProgressReport.setDepartment(dept.get());
					SemesterProgressReport.setUser(userresult);
					SemesterProgressReport.setExIsActive(true);
					SemesterProgressReport.setExIsDelete(false);
					super.semesterProgressReport.save(SemesterProgressReport);
				} else {
					int retval = super.semesterProgressReport.updateMigSemesterReport(finalpoint, roundOff,
							regularcredithour, totalcreditPoint, date, Prog.get(), sem.get(), programyear.get(),
							grade.getExRollNo(), academicYear.get(), collage.get(), degree.get(),
							userresult, finalcgpapoint, dept.get());
					logger.info(grade.getExRollNo() + " : Update query status : " + retval);
				}
				
			}
			String ExReportType = "SemesterReport";
			// GradeReportLog
			Boolean gradeReortLog = gradeReortLoger(null, academicYear.get(), collage.get(), degree.get(), null,
					Prog.get(), sem.get(), request.getExRemark(), userresult, ExIsReGenerated, ExReportType, null,
					dept.get(), programyear.get(),null,batch.get());
			if (gradeReortLog == true) {
				info.put("status", "1");
				info.put("message", "Semester Progress Report genrated successfully.");
				info.put("genratedCount", duplicate.size() <= 0 ? 1 : duplicate.size() + 1);
			} else {
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			
			}
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> checkMigReportStatus(GradeReportRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			logger.info("Inside checkGradeReportStatus");

			if (request.getReportType() == null || request.getReportType().equals("")) {
				info.put("status", "2");
				info.put("message", "ReportType is required");
				return info;
			}

			List<GradeReportLog> duplicate = null;
			// duplicate check in GradeReportLog for gradeReport
			if (request.getReportType().equalsIgnoreCase("GradeReport")) {
				if (request.getCourses() == null || request.getCourses().equals("")) {
					info.put("status", "2");
					info.put("message", "Courses  is required");
					return info;
				}
				Optional<Courses> course = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(), false,
						true);
				if (!course.isPresent()) {
					info.put("status", "2");
					info.put("message", "Course not present");
					return info;
				}
				List<Long> list = new ArrayList();
				if(request.getSection().size()>0) {		
					for(int i =0 ; i<request.getSection().size() ; i++) {
						Optional<Section> section  = super.section.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSection().get(i));
						if(!section.isPresent()) {
							info.put("status", "2");
							info.put("message", "Section not present");
							return info;
						}		
						list.add(section.get().getId());
					
					}	
				}else {
					List<Section> slist  =  super.section.findByExIsDeleteAndExIsActive(false, true);		
					for(Section sec : slist) {
						list.add(sec.getId());
					}
				}		
				duplicate = super.GradeReportLog
						.findByAcademicYearIdAndCollegesIdAndProgrammesIdAndExReportTypeAndDegreeIdAndCoursesIdAndSemesterIdAndExReportCategoryAndDepartmentIdAndSectionIdIn(
								 request.getAcademicYear(), request.getColleges(),
								request.getProgrammes(), "GradeReport", request.getDegree(), request.getCourses(),
								request.getSemester(), "Generate", request.getDepartment(),list);

			}
			// duplicate check in GradeReportLog for semesterReport
			if (request.getReportType().equalsIgnoreCase("SemesterReport")) {
				duplicate = super.GradeReportLog
						.findByAcademicYearIdAndCollegesIdAndProgrammesIdAndExReportTypeAndDegreeIdAndSemesterIdAndExReportCategoryAndDepartmentId(
								 request.getAcademicYear(), request.getColleges(),
								request.getProgrammes(), "SemesterReport", request.getDegree(), request.getSemester(),
								"Generate", request.getDepartment());
			}

			if (duplicate.size() <= 0) {
				info.put("status", "1");
				info.put("message", "first Time Generating");
				return info;
			} else {
				info.put("status", "3");
				info.put("message", "regenerating");
				return info;
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}

	@Override
	public Map<String, Object> bookletUpload(BookletUploadRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();	
		List<String> failureList = new ArrayList<String>();
		List<String> successList = new ArrayList<String>();
		List<Object> list = new ArrayList<Object>();
		 try {
				Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
						true);
				if (!collage.isPresent()) {
					info.put("status", "2");
					info.put("message", "College Id not Present");
					return info;
				}
				Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
				if (!degree.isPresent()) {
					info.put("status", "2");
					info.put("message", "Degree not present");
					return info;
				}

				Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
						request.getProgrammes());
				if (!Prog.isPresent()) {
					info.put("status", "2");
					info.put("message", "Programmes not present");
					return info;
				}
				Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),
						false, true);
				if (!dept.isPresent()) {
					info.put("status", "2");
					info.put("message", "department not  present");
					return info;

				}
				Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
						request.getAcademicYear());
				if (!academicYear.isPresent()) {
					info.put("status", "2");
					info.put("message", "AcademicYear id not present");
					return info;
				}
				
				User userresult = null;
				if (request.getUser() == null || request.getUser().equals("")) {
					userresult = null;
				} else {
					List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
					if (user.size() <= 0) {
						info.put("status", "2");
						info.put("message", "User id not present");
						return info;
					}
					userresult = user.get(0);
				}
				List<RegistrationType> rtype = super.registrationType.findByIdAndExIsDeleteAndExIsActive(1L, false, true);
				if (rtype.size() <= 0) {
					info.put("status", "2");
					info.put("message", "Regular Registration Type not present");
					return info;
				}
				// check for all gradial courses GradeReport are genrated or not
				Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourse(),false, true);
				 if (!courses.isPresent()) {
						info.put("status", "2");
						info.put("message", "courses not present");
						return info;
				}
				 
				 if(request.getExBooklet()==null ||request.getExBooklet().isEmpty())
				 {
					    info.put("status", "2");
						info.put("message", "please select zip file");
						return info; 
					 
				 }		
				 
				 String filename =  super.unzipUtility.filename(request.getExBooklet());
				 System.out.println(">>>>>>>>>>>filename>>"+filename);
				 System.out.println(">>>>>>>>>>>courses.get().getExCoursesCode()>>"+courses.get().getExCoursesCode());
				 if(!filename.equals(courses.get().getExCoursesCode()))
				 {
					    info.put("status", "2");
						info.put("message", "Zip file name should be same as course code");
						return info; 
					 
				 }	
					
				 
				 Date date = new Date();
				 String bookletpath=""; 
				 int isEvaluated =0;
			 String serverdir = unzipUtility.createFolder( academicYear.get().getExYear(),"AnswerBooklet" ,collage.get().getExIdentifier(),Prog.get().getExIdentifier());		

 	         bookletpath = "/"+academicYear.get().getExYear()+"/"+"AnswerBooklet"+"/"+collage.get().getExIdentifier()+"/"+Prog.get().getExIdentifier()+"/"+filename;	           	  					
			 List<String> retvalue =  unzipUtility.unzip(request.getExBooklet() , serverdir);	
			 if(retvalue.size()<=0) {
				info.put("status", "2");
				info.put("message", "Folders are not Present.");
				return info; 				 
			 }
			 for(int l=0;l<retvalue.size();l++){   
				 logger.info(">>>>>>>>>>retvalue.get(l)"+retvalue.get(l));
            	List<ExamBarcodes> bookletpresent =super.ExamBarcodes.findByExIsActiveAndCollegesIdAndCoursesIdAndExamAnnouncementIdAndProgrammesIdAndRegistrationTypeIdAndExBarcodeAndDepartmentIdAndDegreeId(true, request.getColleges(), request.getCourse(), request.getExamAnnouncement(), request.getProgrammes(), request.getRegistrationType(),retvalue.get(l),request.getDepartment(),request.getDegree()); 
            	if(bookletpresent.size()>0) { 
            		if(bookletpresent.get(0).getExIsEvaluated()==isEvaluated) {
					 int status = super.exambarcode.updateAnswerBookletStatus(bookletpath+"/"+retvalue.get(l)+"/", date, true, request.getRegistrationType(), request.getProgrammes(), request.getCourse(), retvalue.get(l) , request.getExamAnnouncement(),userresult);
	            		 if(status==0) { 
	            			failureList.add(retvalue.get(l)+ ": Records are not present to upload booklet");
	     					list.add(retvalue.get(l));
	            		 }	           		 
	 					successList.add("Success" + retvalue.get(l));	
	            		}else {
	            			failureList.add(retvalue.get(l)+ ": Booklet already evaluated");
	     					list.add(retvalue.get(l));		
	            		}           	
     			   }
            	else {
            		failureList.add(retvalue.get(l)+ ": Barcode Not Present for particular request::");
					list.add(retvalue.get(l));
				}
			 }	
			    logger.info("Booklet Not uploaded : " + failureList);
			 	info.put("status", "1");
				info.put("message", "Answer Booklet upload");
				info.put("success", successList.size() + " Booklet uploaded Successfully");
				info.put("failure", list.size() + " Booklet Not uploadeds ");
				return info;
		 }catch(Exception e) {
			 e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
		 }
		 
    }

	@Override
	public Map<String, Object> getPendingBarcodeOnstaff(EvaluationDetailsRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
			if (request.getAcademicYear() == null || request.getAcademicYear().equals("")) {
				info.put("status", "2");
				info.put("message", "Academicyear is required");
				return info;
			}												
			if (request.getExamAnnouncement() == null || request.getExamAnnouncement().equals("")) {
				info.put("status", "2");
				info.put("message", "Examannouncement is required");
				return info;
			}			
			if (request.getStaffid() == null || request.getStaffid().equals("")) {
				info.put("status", "2");
				info.put("message", "staffid is required");
				return info;
			}			
			Optional<EvaluatorList> staffid = super.expertlist.findById(request.getStaffid() );
			if (!staffid.isPresent()) {
				info.put("status", "2");
				info.put("message", "staff not present");
				return info;
			}	
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement
					.findByExIsDeleteAndExIsActiveAndId(false, true, request.getExamAnnouncement());
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "Examannouncement  not present");
				return info;
			}
			
			
			
			 //Pendingbarcodedetails
			Date date=new Date();
        	List dataList = new LinkedList();	
			List<ExamBarcodes>  recordlist= super.ExamBarcodes.findByAcademicYearIdAndExamAnnouncementIdAndExpertId(request.getAcademicYear(),request.getExamAnnouncement(),request.getStaffid());
			if (recordlist.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No records found");
				return info;
		   } 
		   List<EvaluationDetails> eval=	super.evaluationDetails.findByAcademicYearIdAndExamAnnouncementIdAndExpertId(request.getAcademicYear(),request.getExamAnnouncement(),request.getStaffid());
		   if (eval.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No records found");
				return info;
		   } 			
			String serverurl = commonHelper.getSettingValue("SERVER_IP");
			String localurl = commonHelper.getSettingValue("DOCUMENT_PATH");

			
			int isEvaluated =0;
			int savedisEvaluated =2;
		   for(ExamBarcodes e : recordlist) {
			   if(e.getExIsEvaluated()==isEvaluated ||e.getExIsEvaluated()==savedisEvaluated) {
			   Map<Object, Object> staffinfo = new HashMap<Object, Object>();
				
			   if(e.getExIsEvaluated() != null && e.getExIsEvaluated() == 2) {
					staffinfo.put("barcode", e.getExBarcode()+"*");
			   }else {
					staffinfo.put("barcode", e.getExBarcode());
			   }				
                int filecount = 0;
				if(e.getExAnsBookletPath() != null ||!e.getExAnsBookletPath().equals("NA")) {				
				  String name=localurl+e.getExAnsBookletPath();
				  logger.info("destinationPath file: " +localurl+e.getExAnsBookletPath());	   
                   File directory=new File(name);
                   for (File file : directory.listFiles()) {
                       if (file.isFile()) {
                    	   filecount++;
                       }                                          
                   }
                   logger.info("destinationPath file count"+filecount);				

				}
				staffinfo.put("ansBookletPath", (e.getExAnsBookletPath() == null || e.getExAnsBookletPath().equals("NA"))?"NA" :serverurl+e.getExAnsBookletPath());															
				staffinfo.put("evaluatedPath",  (e.getExEvaluatedPath() == null || e.getExEvaluatedPath().equals("NA"))?"NA" :serverurl+e.getExEvaluatedPath());
				staffinfo.put("timeTaken", e.getExTimeTaken());	
				staffinfo.put("id", e.getId());
				staffinfo.put("exIsEvaluated", e.getExIsEvaluated());	
				staffinfo.put("ansBookletFileCount", filecount);	
				dataList.add(staffinfo); 
			   }
		   }		  
		  if(dataList.size() <=0) {
			   info.put("status", "2");
				info.put("message", "No pending Barcode list");	
				info.put("pendingcount",dataList.size());
				info.put("perDayLimit",eval.get(0).getExLimitPerDay());
				info.put("evaluatedcount",recordlist.size()-dataList.size());
				info.put("totalcount",recordlist.size());
				info.put("pendingbarcodedetails",dataList.size()<=0?"No pending Barcode list":dataList);
				return info;
			   
		   }else {
			   info.put("status", "1");
				info.put("message", "success");	
				info.put("pendingcount",dataList.size());
				info.put("perDayLimit",eval.get(0).getExLimitPerDay());
				info.put("evaluatedcount",recordlist.size()-dataList.size());
				info.put("totalcount",recordlist.size());
				info.put("pendingbarcodedetails",dataList.size()<=0?"No pending Barcode list":dataList);
				return info;
		   }
		       

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> saveEvaluatorSelection(EvaluatorSelectionRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<EvaluatorList> expertid = super.expertlist.findByIdAndExIsDeleteAndExIsActive(request.getEvaluatorId(),false,true);
			if (!expertid.isPresent()) {
				info.put("status", "2");
				info.put("message", "evaluatorid not present");
				return info;
			}		
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false, true,request.getExamAnnouncement());
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "Examannouncement  not present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			
			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			
			Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(), false,true);
			if (!courses.isPresent()) {
				info.put("status", "2");
				info.put("message", "courses not  present");
				return info;

			}
			List<RegistrationType> registration = super.registrationType.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType not present");
				return info;
			}
			
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			  List<EvaluationType> evaluation = super.evaluationType.findByIdAndExIsDelete(request.getEvaluationType(), false);		
				if (evaluation.size() <= 0) {
					info.put("status", "2");
					info.put("message", "EvaluationType id not present");
					return info;
				}	
			User userresult = null;
			if (request.getUser() == null || request.getUser().equals("")) {
				userresult = null;
			} else {
				List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
				userresult = user.get(0);
			}

			
			List<EvaluatorSelection> task = super.EvaluatorSelection.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCollegesIdAndExamAnnouncementIdAndEvaluationIdAndCoursesIdAndExpertId(
							false, true, request.getAcademicYear(), request.getColleges(),
							request.getExamAnnouncement(), request.getEvaluationType(), 
							request.getCourses(), request.getEvaluatorId());
			if (task.size() > 0) {
				info.put("status", "2");
				info.put("message", "Evaluator already selected");
				return info;
			}

			Date date = new Date();

			SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");
			SimpleDateFormat time = new SimpleDateFormat("HH:MM");

			EvaluatorSelection selection = new EvaluatorSelection();

			selection.setAcademicYear(academicYear.get());
			selection.setColleges(collage.get());
			selection.setEvaluation(evaluation.get(0));
			selection.setExamAnnouncement(result.get());
			selection.setUser(userresult);
			selection.setRegistrationType(registration.get(0));
			selection.setExEvaluationFrom(date1.parse(request.getExEvaluationFrom() + " 00:00:00"));
			selection.setExEvaluationTime(time.parse(request.getExEvaluationTime()));
			selection.setExEvaluationTo(date1.parse(request.getExEvaluationTo() + " 23:59:00"));
			selection.setExEvaluationVenue(request.getExEvaluationVenue());
		//	selection.setExFirstName(request.getExFirstName());
			selection.setExIsActive(true);
			selection.setExIsDelete(false);
			selection.setExCreateDate(date);
		//	selection.setExMobile(request.getExMobile());
			selection.setCourses(courses.get());
			selection.setExpert(expertid.get());
			selection.setDegree(degree.get());
			//selection.setDepartment(dept.get());
			selection.setProgrammes(Prog.get());
			super.EvaluatorSelection.save(selection);
			
			
		
			info.put("status", "1");
			info.put("message", "Evaluator saved successfully");
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getEvaluatorSelection(EvaluatorSelectionRequest request) {		
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
			if (request.getAcademicYear() == null || request.getAcademicYear().equals("")) {
				info.put("status", "2");
				info.put("message", "Academicyear is required");
				return info;
			}
			
			if (request.getColleges()== null || request.getColleges().equals("")) {
				info.put("status", "2");
				info.put("message", "Colleges is required");
				return info;
			}
			if (request.getCourses()== null || request.getCourses().equals("")) {
				info.put("status", "2");
				info.put("message", "Course is required");
				return info;
			}
			if (request.getProgrammes()== null || request.getProgrammes().equals("")) {
				info.put("status", "2");
				info.put("message", "Programme is required");
				return info;
			}
			if (request.getExamAnnouncement() == null || request.getExamAnnouncement().equals("")) {
				info.put("status", "2");
				info.put("message", "Examannouncement id is required");
				return info;
			}
			
			if (request.getEvaluationType() == null || request.getEvaluationType().equals("")) {
				info.put("status", "2");
				info.put("message", "EvaluationType id is required");		
				return info;
			}	
			
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false,true, request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(),false,true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;			
			}
			Optional<Courses> course = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(),false,true);
			if (!course.isPresent()) {
				info.put("status", "2");
				info.put("message", "Course Id not Present");
				return info;			
			}
			Optional<Programmes> programmes = super.programmes.findByIdAndExIsDeleteAndExIsActive(request.getProgrammes(),false,true);
			if (!programmes.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes Id not Present");
				return info;			
			}
			
			List<RegistrationType> registration = super.registrationType.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType not present");
				return info;
			}
			
			
			Optional<ExamAnnouncement> ExamAnnouncement = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false ,true ,request.getExamAnnouncement());
            if(!ExamAnnouncement.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncementId not present");
			return info;
		   }			
            List<EvaluationType> evaluation = super.evaluationType.findByIdAndExIsDelete(request.getEvaluationType(), false);		
			if (evaluation.size() <= 0) {
				info.put("status", "2");
				info.put("message", "EvaluationType id not present");
				return info;
			}				
			
			String serverurl = super.commonHelper.getSettingValue("SERVER_IP");
						
			List<EvaluatorSelection> task = null ; 
				task = super.EvaluatorSelection.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCollegesIdAndExamAnnouncementIdAndEvaluationIdAndProgrammesIdAndCoursesIdAndRegistrationTypeId
						(false , true, request.getAcademicYear() , request.getColleges() , request.getExamAnnouncement() , request.getEvaluationType(),request.getProgrammes(),request.getCourses(), request.getRegistrationType());
		
			if(task.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No records found");
				return info;
			}
									
			List dataList = new LinkedList();
			for (EvaluatorSelection e : task) {
				Map<Object, Object> evaluator = new HashMap<Object, Object>();
				evaluator.put("id", e.getId());
				evaluator.put("exQpFile", (e.getExQpUrl()== null || e.getExQpUrl()== "NA") ?null :serverurl+e.getExQpUrl());
				evaluator.put("exAnswerKeyFile", (e.getExAnswerKeyUrl()== null || e.getExAnswerKeyUrl()== "NA")?null :serverurl+e.getExAnswerKeyUrl());
				evaluator.put("exGuidelinesFile", (e.getExGuidelinesUrl()== null || e.getExGuidelinesUrl()== "NA")?null :serverurl+e.getExGuidelinesUrl());
				evaluator.put("exRemurationFile", (e.getExRemurationUrl()== null || e.getExRemurationUrl()== "NA")?null :serverurl+e.getExRemurationUrl());
				evaluator.put("exAccommodationFile", (e.getExAccommodationUrl()== null || e.getExAccommodationUrl()== "NA")?null :serverurl+e.getExAccommodationUrl());
				evaluator.put("exEvaluationTime", e.getExEvaluationTime().toString().substring(0, 5));
				evaluator.put("exEvaluationFrom", e.getExEvaluationFrom().toString().substring(0, 10));
				
				evaluator.put("exEvaluationTo", e.getExEvaluationTo().toString().substring(0, 10));
				evaluator.put("exEvaluationVenue", e.getExEvaluationVenue());
				
				evaluator.put("examAnnouncement", e.getExamAnnouncement().getExName());
				evaluator.put("examAnnouncementId", e.getExamAnnouncement().getId());	
				evaluator.put("registrationType", e.getRegistrationType().getExName());
				evaluator.put("registrationTypeId", e.getRegistrationType().getId());
				
				evaluator.put("evaluationType", e.getEvaluation().getExName());
				evaluator.put("evaluationTypeId", e.getEvaluation().getId());	
				evaluator.put("exName", e.getExpert().getExName());
				evaluator.put("evaluatorListId", e.getExpert().getId());
				evaluator.put("exMobile", e.getExpert().getExContactDetails());
				evaluator.put("exFullName", e.getExpert().getExFullName());
				
				evaluator.put("courses",e.getCourses().getExName());
				evaluator.put("coursesId",e.getCourses().getId());
				evaluator.put("courseCode", e.getCourses().getExCoursesCode());
				evaluator.put("creditHours", e.getCourses().getCreditHours().getExCreditHourTitle());				
				evaluator.put("exDesignation",e.getExpert().getExdesignation());
				evaluator.put("addressLine1",e.getExpert().getExAddressLine1());
				
				dataList.add(evaluator);
			}
			info.put("status", "1");
			info.put("message", "success");
			info.put("evaluator", dataList);
				return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
		
	}

	@Override
	public Map<String, Object> getactivedetailsonStaff(Long staffId) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
			if (staffId == null || staffId.equals("")) {
				info.put("status", "2");
				info.put("message", "staffid  is required");		
				return info;
			}		
			
			String serverurl = super.commonHelper.getSettingValue("SERVER_IP");
			
			List<EvaluatorSelection> task  = super.EvaluatorSelection.findByExIsActiveAndExpertId( true, staffId);			
			if(task.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No records found");
				return info;
			}
									
			List dataList = new LinkedList();
			for (EvaluatorSelection e : task) {
				Map<Object, Object> evaluator = new HashMap<Object, Object>();
				evaluator.put("id", e.getId());
			
				evaluator.put("exFirstName", e.getExFirstName());
				evaluator.put("exMobile", e.getExMobile());
				evaluator.put("exEmployeeId", e.getExEmployeeId());
				evaluator.put("exEvaluationTime", e.getExEvaluationTime().toString().substring(0, 5));
				evaluator.put("exEvaluationFrom", e.getExEvaluationFrom().toString().substring(0, 10));
				
				evaluator.put("exEvaluationTo", e.getExEvaluationTo().toString().substring(0, 10));
				evaluator.put("exEvaluationVenue", e.getExEvaluationVenue());
				
				evaluator.put("examAnnouncement", e.getExamAnnouncement().getExName());
				evaluator.put("examAnnouncementId", e.getExamAnnouncement().getId());	
				
				evaluator.put("evaluationType", e.getEvaluation().getExName());
				evaluator.put("evaluationTypeId", e.getEvaluation().getId());	
				
				
				evaluator.put("academicYear",e.getAcademicYear().getExYear());
				evaluator.put("academicYearId",e.getAcademicYear().getId());
				
				
				evaluator.put("courses",e.getCourses().getExName());
				evaluator.put("coursesId",e.getCourses().getId());
		//		evaluator.put("staffName", e.getStaffpersonal().getExName());

				
		//		evaluator.put("staffid",e.getStaffpersonal().getId());
				
				
				dataList.add(evaluator);
			}
			info.put("status", "1");
			info.put("message", "success");
			info.put("evaluator", dataList);
				return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
		
	}

	@Override
	public Map<String, Object> bookletAllocation(BookletStaffRequest request) {
		// TODO Auto-generated method stub
		Map<String, Object> info = new LinkedHashMap<>();
		List<String> failureList = new ArrayList<String>();
		List<String> successList = new ArrayList<String>();
		List<Object> list = new ArrayList<Object>();
		try {					
			if (request.getAcademicYear() == null || request.getAcademicYear().equals("")) {
				info.put("status", "2");
				info.put("message", "Academicyear is required");
				return info;
			}
												
			if (request.getExamAnnouncement() == null || request.getExamAnnouncement().equals("")) {
				info.put("status", "2");
				info.put("message", "Examannouncement is required");
				return info;
			}	
			if(request.getStaffId() == null || request.getStaffId().equals("")) {
				info.put("status", "2");
				info.put("message", " staff is required");
				return info;
			}	
			if(request.getAllocatedbooklet() == null || request.getAllocatedbooklet().equals("") ||request.getAllocatedbooklet()==0) {
				info.put("status", "2");
				info.put("message", " Please Allocate booklet");
				return info;
			}	
			if(request.getLimitperday() == null || request.getLimitperday().equals("")) {
				info.put("status", "2");
				info.put("message", " limitperday is required");
				return info;
			}	
			
			
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false,true, request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			
			Optional<Colleges> col = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,	true);
			 if (!col.isPresent()) {
					info.put("status", "2");
					info.put("message", "college id not present");
					return info;
				}
			 
			 List<RegistrationType> registration = super.registrationType.findByIdAndExIsDelete(request.getRegistrationType(), false);
				if (registration.size() <= 0) {
					info.put("status", "2");
					info.put("message", "RegistrationType id not present");
					return info;
				}
			
			Optional<Programmes> Prog = super.programmes.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", " Programe not present");
				return info;
			}
						
			Optional<ExamAnnouncement> ExamAnnouncement = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false ,true ,request.getExamAnnouncement());
            if(!ExamAnnouncement.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncementId not present");
			return info;
		   }
            Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourse(),false, true);
			 if (!courses.isPresent()) {
					info.put("status", "2");
					info.put("message", "courses not present");
					return info;
			}
			 
				Optional<EvaluatorList> Staffpersonal = super.expertlist.findById(request.getStaffId());
				if (!Staffpersonal.isPresent()) {
					info.put("status", "2");
					info.put("message", "Expert not present");
					return info;
				}	
				User userresult=null ;
				if(request.getUser()== null || request.getUser().equals("")) {
					userresult=null;
				}else {
					List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false,true);		
					if (user.size() <= 0) {
						info.put("status", "2");
						info.put("message", "User id not present");
						return info;
					}
					userresult=user.get(0);
				}			 								
					//EvaluationDetailsRepository.save(details);					
					List<EvaluationDetails> validatestaff = super.evaluationDetails.findByExamAnnouncementIdAndAcademicYearIdAndCoursesIdAndDegreeIdAndProgrammesIdAndRegistrationTypeIdAndExpertId
																(request.getExamAnnouncement() , request.getAcademicYear() , request.getCourse() , request.getColleges() , request.getProgrammes() , request.getRegistrationType() , request.getStaffId());
					if(validatestaff.size() >0) {
						info.put("status", "2");
						info.put("message", "Expert already allocated:"+validatestaff.get(0).getExpert().getExFullName());
						return info;
					}										
			
			 	 Date date = new Date();		 
			 	 int retval = 0;
			 	 boolean is_attendence = true;
			 // Based on allocatedbooklet Count get All the student List	
			 //Long examid , Long academicyear , Long college , Long program, Pageable pageable
			// for(int i =0; i< request.getStaffdetails().size() ;i++) {	
			 	 
			 	 logger.info("ddddddddddddddddddddddddd  "+request.getAllocatedbooklet().intValue());
				PageRequest paging = PageRequest.of(0, request.getAllocatedbooklet().intValue());		
				 List<ExamBarcodes> page = super.ExamBarcodes.getStudentForEvalution(request.getExamAnnouncement(),request.getAcademicYear(),request.getColleges(),request.getProgrammes() , is_attendence , request.getRegistrationType(),request.getCourse()  , paging);				 
				 if(page.size() >0) {					 
						for(ExamBarcodes student : page) {
							if(student.getExAnsBookletPath()!=null) {	
							  retval = super.exambarcode.updateStaffId(request.getStaffId(), date, request.getAcademicYear(), request.getProgrammes(), request.getCourse(), student.getExBarcode() , request.getExamAnnouncement());
							  successList.add("Success" +student.getExBarcode());	
							  }
							else {
								failureList.add(student.getExBarcode()+ ":barcode booklet not present");
		     					list.add(student.getExBarcode());
							}							
						}
						if(successList.size()>0) {
								Optional<EvaluatorList> Staffpersonalres = super.expertlist.findById(request.getStaffId());
								 // update Log table 
						     	bookletLog(successList.size(),page.get(0).getAcademicYear() ,page.get(0).getCourses(),page.get(0).getDegree(),page.get(0).getExamAnnouncement(),page.get(0).getRegistrationType(),page.get(0).getSemester(),page.get(0).getProgrammeYear(),page.get(0).getProgrammes(),request.getLimitperday() , Staffpersonalres.get(),false ,userresult);					
						
						}
						}else {
				 		info.put("status", "2");

						info.put("message", "Students not present");

					//	info.put("message", "Booklet Already Allocated");

						return info;						
					}				 
			// }	
				logger.info("Booklet Not AllocatedNot Inserted : " + failureList);
		 		info.put("status", "1");
				info.put("message", "Booklet Allocate ");
				info.put("success", successList.size() + " Booklet Allocated Successfully");
				info.put("failure", list.size() + " Booklet Not Allocated");
				return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}	
	
	private Boolean bookletLog(int allocatedbooklet, AcademicYear academicYear, Courses courses, Degree degree, ExamAnnouncement examAnnouncement, RegistrationType registrationType, Semster semster, ProgrammeYear programmeYear, Programmes programmes, Long limitperday, EvaluatorList staffpersonal,Boolean isreallocated ,User user) {
		try {
			Date date = new Date();
			EvaluationDetails details = new EvaluationDetails();
			details.setAcademicYear(academicYear);
			//details.setColleges(colleges);
			details.setCourses(courses);
			details.setDegree(degree);
			details.setExAllocatedBooklet(Long.valueOf(allocatedbooklet));
			details.setExamAnnouncement(examAnnouncement);
			details.setExCreateDate(date);
			details.setExLimitPerDay(limitperday);
			//details.setExTimeLimit();
			details.setProgrammes(programmes);
			details.setRegistrationType(registrationType);
			details.setExpert(staffpersonal);
			details.setExIsActive(true);
			details.setExIsDelete(false);
			details.setProgrammeYear(programmeYear);
			details.setSemester(semster);
			details.setExIsReallocated(isreallocated);
			if(isreallocated==false) {
			details.setExIntiAllocatedBooklet(Long.valueOf(allocatedbooklet));
			details.setAllocationUser(user);	
			}
			else {
				details.setReAllocationUser(user);		
			}
			
			super.evaluationDetails.save(details);
			return true;
		}catch(Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			return false;
		}
	}

	@Override
	public Map<String, Object> reAllocateBooklet(EvaluationDetailsRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
			if (request.getAcademicYear() == null || request.getAcademicYear().equals("")) {
				info.put("status", "2");
				info.put("message", "Academicyear is required");
				return info;
			}												
			if (request.getExamAnnouncement() == null || request.getExamAnnouncement().equals("")) {
				info.put("status", "2");
				info.put("message", "Examannouncement is required");
				return info;
			}
			
			if (request.getCourse() == null || request.getCourse().equals("")) {
				info.put("status", "2");
				info.put("message", "Course is required");
				return info;
			}	
			if (request.getProgrammes() == null || request.getProgrammes().equals("")) {
				info.put("status", "2");
				info.put("message", "Programmes is required");
				return info;
			}
			if (request.getRegistrationType() == null || request.getRegistrationType().equals("")) {
				info.put("status", "2");
				info.put("message", "RegistrationType is required");
				return info;
			}
			if (request.getOldstaffid() == null || request.getOldstaffid().equals("")) {
				info.put("status", "2");
				info.put("message", "Oldstaffid is required");
				return info;
			}
			if (request.getNewstaffid() == null || request.getNewstaffid().equals("")) {
				info.put("status", "2");
				info.put("message", "Newstaffid is required");
				return info;
			}
			Optional<EvaluatorList> Oldstaffid = super.expertlist.findById(request.getOldstaffid() );
			if (!Oldstaffid.isPresent()) {
				info.put("status", "2");
				info.put("message", "Oldstaff not present");
				return info;
			}
			Optional<EvaluatorList> Newstaffid = super.expertlist.findById(request.getNewstaffid());
			if (!Newstaffid.isPresent()) {
				info.put("status", "2");
				info.put("message", "Newstaff not present");
				return info;
			}
		
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false,true, request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			
			  Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true,request.getDegree());
				if (!degree.isPresent() || !degree.get().getExIsActive()) {
					info.put("status", "2");
					info.put("message", "Degree not present");
					return info;
				}
			
			Optional<Programmes> Prog = super.programmes.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", " Programe not present");
				return info;
			}
						
			Optional<ExamAnnouncement> ExamAnnouncement = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false ,true ,request.getExamAnnouncement());
            if(!ExamAnnouncement.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncementId not present");
			return info;
		   }
            Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourse(),	false, true);
			 if (!courses.isPresent()) {
					info.put("status", "2");
					info.put("message", "courses not present");
					return info;
			}
			List<RegistrationType> registration = super.registrationType.findByIdAndExIsDelete(request.getRegistrationType(), false);
				if (registration.size() <= 0) {
					info.put("status", "2");
					info.put("message", "RegistrationType id not present");
					return info;
			}
			 User userid =super.commonHelper.getuser(request.getUser()) ;
			 //EvaluationDetailsResponse
			Date date=new Date();
        	List dataList = new LinkedList();
        	int evaluated=0;
			List<ExamBarcodes>  recordlist= super.exambarcode.findByExIsAttendanceAndAcademicYearIdAndDegreeIdAndProgrammesIdAndExamAnnouncementIdAndCoursesIdAndExpertIdAndRegistrationTypeIdAndExIsEvaluatedAndIdIn(true,request.getAcademicYear(),request.getDegree(),request.getProgrammes(),request.getExamAnnouncement(),request.getCourse(),request.getOldstaffid(),request.getRegistrationType(),evaluated , request.getBarcodelist());
			if (recordlist.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No records found");
				return info;
		   } 	

		   for(ExamBarcodes res : recordlist) {
			  int  retval = super.exambarcode.updateStaffIdReallocation(request.getNewstaffid(), date, request.getAcademicYear(), request.getProgrammes(), request.getCourse(), res.getExBarcode() , request.getExamAnnouncement(),request.getRegistrationType(),request.getDegree(),res.getId());				   
		   }
		   List<EvaluationDetails> validatestaff = super.evaluationDetails.findByExamAnnouncementIdAndAcademicYearIdAndCoursesIdAndDegreeIdAndProgrammesIdAndRegistrationTypeIdAndExpertId
					(request.getExamAnnouncement() , request.getAcademicYear() , request.getCourse() , request.getDegree() , request.getProgrammes() , request.getRegistrationType() , request.getOldstaffid());
               if(validatestaff.size() <=0) {
               info.put("status", "2");
               info.put("message", " staff  not allocated:");
               return info;
           }
   	    String Description=request.toString();			
   		Boolean audit = commonHelper.saveauditlogdetails(false , Description ,userid, 60L);	   
        Long remaining = validatestaff.get(0).getExAllocatedBooklet()-request.getBarcodelist().size();
   		
   		
   		bookletLog(recordlist.size(),academicYearid.get() ,courses.get(),recordlist.get(0).getDegree(),ExamAnnouncement.get(),registration.get(0),recordlist.get(0).getSemester(),recordlist.get(0).getProgrammeYear(),Prog.get(),validatestaff.get(0).getExLimitPerDay(),Newstaffid.get(),true,userid );					
		   int  resultvalue = super.evaluationDetails.updatebookletlog(true, date, request.getAcademicYear(), request.getProgrammes(), request.getCourse() , request.getExamAnnouncement(),request.getRegistrationType(),request.getDegree(),request.getOldstaffid(),request.getNewstaffid(),remaining);				   
		   if(resultvalue==0)
		   {
			   info.put("status", "2");
			   info.put("message", "something went wrong BookletLog ");	
			   return info;  
		   }
		        info.put("status", "1");
				info.put("message", "Booklets are reallocated successfully");	
				return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getCoursesOnExam(EvaluationDetailsRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
			if (request.getAcademicYear() == null || request.getAcademicYear().equals("")) {
				info.put("status", "2");
				info.put("message", "Academicyear is required");
				return info;
			}
			
			if (request.getDegree() == null || request.getDegree().equals("")) {
				info.put("status", "2");
				info.put("message", "degree is required");
				return info;
			}	
			
			if (request.getProgrammes() == null || request.getProgrammes().equals("")) {
				info.put("status", "2");
				info.put("message", "Programmes is required");
				return info;
			}																
			if (request.getExamAnnouncement() == null || request.getExamAnnouncement().equals("")) {
				info.put("status", "2");
				info.put("message", "Examannouncement is required");
				return info;
			}						
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false,true, request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}			
						
			Optional<ExamAnnouncement> ExamAnnouncement = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false ,true ,request.getExamAnnouncement());
            if(!ExamAnnouncement.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncementId not present");
			return info;
		   }	
            
            Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true,request.getDegree());
			if (!degree.isPresent() || !degree.get().getExIsActive()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}
			
			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", " Programe not present");
				return info;
			}
			
			 List<RegistrationType> registration = super.registrationType.findByIdAndExIsDelete(request.getRegistrationType(), false);
				if (registration.size() <= 0) {
					info.put("status", "2");
					info.put("message", "RegistrationType id not present");
					return info;
				}
			
			List<ExamBarcodes> ormmarks = super.exambarcode.getCoursesDetails(request.getExamAnnouncement(),request.getAcademicYear(),request.getProgrammes(),  request.getRegistrationType());			
			 if(ormmarks.size() <=0){
	        		info.put("status", "2");
	    			info.put("message", "Exam not conducted");		
	    			return info;
	        	}
			           
        	List dataList = new LinkedList();	
           for (ExamBarcodes e : ormmarks) {
        		Map<Object, Object> coursesdata = new HashMap<Object, Object>();
				coursesdata.put("id", e.getCourses().getId());
				coursesdata.put("exName", e.getCourses().getExName());
				coursesdata.put("exCoursesCode",e.getStudentadmission().getBatch().getExIdentifier()+"::"+ e.getCourses().getExCoursesCode()+"::"+e.getCourses().getExName());
				coursesdata.put("creditHours", e.getCourses().getCreditHours().getExCreditHourTitle());
				coursesdata.put("exIsSatisfactory", e.getCourses().getExIsSatisfactory());
				coursesdata.put("exIsElective", e.getCourses().getExIsElective());	
				coursesdata.put("exIsProject", e.getCourses().getExIsProject());				
				coursesdata.put("exIsSeminar", e.getCourses().getExIsSeminar());				

				
				
				dataList.add(coursesdata);
        	}	
			info.put("status", "1");
			info.put("message", "success");		
        	info.put("details", dataList);

				return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getStudentCount(EvaluationDetailsRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
			if (request.getAcademicYear() == null || request.getAcademicYear().equals("")) {
				info.put("status", "2");
				info.put("message", "Academicyear is required");
				return info;
			}
												
			if (request.getExamAnnouncement() == null || request.getExamAnnouncement().equals("")) {
				info.put("status", "2");
				info.put("message", "Examannouncement is required");
				return info;
			}						
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false,true, request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			
			  Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true,request.getDegree());
				if (!degree.isPresent() || !degree.get().getExIsActive()) {
					info.put("status", "2");
					info.put("message", "Degree not present");
					return info;
				}
			
			Optional<Programmes> Prog = super.programmes.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", " Programe not present");
				return info;
			}
						
			Optional<ExamAnnouncement> ExamAnnouncement = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false ,true ,request.getExamAnnouncement());
            if(!ExamAnnouncement.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncementId not present");
			return info;
		   }
            
            List<RegistrationType> registration = super.registrationType.findByIdAndExIsDelete(request.getRegistrationType(), false);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType id not present");
				return info;
			}
			
            Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourse(),	false, true);
			 if (!courses.isPresent()) {
					info.put("status", "2");
					info.put("message", "courses not present");
					return info;
			}
        	List dataList = new LinkedList();	
        	
        	
        	
    	   	// check If registraion type Re-Evaluation or Supplymentry-Re-Evaluation
            	if(request.getRegistrationType()  == 3 || request.getRegistrationType() == 7) {
            		return getReEvaluationCount(request.getRegistrationType() , request.getProgrammes() , ExamAnnouncement.get().getProgrammeYear().getId() , request.getCourse() , request.getDegree() , request.getAcademicYear(),ExamAnnouncement.get().getSemester().getId());
            	}
        	
        	List<ExamBarcodes> ormmarks = super.exambarcode.findByExamAnnouncementIdAndAcademicYearIdAndCoursesIdAndProgrammesIdAndExIsAttendanceAndRegistrationTypeIdAndDegreeId
        			(request.getExamAnnouncement(),request.getAcademicYear(), request.getCourse() , request.getProgrammes()  , true  , request.getRegistrationType() , request.getDegree());
			 if(ormmarks.size() <=0){
	        		info.put("status", "2");
	    			info.put("message", "Bookled Not Uploded");		
	    			return info;
	        }
			 
			 
			 List<ExamBarcodes> pending = super.ExamBarcodes.findByExamAnnouncementIdAndAcademicYearIdAndCoursesIdAndProgrammesIdAndExIsAttendanceAndRegistrationTypeIdAndDegreeId
	        			(request.getExamAnnouncement(),request.getAcademicYear(), request.getCourse() , request.getProgrammes()  , true  , request.getRegistrationType() , request.getDegree() );
				
			/*
			 * if(pending.size() <=0){ info.put("status", "2"); info.put("message",
			 * "Exam not conducted"); //return info; }
			 */
			 
				 int notallocated=0;
				 int allacted=0;

				 for(ExamBarcodes o :pending) {
					 if(o.getExpert() == null || o.getExIsEvaluated().equals("")) {
						 ++notallocated;
					 }
					
				 }
        	
				 allacted = ormmarks.size()-notallocated;
				info.put("totalstudent", ormmarks.size()<=0?0:ormmarks.size());
				info.put("allocatedstudent",allacted<=0?0:allacted);
				info.put("remainingStudent", notallocated<=0?0:notallocated);

				info.put("status", "1");
				info.put("message", "success");		
				return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}
	
	private Map<String, Object> getReEvaluationCount(Long registrationType, Long programmes, Long programmeyear,
			Long course, Long degree, Long academicYear, Long semester) {
		Map<String, Object> info = new LinkedHashMap<>();
		// get Student Details who apply for Re-Evaluation or Supplymentry-Re-Evaluation
		List<CoursesRegistration> ormmarks = super.coursesRegistration.findByProgrammesIdAndExIsActiveAndExIsDeleteAndRegistrationIdAndCoursesIdAndProgrammeYearIdAndSemesterId(programmes , true , false , registrationType , programmeyear , courses,semester);												
		if(ormmarks.size() <= 0 ) {
    		info.put("status", "2");
			info.put("message", "Student Not Apply for Re-Evaluation");		
			return info;
		}
		
		List<String> name = new ArrayList<String>();
		
		for(CoursesRegistration s : ormmarks) {
			name.add(s.getStudentadmission().getExRollNo());
		}
		 List<ExamBarcodes> pending = super.ExamBarcodes.findByProgrammeYearIdAndSemesterIdAndAcademicYearIdAndCoursesIdAndProgrammesIdAndExIsAttendanceAndDegreeIdAndExIsReevaluatedAndExRollNoIn
     			(programmeyear,semester,academicYear, courses ,programmes  , true  , degree , false ,  name);
			
		 int notallocated=0;
		 int allacted=0;

		 for(ExamBarcodes o :pending) {
			 if(o.getExIsReevaluated() == null || o.getExIsReevaluated() == false) {
				 ++notallocated;
			 }
			
		 }		
		 allacted = ormmarks.size()-notallocated;
		info.put("totalstudent", ormmarks.size()<=0?0:ormmarks.size());
		info.put("allocatedstudent",allacted<=0?0:allacted);
		info.put("remainingStudent", notallocated<=0?0:notallocated);

		info.put("status", "1");
		info.put("message", "success");		
		return info;	
	}
	
    public static Long convertToLong(Object o){
        String stringToConvert = String.valueOf(o);
        Long convertedLong = Long.parseLong(stringToConvert);
        return convertedLong;

    }
	

	@Override
	public Map<String, Object> getTeacherList(EvaluationDetailsRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
			if (request.getAcademicYear() == null || request.getAcademicYear().equals("")) {
				info.put("status", "2");
				info.put("message", "Academicyear is required");
				return info;
			}
												
			if (request.getExamAnnouncement() == null || request.getExamAnnouncement().equals("")) {
				info.put("status", "2");
				info.put("message", "Examannouncement is required");
				return info;
			}						
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false,true, request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			
			  Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true,request.getDegree());
				if (!degree.isPresent() || !degree.get().getExIsActive()) {
					info.put("status", "2");
					info.put("message", "Degree not present");
					return info;
				}
			
			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", " Programe not present");
				return info;
			}
						
			Optional<ExamAnnouncement> ExamAnnouncement = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false ,true ,request.getExamAnnouncement());
            if(!ExamAnnouncement.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncementId not present");
			return info;
		   }
            Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActiveAndAcademicYearId(request.getCourse(),	false, true,request.getAcademicYear());
			 if (!courses.isPresent()) {
					info.put("status", "2");
					info.put("message", "courses not present");
					return info;
			}
			 
			 //EvaluationDetailsResponse
			 
        	List dataList = new LinkedList();	
        	
        	ArrayList<Object[]> evedetails  = super.teacherCourseMapping.getTeacherList(request.getProgrammes(),request.getCourse(), request.getDegree(), ExamAnnouncement.get().getProgrammeYear().getId() , request.getAcademicYear(),ExamAnnouncement.get().getSemester().getId());	
        	
        	if(evedetails.size()<=0) {
        		info.put("status", "2");
				info.put("message", "Teacher not Mapped with selected Courses");
				return info;
        	}
        	
        	for (Object[] e : evedetails) {
				Map<Object, Object> staffinfo = new HashMap<Object, Object>();
				staffinfo.put("exName", e[0]);
				staffinfo.put("employeeId", e[1]);
				staffinfo.put("mobile", e[2]);
				staffinfo.put("stafftype", e[3]);
				staffinfo.put("stafftypeid", e[4]);
				staffinfo.put("stafftid", e[5]);
				dataList.add(staffinfo);
			}
        	        	
        
				info.put("status", "1");
				info.put("message", "success");	
        		info.put("details", dataList);

				return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getBarcodeStatusOnstaff(BookletStaffRequest request) {
		// TODO Auto-generated method stub
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			if (request.getAcademicYear() == null || request.getAcademicYear().equals("")) {
				info.put("status", "2");
				info.put("message", "Academicyear is required");
				return info;
			}

			if (request.getExamAnnouncement() == null || request.getExamAnnouncement().equals("")) {
				info.put("status", "2");
				info.put("message", "Examannouncement is required");
				return info;
			}
			if (request.getStaffId() == null || request.getStaffId().equals("")) {
				info.put("status", "2");
				info.put("message", " staff is required");
				return info;
			}

			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}

			Optional<ExamAnnouncement> ExamAnnouncement = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false, true, request.getExamAnnouncement());
			if (!ExamAnnouncement.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncementId not present");
				return info;
			}

			Optional<EvaluatorList> Staffpersonal = super.expertlist.findById(request.getStaffId());
			if (!Staffpersonal.isPresent()) {
				info.put("status", "2");
				info.put("message", "Staff not present");
				return info;
			}
			List<ExamBarcodes> recordlist = super.ExamBarcodes.findByAcademicYearIdAndExamAnnouncementIdAndExpertId(
					request.getAcademicYear(), request.getExamAnnouncement(), request.getStaffId());
			if (recordlist.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No records found");
				return info;
			}
			String serverurl = commonHelper.getSettingValue("SERVER_IP");
			String localurl = commonHelper.getSettingValue("DOCUMENT_PATH");
			List dataList = new LinkedList();
			int isEvaluated = 0;
			int savedisEvaluated = 2;
			for (ExamBarcodes e : recordlist) {
				Map<Object, Object> staffinfo = new HashMap<Object, Object>();
				int filecount = 0;
				staffinfo.put("barcode", e.getExBarcode());
				staffinfo.put("exIsEvaluated", e.getExIsEvaluated());
				dataList.add(staffinfo);

			}
			if (dataList.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No records found");
				return info;

			} else {
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> saveEvaluatedMark(EvaluationDetailsRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {									
			if (request.getStaffid() == null || request.getStaffid().equals("")) {
				info.put("status", "2");
				info.put("message", "Expert is required");
				return info;
			}
			if (request.getBarcode() == null || request.getBarcode().equals("")) {
				info.put("status", "2");
				info.put("message", "Barcode is required");
				return info;
			}	
			if (request.getMethodType() == null || request.getMethodType().equals("")) {
				info.put("status", "2");
				info.put("message", "MethodType is required");
				return info;
			}	
			if (request.getTimetaken() == null || request.getTimetaken().equals("")) {
				info.put("status", "2");
				info.put("message", "Timetaken is required");
				return info;
			}	
			if (request.getEvaluatedtime() == null || request.getEvaluatedtime().equals("")) {
				info.put("status", "2");
				info.put("message", "Evaluatedtime is required");
				return info;
			}	
			if (request.getEvaluatedfile() == null || request.getEvaluatedfile().equals("")) {
				info.put("status", "2");
				info.put("message", "Evaluatedfile is required");
				return info;
			}

			Optional<EvaluatorList> Staffpersonal = super.expertlist.findById(request.getStaffid());
			if (!Staffpersonal.isPresent()) {
				info.put("status", "2");
				info.put("message", "Expert not present");
				return info;
			}      			
        	String destDir = commonHelper.getSettingValue("DOCUMENT_PATH");
        	
			List<ExamBarcodes> staffdetail = super.ExamBarcodes.findByExpertIdAndExBarcode(request.getStaffid() , request.getBarcode());
              if(staffdetail.size()<=0) {
            	  info.put("status", "2");
            	  info.put("message", "Expert not mapped with barcode");	
            	  return info;	        	
            }
        	int isEvaluated =1;
            if(staffdetail.get(0).getExIsEvaluated()==isEvaluated){
            	info.put("status", "2");
    			info.put("message", "Marks already submitted");	
    			return info;	
            }
           // System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>"+request.getEvaluatedfile().size());
            
       	 String UPLOADED_FOLDER = EvaluatedpathFolder(staffdetail.get(0).getAcademicYear().getExYear(),"AnswerBooklet" ,staffdetail.get(0).getColleges().getExIdentifier(),staffdetail.get(0).getProgrammes().getExIdentifier(),staffdetail.get(0).getCourses().getExCoursesCode(),staffdetail.get(0).getExBarcode(),"VerifiedAnswerSheet/");		            
              String extension = ".png";
            for(int i = 0 ; i<request.getEvaluatedfile().size() ; i++) {           	
            	String image = request.getEvaluatedfile().get(i);
            	 String[] result = image.split(",");
            	
            	//logger.info("........."+result[1]);          	
            	
            		//logger.info("?????????"+request.getPhoto().get(i));           		
            		byte[] data = DatatypeConverter.parseBase64Binary(result[1]);            		
            		
            		int  j = 0;
            		if(i == 0) {
            			j = 1;
            		}else {
            			 j = i+1;
            		}           		
            		 String newfilename = UPLOADED_FOLDER+String.valueOf(j)+extension;
            		 //System.out.println(">>>>>>>>>>>>>>>>>"+newfilename);
            		 File file = new File(newfilename);
            		 try (OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(file))) {
            	            outputStream.write(data);
            	        } catch (IOException e) {
            	            e.printStackTrace();
            	        }
            	           	 
            }	      
            String  evaluatedpath = "/"+staffdetail.get(0).getAcademicYear().getExYear()+"/"+"AnswerBooklet"+"/"+staffdetail.get(0).getColleges().getExIdentifier()+"/"+staffdetail.get(0).getProgrammes().getExIdentifier()+"/"+staffdetail.get(0).getCourses().getExCoursesCode()+"/"+staffdetail.get(0).getExBarcode()+"/"+"VerifiedAnswerSheet/";
			if(request.getMethodType().equalsIgnoreCase("save")){
			int is_evaluated =2;
    		int  recordlist= super.ExamBarcodes.updeterecordonstaffidSave(request.getExternalMark(),request.getEvaluatedtime(),request.getTimetaken(),evaluatedpath,request.getBarcode(),request.getStaffid(),is_evaluated);	   
    		if(recordlist==1){     			
    			         List<ExternalMarks> testres =ExternalMarksRepository.findByExpertIdAndExBarcode(request.getStaffid(), request.getBarcode());
    			            if(testres.size()<=0) {
    			            	Boolean res = savemarks(request.getBarcode(),Staffpersonal.get(),staffdetail.get(0),request.getFirstQMarks(),request.getSecondQMarks(),request.getThirdQMarks(),request.getFourQMarks(),request.getFiveQMarks(),request.getSixQMarks(),request.getSevenQMarks(),request.getEightQMarks(),request.getNineQMarks(),request.getTenQMarks(),request.getElevenQMarks(),request.getTwelveQMarks(),request.getThirteenQMarks(),request.getFourteenQMarks(),request.getFifteenQMarks(),request.getSixteenQMarks(),request.getSeventeenQMarks(),request.getEighteenQMarks(),request.getNinteenQMarks(),request.getTwentyQMarks(),request.getTwentyoneQMarks(),request.getTwentytwoQMarks(),request.getTwentythreeQMarks(),request.getTwentyfourQMarks(),request.getTwentyfiveQMarks(),request.getTwentysixQMarks(),request.getTwentysevenQMarks(),request.getTwentyeightQMarks(),request.getTwentynineQMarks(),request.getThirtyQMarks(),request.getThirtyoneQMarks(),request.getThirtytwoQMarks(),request.getThirtythreeQMarks(),request.getThirtyfourQMarks(),request.getThirtyfiveQMarks(),request.getThirtysixQMarks(),request.getThirtysevenQMarks(),request.getThirtyeightQMarks(),request.getThirtynineQMarks(),request.getFortyQMarks());
			    	    					if(res==true) {
			    	    						ExamBarcodes.updeteMarks(getTotalNumber(request.getStaffid(), request.getBarcode() , request) , request.getStaffid() , request.getBarcode());
			    	    						info.put("status", "1");
			    	    						info.put("message", "Marks saved successfully");	
			    	    						return info;	
			    	    					} 
			    	    					info.put("status", "2");
			    							info.put("message", "Marks not saved successfully");	
			    							return info;	
    			            }
    			            else {
    	    					int update =ExternalMarksRepository.updatemarks(request.getFirstQMarks(),request.getSecondQMarks(),request.getThirdQMarks(),request.getFourQMarks(),request.getFiveQMarks(),request.getSixQMarks(),request.getSevenQMarks(),request.getEightQMarks(),request.getNineQMarks(),request.getTenQMarks(),request.getElevenQMarks(),request.getTwelveQMarks(),request.getBarcode(),Staffpersonal.get(),staffdetail.get(0),request.getThirteenQMarks(),request.getFourteenQMarks(),request.getFifteenQMarks(),request.getSixteenQMarks(),request.getSeventeenQMarks(),request.getEighteenQMarks(),request.getNinteenQMarks(),request.getTwentyQMarks(),request.getTwentyoneQMarks(),request.getTwentytwoQMarks(),request.getTwentythreeQMarks(),request.getTwentyfourQMarks(),request.getTwentyfiveQMarks(),request.getTwentysixQMarks(),request.getTwentysevenQMarks(),request.getTwentyeightQMarks(),request.getTwentynineQMarks(),request.getThirtyQMarks(),request.getThirtyoneQMarks(),request.getThirtytwoQMarks(),request.getThirtythreeQMarks(),request.getThirtyfourQMarks(),request.getThirtyfiveQMarks(),request.getThirtysixQMarks(),request.getThirtysevenQMarks(),request.getThirtyeightQMarks(),request.getThirtynineQMarks(),request.getFortyQMarks());
    	    					if(update==1) {
    	    						ExamBarcodes.updeteMarks(getTotalNumber(request.getStaffid(), request.getBarcode() , request) , request.getStaffid() , request.getBarcode());
    	    						info.put("status", "1");
    	    						info.put("message", "Marks saved successfully");	
    	    						return info;	
    	    					}
    	    					info.put("status", "2");
    							info.put("message", "Marks not saved successfully");	
    							return info;		
    	    			}			
    					
    		        }
  
    		 }
    		
        	if(request.getMethodType().equalsIgnoreCase("Submit")){
        		int  submitlist= super.ExamBarcodes.updeterecordonstaffid(true,request.getExternalMark(),request.getEvaluatedtime(),request.getTimetaken(),evaluatedpath,request.getBarcode(),request.getStaffid());	
        		if(submitlist==1){ 
        			 List<ExternalMarks> testres =ExternalMarksRepository.findByExpertIdAndExBarcode(request.getStaffid(), request.getBarcode());
			            if(testres.size()<=0) {
			            	Boolean res = savemarks(request.getBarcode(),Staffpersonal.get(),staffdetail.get(0),request.getFirstQMarks(),request.getSecondQMarks(),request.getThirdQMarks(),request.getFourQMarks(),request.getFiveQMarks(),request.getSixQMarks(),request.getSevenQMarks(),request.getEightQMarks(),request.getNineQMarks(),request.getTenQMarks(),request.getElevenQMarks(),request.getTwelveQMarks(),request.getThirteenQMarks(),request.getFourteenQMarks(),request.getFifteenQMarks(),request.getSixteenQMarks(),request.getSeventeenQMarks(),request.getEighteenQMarks(),request.getNinteenQMarks(),request.getTwentyQMarks(),request.getTwentyoneQMarks(),request.getTwentytwoQMarks(),request.getTwentythreeQMarks(),request.getTwentyfourQMarks(),request.getTwentyfiveQMarks(),request.getTwentysixQMarks(),request.getTwentysevenQMarks(),request.getTwentyeightQMarks(),request.getTwentynineQMarks(),request.getThirtyQMarks(),request.getThirtyoneQMarks(),request.getThirtytwoQMarks(),request.getThirtythreeQMarks(),request.getThirtyfourQMarks(),request.getThirtyfiveQMarks(),request.getThirtysixQMarks(),request.getThirtysevenQMarks(),request.getThirtyeightQMarks(),request.getThirtynineQMarks(),request.getFortyQMarks());
	    					if(res==true) {
	    						ExamBarcodes.updeteMarks(getTotalNumber(request.getStaffid(), request.getBarcode() , request) , request.getStaffid() , request.getBarcode());
	    						info.put("status", "1");
	    						info.put("message", "Marks sumbited successfully");	
	    						return info;	
	    					}   
	    					info.put("status", "1");
	         				info.put("message", "Marks not sumbited successfully");	
	         				return info;
			            }	    					
			            else {	
			            	//Double firstQMarks =  request.getFirstQMarks() == null :testres.get(0).getFirstQMarks();
			            	//, secondQMarks,  thirdQMarks,  fourQMarks,  fiveQMarks,  sixQMarks, sevenQMarks,  eightQMarks,  nineQMarks,  tenQMarks,  elevenQMarks, twelve = 0.00;
			            				            				            	
	    					int update =ExternalMarksRepository.updatemarks(request.getFirstQMarks(),request.getSecondQMarks(),request.getThirdQMarks(),request.getFourQMarks(),request.getFiveQMarks(),request.getSixQMarks(),request.getSevenQMarks(),request.getEightQMarks(),request.getNineQMarks(),request.getTenQMarks(),request.getElevenQMarks(),request.getTwelveQMarks(),request.getBarcode(),Staffpersonal.get(),staffdetail.get(0),request.getThirteenQMarks(),request.getFourteenQMarks(),request.getFifteenQMarks(),request.getSixteenQMarks(),request.getSeventeenQMarks(),request.getEighteenQMarks(),request.getNinteenQMarks(),request.getTwentyQMarks(),request.getTwentyoneQMarks(),request.getTwentytwoQMarks(),request.getTwentythreeQMarks(),request.getTwentyfourQMarks(),request.getTwentyfiveQMarks(),request.getTwentysixQMarks(),request.getTwentysevenQMarks(),request.getTwentyeightQMarks(),request.getTwentynineQMarks(),request.getThirtyQMarks(),request.getThirtyoneQMarks(),request.getThirtytwoQMarks(),request.getThirtythreeQMarks(),request.getThirtyfourQMarks(),request.getThirtyfiveQMarks(),request.getThirtysixQMarks(),request.getThirtysevenQMarks(),request.getThirtyeightQMarks(),request.getThirtynineQMarks(),request.getFortyQMarks());
	    					if(update==1) {
	    						ExamBarcodes.updeteMarks(getTotalNumber(request.getStaffid(), request.getBarcode() , request) , request.getStaffid() , request.getBarcode());
	    						info.put("status", "1");
	    						info.put("message", "Marks sumbited successfully");	
	    						return info;	
	    					}
	    					info.put("status", "1");
	         				info.put("message", "Marks not sumbited successfully");	
	         				return info;
			            }
			        
        		  }		
        			
         }
        	    info.put("status", "2");
				info.put("message", "Please provide proper methodtype");	
				return info;      
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}
	
	private Double getTotalNumber(Long longstaff, String barcode, EvaluationDetailsRequest request) {
		 List<ExternalMarks> testres =ExternalMarksRepository.findByExpertIdAndExBarcode(longstaff, barcode);
		    if(testres.size() <=0) {
		    	return 0.0;
		    }
		    double totalmarks = 0.0; 						
			   ArrayList<Double> arraylist = new ArrayList<Double>();
			   arraylist.add(testres.get(0).getTwentysixQMarks() == null ?0.0 :testres.get(0).getTwentysixQMarks());
			   arraylist.add(testres.get(0).getTwentysevenQMarks() == null ?0.0 :testres.get(0).getTwentysevenQMarks());
			   arraylist.add(testres.get(0).getTwentyeightQMarks() == null ?0.0 :testres.get(0).getTwentyeightQMarks());
			   arraylist.add(testres.get(0).getTwentynineQMarks() == null ?0.0 :testres.get(0).getTwentynineQMarks());	    						   
			   arraylist.add(testres.get(0).getThirtyQMarks() == null ?0.0 :testres.get(0).getThirtyQMarks());
			   arraylist.add(testres.get(0).getThirtyoneQMarks() == null ?0.0 :testres.get(0).getThirtyoneQMarks());	    						   
			   arraylist.add(testres.get(0).getThirtytwoQMarks() == null ?0.0 :testres.get(0).getThirtytwoQMarks());
			   arraylist.add(testres.get(0).getThirtythreeQMarks() == null ?0.0 :testres.get(0).getThirtythreeQMarks());
			   arraylist.add(testres.get(0).getThirtyfourQMarks() == null ?0.0 :testres.get(0).getThirtyfourQMarks());
			   arraylist.add(testres.get(0).getThirtyfiveQMarks() == null ?0.0 :testres.get(0).getThirtyfiveQMarks());
			   Collections.sort(arraylist ,  Collections.reverseOrder());
			   for(int i =0 ;i <8 ;i++) {
				   totalmarks = totalmarks+arraylist.get(i);
			   }
			
			   ArrayList<Double> arraylist1 = new ArrayList<Double>();
			   arraylist1.add(testres.get(0).getThirtysixQMarks() == null ?0.0 :testres.get(0).getThirtysixQMarks());
			   arraylist1.add(testres.get(0).getThirtysevenQMarks() == null ?0.0 :testres.get(0).getThirtysevenQMarks());
			   arraylist1.add(testres.get(0).getThirtyeightQMarks() == null ?0.0 :testres.get(0).getThirtyeightQMarks());
			   arraylist1.add(testres.get(0).getThirtynineQMarks() == null ?0.0 :testres.get(0).getThirtynineQMarks());	    						   
			   arraylist1.add(testres.get(0).getFortyQMarks() == null ?0.0 :testres.get(0).getFortyQMarks());
			
			   Collections.sort(arraylist1 ,  Collections.reverseOrder());
			   for(int i =0 ;i <3 ;i++) {
				   totalmarks = totalmarks+arraylist1.get(i);
			   }
			   totalmarks = totalmarks+(request.getFirstQMarks() == null ?0.0:request.getFirstQMarks());
			   totalmarks = totalmarks+(request.getSecondQMarks() == null ?0.0:request.getSecondQMarks());
			   totalmarks = totalmarks+(request.getThirdQMarks() == null ?0.0:request.getThirdQMarks());
			   totalmarks = totalmarks+(request.getFourQMarks() == null ?0.0:request.getFourQMarks());
			   totalmarks = totalmarks+(request.getFiveQMarks() == null ?0.0:request.getFiveQMarks());
			   totalmarks = totalmarks+(request.getSixQMarks() == null ?0.0:request.getSixQMarks());
			   totalmarks = totalmarks+(request.getSevenQMarks() == null ?0.0:request.getSevenQMarks());
			   totalmarks = totalmarks+(request.getEightQMarks() == null ?0.0:request.getEightQMarks());
			   
			   totalmarks = totalmarks+(request.getNineQMarks() == null ?0.0:request.getNineQMarks());
			   totalmarks = totalmarks+(request.getTenQMarks() == null ?0.0:request.getTenQMarks());
			   totalmarks = totalmarks+(request.getElevenQMarks() == null ?0.0:request.getElevenQMarks());
			   totalmarks = totalmarks+(request.getTwelveQMarks() == null ?0.0:request.getTwelveQMarks());
			   totalmarks = totalmarks+(request.getThirteenQMarks() == null ?0.0:request.getThirteenQMarks());
			   totalmarks = totalmarks+(request.getFourteenQMarks() == null ?0.0:request.getFourteenQMarks());
			   totalmarks = totalmarks+(request.getFifteenQMarks() == null ?0.0:request.getFifteenQMarks());
			   totalmarks = totalmarks+(request.getSixteenQMarks() == null ?0.0:request.getSixteenQMarks());
			   
			   totalmarks = totalmarks+(request.getSeventeenQMarks() == null ?0.0:request.getSeventeenQMarks());
			   totalmarks = totalmarks+(request.getEighteenQMarks() == null ?0.0:request.getEighteenQMarks());
			   totalmarks = totalmarks+(request.getNinteenQMarks() == null ?0.0:request.getNinteenQMarks());
			   totalmarks = totalmarks+(request.getTwentyQMarks() == null ?0.0:request.getTwentyQMarks());
			   totalmarks = totalmarks+(request.getTwentyoneQMarks() == null ?0.0:request.getTwentyoneQMarks());
			   totalmarks = totalmarks+(request.getTwentytwoQMarks() == null ?0.0:request.getTwentytwoQMarks());
			   totalmarks = totalmarks+(request.getTwentythreeQMarks() == null ?0.0:request.getTwentythreeQMarks());
			   
			   totalmarks = totalmarks+(request.getTwentyfourQMarks() == null ?0.0:request.getTwentyfourQMarks());
			   totalmarks = totalmarks+(request.getTwentyfiveQMarks() == null ?0.0:request.getTwentyfiveQMarks());
			  
			   return totalmarks;
		
	}

	private Boolean savemarks(String barcode, EvaluatorList staffpersonal, ExamBarcodes omrMarks, Double firstQMarks,
			Double secondQMarks, Double thirdQMarks, Double fourQMarks, Double fiveQMarks, Double sixQMarks,
			Double sevenQMarks, Double eightQMarks, Double nineQMarks, Double tenQMarks, Double elevenQMarks,
			Double twelve ,Double thirteenQMarks, Double fourteenQMarks, Double fifteenQMarks, Double sixteenQMarks,
			Double seventeenQMarks, Double eighteenQMarks, Double ninteenQMarks, Double twentyQMarks,
			Double twentyoneQMarks, Double twentytwoQMarks, Double twentythreeQMarks, Double twentyfourQMarks,
			Double twentyfiveQMarks, Double twentysixQMarks, Double twentysevenQMarks, Double twentyeightQMarks,
			Double twentynineQMarks, Double thirtyQMarks, Double thirtyoneQMarks, Double thirtytwoQMarks,
			Double thirtythreeQMarks, Double thirtyfourQMarks, Double thirtyfiveQMarks, Double thirtysixQMarks,
			Double thirtysevenQMarks, Double thirtyeightQMarks, Double thirtynineQMarks, Double fortyQMarks)  {

		try {					
			ExternalMarks ExternalMarks= new ExternalMarks();
			ExternalMarks.setExBarcode(barcode);    				
			ExternalMarks.setExpert(staffpersonal);
			ExternalMarks.setExambarcode(omrMarks);
			
			ExternalMarks.setFirstQMarks(firstQMarks == null ?0.0:firstQMarks);
			ExternalMarks.setSecondQMarks(secondQMarks== null ?0.0:secondQMarks);
			ExternalMarks.setThirdQMarks(thirdQMarks== null ?0.0:thirdQMarks);
			ExternalMarks.setFourQMarks(fourQMarks== null ?0.0:fourQMarks);
			ExternalMarks.setFiveQMarks(fiveQMarks== null ?0.0:fiveQMarks);   					
			ExternalMarks.setSixQMarks(sixQMarks== null ?0.0:sixQMarks);
			ExternalMarks.setSevenQMarks(sevenQMarks== null ?0.0:sevenQMarks);
			ExternalMarks.setEightQMarks(eightQMarks== null ?0.0:eightQMarks);
			ExternalMarks.setNineQMarks(nineQMarks== null ?0.0:nineQMarks);
			ExternalMarks.setTenQMarks(tenQMarks== null ?0.0:tenQMarks);
			ExternalMarks.setElevenQMarks(elevenQMarks== null ?0.0:elevenQMarks);
			ExternalMarks.setTwelveQMarks(twelve== null ?0.0:twelve);
			ExternalMarks.setThirteenQMarks(thirteenQMarks== null ?0.0:thirteenQMarks);
			ExternalMarks.setFourteenQMarks(fourteenQMarks== null ?0.0:fourteenQMarks);
			ExternalMarks.setFifteenQMarks(fifteenQMarks== null ?0.0:fifteenQMarks);
			ExternalMarks.setSixteenQMarks(sixteenQMarks== null ?0.0:sixteenQMarks);
			ExternalMarks.setSeventeenQMarks(seventeenQMarks== null ?0.0:seventeenQMarks);
			ExternalMarks.setEighteenQMarks(eighteenQMarks== null ?0.0:eighteenQMarks);
			ExternalMarks.setNinteenQMarks(ninteenQMarks== null ?0.0:ninteenQMarks);
			ExternalMarks.setTwentyQMarks(twentyQMarks== null ?0.0:twentyQMarks);
			ExternalMarks.setTwentyoneQMarks(twentyoneQMarks== null ?0.0:twentyoneQMarks);
			ExternalMarks.setTwentytwoQMarks(twentytwoQMarks== null ?0.0:twentytwoQMarks);
			ExternalMarks.setTwentythreeQMarks(twentythreeQMarks== null ?0.0:twentythreeQMarks);
			ExternalMarks.setTwentyfourQMarks(twentyfourQMarks== null ?0.0:twentyfourQMarks);
			ExternalMarks.setTwentyfiveQMarks(twentyfiveQMarks== null ?0.0:twentyfiveQMarks);
			ExternalMarks.setTwentysixQMarks(twentysixQMarks== null ?0.0:twentysixQMarks);
			ExternalMarks.setTwentysevenQMarks(twentysevenQMarks== null ?0.0:twentysevenQMarks);
			ExternalMarks.setTwentyeightQMarks(twentyeightQMarks== null ?0.0:twentyeightQMarks);
			ExternalMarks.setTwentynineQMarks(twentynineQMarks== null ?0.0:twentynineQMarks);
			ExternalMarks.setThirtyQMarks(thirtyQMarks== null ?0.0:thirtyQMarks);
			ExternalMarks.setThirtyoneQMarks(thirtyoneQMarks== null ?0.0:thirtyoneQMarks);
			ExternalMarks.setThirtytwoQMarks(thirtytwoQMarks== null ?0.0:thirtytwoQMarks);
			ExternalMarks.setThirtythreeQMarks(thirtythreeQMarks== null ?0.0:thirtythreeQMarks);
			ExternalMarks.setThirtyfourQMarks(thirtyfourQMarks== null ?0.0:thirtyfourQMarks);
			ExternalMarks.setThirtyfiveQMarks(thirtyfiveQMarks== null ?0.0:thirtyfiveQMarks);
			ExternalMarks.setThirtysixQMarks(thirtysixQMarks== null ?0.0:thirtysixQMarks);
			ExternalMarks.setThirtysevenQMarks(thirtysevenQMarks== null ?0.0:thirtysevenQMarks);
			ExternalMarks.setThirtyeightQMarks(thirtyeightQMarks== null ?0.0:thirtyeightQMarks);
			ExternalMarks.setThirtynineQMarks(thirtynineQMarks== null ?0.0:thirtynineQMarks);
			ExternalMarks.setFortyQMarks(fortyQMarks== null ?0.0:fortyQMarks);
			
			ExternalMarksRepository.save(ExternalMarks);
			return true;

		}catch(Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
		}
		return false;
	}

	private String EvaluatedpathFolder(String academicyear, String foldername,
			String collegename, String program ,String courses, String barcode, String answersheet) {

			try {		
				String UPLOADED_FOLDER = commonHelper.getSettingValue("DOCUMENT_PATH");						
				File file2 = new File(UPLOADED_FOLDER+"/"+academicyear);			
				if (file2.mkdir()) {
		            file2.setExecutable(true , false); 
		            file2.setReadable(true , false); 
		            file2.setWritable(true , false); 
					
				}
				String academic= file2.getPath();			
				File file3 = new File(academic+"/"+foldername);
				if (file3.mkdir()) {	
		            file3.setExecutable(true , false); 
		            file3.setReadable(true , false); 
		            file3.setWritable(true , false); 
				}
				String folder= file3.getPath();	
				File file4 = new File(folder+"/"+collegename);	
				if (file4.mkdir()) {
		            file4.setExecutable(true , false); 
		            file4.setReadable(true , false); 
		            file4.setWritable(true , false); 
				}	
				
				String col= file4.getPath();	
				File file5 = new File(col+"/"+program);	
				if (file5.mkdir()) {
					file5.setExecutable(true , false); 
					file5.setReadable(true , false); 
					file5.setWritable(true , false); 
				}	
				
				
				String pro= file5.getPath();	
				File file6 = new File(pro+"/"+courses);	
				if (file6.mkdir()) {
					file6.setExecutable(true , false); 
					file6.setReadable(true , false); 
					file6.setWritable(true , false); 
				}	
				
				
				
				String cour= file6.getPath();	
				File file7 = new File(cour+"/"+barcode);	
				if (file7.mkdir()) {
					file7.setExecutable(true , false); 
					file7.setReadable(true , false); 
					file7.setWritable(true , false); 
				}	

				String barcodes= file7.getPath();	
				File file8 = new File(barcodes+"/"+answersheet);	
				if (file8.mkdir()) {
					file8.setExecutable(true , false); 
					file8.setReadable(true , false); 
					file8.setWritable(true , false); 
				}	
				
				
				
				return UPLOADED_FOLDER+academicyear+"/"+foldername+"/"+collegename+"/"+program+"/"+courses+"/"+barcode+"/"+answersheet+"/";
			}catch(Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
			}
			return "NA";
		}

	@Override
	public Map<String, Object> getsavedEvaluatedMark(EvaluationDetailsRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
														
			if (request.getBarcode() == null || request.getBarcode().equals("")) {
				info.put("status", "2");
				info.put("message", "Barcode is required");
				return info;
			}			
			if (request.getStaffid() == null || request.getStaffid().equals("")) {
				info.put("status", "2");
				info.put("message", "staffid is required");
				return info;
			}			
			Optional<EvaluatorList> staffid = super.expertlist.findById(request.getStaffid());
			if (!staffid.isPresent()) {
				info.put("status", "2");
				info.put("message", "staff not present");
				return info;
			}	
			
            
			 //Pendingbarcodedetails
			Date date=new Date();
			int isnotevaluated=0;
			List<ExamBarcodes>  recordlist= ExamBarcodes.findByExpertIdAndExBarcode(request.getStaffid(), request.getBarcode());
			if (recordlist.size() <= 0) {
				info.put("status", "2");
				info.put("message", "staff is not allocated to particular barcode");
				return info;
		     } 
			List<ExternalMarks> list= ExternalMarksRepository.findByExpertIdAndExBarcode(request.getStaffid(), request.getBarcode());
			if (list.size() <= 0) {
				info.put("status", "2");
				info.put("message", "barcode not evaluated yet");
				return info;
		      }
			String serverurl = commonHelper.getSettingValue("SERVER_IP");
			 List<Double> marks = new ArrayList<Double>();
				List dataList = new LinkedList();			      

			int isevaluated=1;
			if (list.get(0).getExambarcode().getExIsEvaluated()==isevaluated) {
				info.put("status", "2");
				info.put("message", "barcode already evaluated");
				return info;
		     } 
			else {
				info.put("status", "1");
				info.put("message", "success");	
				info.put("barcode", list.get(0).getExBarcode());
				info.put("exIsEvaluated",list.get(0).getExambarcode().getExIsEvaluated());	
				info.put("evaluatedPath",  (list.get(0).getExambarcode().getExEvaluatedPath() == null || list.get(0).getExambarcode().getExEvaluatedPath().equals("NA"))?"NA" :serverurl+list.get(0).getExambarcode().getExEvaluatedPath());			
				
				info.put("firstQMarks",list.get(0).getFirstQMarks() == null ?0.0:list.get(0).getFirstQMarks());
				info.put("secondQMarks",list.get(0).getSecondQMarks() == null ?0.0:list.get(0).getSecondQMarks());
				info.put("thirdQMarks",list.get(0).getThirdQMarks() == null ?0.0:list.get(0).getThirdQMarks());
				info.put("fourQMarks",list.get(0).getFourQMarks() == null ?0.0:list.get(0).getFourQMarks());
				info.put("fiveQMarks",list.get(0).getFiveQMarks() == null ?0.0:list.get(0).getFiveQMarks());
				info.put("sixQMarks",list.get(0).getSixQMarks() == null ?0.0:list.get(0).getSixQMarks());
				info.put("sevenQMarks",list.get(0).getSevenQMarks() == null ?0.0:list.get(0).getSevenQMarks() );
				info.put("eightQMarks",list.get(0).getEightQMarks() == null ?0.0:list.get(0).getEightQMarks());
				info.put("nineQMarks",list.get(0).getNineQMarks() == null ?0.0:list.get(0).getNineQMarks());
				info.put("tenQMarks",list.get(0).getTenQMarks() == null ?0.0:list.get(0).getTenQMarks());
				info.put("elevenQMarks",list.get(0).getElevenQMarks() == null ?0.0:list.get(0).getElevenQMarks());
				
				info.put("twelveQMarks",list.get(0).getTwelveQMarks() == null ?0.0:list.get(0).getTwelveQMarks());
				info.put("thirteenQMarks",list.get(0).getThirteenQMarks() == null ?0.0:list.get(0).getThirteenQMarks() );
				info.put("fourteenQMarks",list.get(0).getFourteenQMarks() == null ?0.0:list.get(0).getFourteenQMarks());	
				info.put("fifteenQMarks",list.get(0).getFifteenQMarks() == null ?0.0:list.get(0).getFifteenQMarks());	
				info.put("sixteenQMarks",list.get(0).getSixteenQMarks() == null ?0.0:list.get(0).getSixteenQMarks());	
				info.put("seventeenQMarks",list.get(0).getSeventeenQMarks() == null ?0.0:list.get(0).getSeventeenQMarks());	
				info.put("eighteenQMarks",list.get(0).getEighteenQMarks() == null ?0.0:list.get(0).getEighteenQMarks() );	
				info.put("ninteenQMarks",list.get(0).getNinteenQMarks() == null ?0.0:list.get(0).getNinteenQMarks());	
				info.put("twentyQMarks",list.get(0).getTwentyQMarks() == null ?0.0:list.get(0).getTwentyQMarks() );	
				info.put("twentyOneQMarks",list.get(0).getTwentyoneQMarks() == null ?0.0:list.get(0).getTwentyoneQMarks());	
				info.put("twentyTwoQMarks",list.get(0).getTwentytwoQMarks() == null ?0.0:list.get(0).getTwentytwoQMarks() );	
				
				info.put("twentyThreeQMarks",list.get(0).getTwentythreeQMarks() == null ?0.0:list.get(0).getTwentythreeQMarks());	
				info.put("twentyFourQMarks",list.get(0).getTwentyfourQMarks() == null ?0.0:list.get(0).getTwentyfourQMarks());	
				info.put("twentyFiveQMarks",list.get(0).getTwentyfiveQMarks() == null ?0.0:list.get(0).getTwentyfiveQMarks());	
				info.put("twentySixQMarks",list.get(0).getTwentysixQMarks() == null ?0.0:list.get(0).getTwentysixQMarks());	
				info.put("twentySevenQMarks",list.get(0).getTwentysevenQMarks() == null ?0.0:list.get(0).getTwentysevenQMarks());	
				info.put("twentyEightQMarks",list.get(0).getTwentyeightQMarks() == null ?0.0:list.get(0).getTwentyeightQMarks());	
				info.put("twentyNineQMarks",list.get(0).getTwentynineQMarks() == null ?0.0:list.get(0).getTwentynineQMarks());	
				info.put("thirtyQMarks",list.get(0).getThirtyQMarks() == null ?0.0:list.get(0).getThirtyQMarks());	
				info.put("thirtyOneQMarks",list.get(0).getThirtyoneQMarks() == null ?0.0:list.get(0).getThirtyoneQMarks());	
				info.put("thirtyTwoQMarks",list.get(0).getThirtytwoQMarks() == null ?0.0:list.get(0).getThirtytwoQMarks());	
				info.put("thirtyThreeQMarks",list.get(0).getThirtythreeQMarks() == null ?0.0:list.get(0).getThirtythreeQMarks());	
				
				info.put("thirtyFourQMarks",list.get(0).getThirtyfourQMarks() == null ?0.0:list.get(0).getThirtyfourQMarks());	
				info.put("thirtyFiveQMarks",list.get(0).getThirtyfiveQMarks() == null ?0.0:list.get(0).getThirtyfiveQMarks());	
				info.put("thirtySixQMarks",list.get(0).getThirtysixQMarks() == null ?0.0:list.get(0).getThirtysixQMarks());	
				info.put("thirtySevenQMarks",list.get(0).getThirtysevenQMarks() == null ?0.0:list.get(0).getThirtysevenQMarks());	
				info.put("thirtyEightQMarks",list.get(0).getThirtyeightQMarks() == null ?0.0:list.get(0).getThirtyeightQMarks());	
				info.put("thirtyNineQMarks",list.get(0).getThirtynineQMarks() == null ?0.0:list.get(0).getThirtynineQMarks());	
				info.put("fortyQMarks",list.get(0).getFortyQMarks() == null ?0.0:list.get(0).getFortyQMarks());	
				
				return info;			  
			}	   
		        

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getBarcodeDetailsOnEvaluator(EvaluationDetailsRequest barcodeRequest) {
		Map<String, Object> info = new LinkedHashMap<>();			
		 try {			 
			 
				Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false,true, barcodeRequest.getAcademicYear());
				if (!academicYearid.isPresent()) {
					info.put("status", "2");
					info.put("message", "AcademicYear id not present");
					return info;
				}
											 
				 List<RegistrationType> registration = super.registrationType.findByIdAndExIsDelete(barcodeRequest.getRegistrationType(), false);
					if (registration.size() <= 0) {
						info.put("status", "2");
						info.put("message", "RegistrationType id not present");
						return info;
					}
				
				Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,barcodeRequest.getProgrammes());
				if (!Prog.isPresent()) {
					info.put("status", "2");
					info.put("message", " Programe not present");
					return info;
				}
							
				Optional<ExamAnnouncement> ExamAnnouncement = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false ,true ,barcodeRequest.getExamAnnouncement());
		        if(!ExamAnnouncement.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncementId not present");
				return info;
			   }
		       Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(barcodeRequest.getCourse(),false, true);
				if (!courses.isPresent()) {
						info.put("status", "2");
						info.put("message", "courses not present");
						return info;
				} 
				Optional<EvaluatorList> Staffpersonal = super.expertlist.findById(barcodeRequest.getStaffid());
				if (!Staffpersonal.isPresent()) {
					info.put("status", "2");
					info.put("message", "Staff not present");
					return info;
				}	
				Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true,barcodeRequest.getDegree());
				if (!degree.isPresent() || !degree.get().getExIsActive()) {
					info.put("status", "2");
					info.put("message", "Degree not present");
					return info;
				}
				Optional<Semster> sem = super.semester.findByIdAndExIsActiveAndExIsDelete(barcodeRequest.getSemester() ,true ,false);
				if (!sem.isPresent()){
					info.put("status", "2");
					info.put("message", "Semster not present");
					return info;
				}
				Optional<ProgrammeYear> programyear = super.programmeYear.findByExIsDeleteAndExIsActiveAndId(false,true, barcodeRequest.getProgrammeYear());
				if (!programyear.isPresent()) {
					info.put("status", "2");
					info.put("message", "ProgrammeYear not present");
					return info;
				} 
				List<ExamBarcodes>  recordlist = ExamBarcodes.findByExIsAttendanceAndAcademicYearIdAndProgrammesIdAndExamAnnouncementIdAndCoursesIdAndDegreeIdAndSemesterIdAndProgrammeYearIdAndExpertIdAndRegistrationTypeId(true,barcodeRequest.getAcademicYear(),barcodeRequest.getProgrammes(),barcodeRequest.getExamAnnouncement(),barcodeRequest.getCourse(),barcodeRequest.getDegree(),barcodeRequest.getSemester(),barcodeRequest.getProgrammeYear(),barcodeRequest.getStaffid(),barcodeRequest.getRegistrationType());
					if (recordlist.size()<=0) {				
					info.put("status", "2");
					info.put("messagsse", "Record not found");
					return info;
				}		
					String serverurl = commonHelper.getSettingValue("SERVER_IP");
					int isEvaluated =0;
					int savedisEvaluated =2;
					List dataList = new LinkedList();	
					for(ExamBarcodes r :recordlist){
						Map<Object, Object> list = new HashMap<Object, Object>();	
						if(r.getExIsEvaluated() ==null || r.getExIsEvaluated() ==isEvaluated || r.getExIsEvaluated() ==savedisEvaluated){										
						list.put("barcode", r.getExBarcode());
						list.put("path",(r.getExAnsBookletPath() == null || r.getExAnsBookletPath().equals("NA"))?"NA" :serverurl+r.getExAnsBookletPath());															
						list.put("exEvaluatedPath",(r.getExEvaluatedPath() == null || r.getExEvaluatedPath().equals("NA"))?"NA" :serverurl+r.getExEvaluatedPath());
						list.put("id", r.getId());	
						list.put("exIsEvaluated", r.getExIsEvaluated());	
						dataList.add(list);	
						}	
						
				}					
					if(dataList.size() <=0) {
						info.put("status", "2");
						info.put("messagsse", "No pending Barcode list");
						info.put("pendingcount",dataList.size());
						info.put("evaluatedcount",recordlist.size()-dataList.size());
						info.put("totalcount",recordlist.size());
						info.put("barcodelist",dataList.size()<=0?"No pending Barcode list":dataList);
						return info;	
					}else {
						info.put("status", "1");
						info.put("messagsse", "success");
						info.put("pendingcount",dataList.size());
						info.put("evaluatedcount",recordlist.size()-dataList.size());
						info.put("totalcount",recordlist.size());
						info.put("barcodelist",dataList.size()<=0?"No pending Barcode list":dataList);
						return info;	
					}
										
		 }catch(Exception e) {
			 e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
		 }
		
	}

	@Override
	public Map<String, Object> getStaffOnAllocatedBooklet(EvaluationDetailsRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
			
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false,true, request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			
			  Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true,request.getDegree());
				if (!degree.isPresent() || !degree.get().getExIsActive()) {
					info.put("status", "2");
					info.put("message", "Degree not present");
					return info;
				}
			
			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", " Programe not present");
				return info;
			}
						
			Optional<ExamAnnouncement> ExamAnnouncement = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false ,true ,request.getExamAnnouncement());
            if(!ExamAnnouncement.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncementId not present");
			return info;
		   }
            Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourse(),	false, true);
			 if (!courses.isPresent()) {
					info.put("status", "2");
					info.put("message", "courses not present");
					return info;
			}
			List<RegistrationType> registration = super.registrationType.findByIdAndExIsDelete(request.getRegistrationType(), false);
				if (registration.size() <= 0) {
					info.put("status", "2");
					info.put("message", "RegistrationType id not present");
					return info;
				}
			 //EvaluationDetailsResponse
			 
        	List dataList = new LinkedList();	
        	
        	ArrayList<Object[]> stafflist = super.evaluationDetails.stafflist(request.getExamAnnouncement(), request.getAcademicYear(), request.getCourse() ,  request.getDegree() , request.getProgrammes(), request.getRegistrationType(),false);
        	if(stafflist.size()<=0) {
        		info.put("status", "2");
				info.put("message", "Record not found");
				return info;
        	}	        	
        	for (Object[] e : stafflist) {       		
				Map<Object, Object> staffinfo = new HashMap<Object, Object>();
				staffinfo.put("first_name", e[0]);
				staffinfo.put("employee_id", e[1]);
				staffinfo.put("mobile", e[2]);
				staffinfo.put("staffid", e[3]);				
				//staffinfo.put("stafftypeid", e[4]);
				//staffinfo.put("stafftype", e[5]);			
				dataList.add(staffinfo);
			}

				info.put("status", "1");
				info.put("message", "success");	
				info.put("staffdetails", dataList);
				return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getPhotocopyDetails(PhotoCopyRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			logger.info("Inside generate Semester Progress Report > " + request);
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ProgrammeYear> programyear = super.programmeYear.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!programyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}
			List<ExamBarcodes> ormmarks = super.exambarcode.getListForPhotoCopy(request.getAcademicYear() , request.getDegree() , request.getProgrammes() ,request.getCourses() , request.getProgrammeYear() , request.getSemester());	
			if(ormmarks.size() <=0) {
				info.put("status", "2");
				info.put("message", "Student not registered for photocopy");
				return info;
			}
			String serverurl = commonHelper.getSettingValue("SERVER_IP");
			String localurl = commonHelper.getSettingValue("DOCUMENT_PATH");
			List dataList = new LinkedList();		
			for(ExamBarcodes e :ormmarks) {
				Map<Object, Object> staffinfo = new HashMap<Object, Object>();			
				staffinfo.put("barcode", e.getExBarcode());
				staffinfo.put("exRollNo", e.getExRollNo());
				staffinfo.put("exStudentName", e.getStudentadmission().getExName());
               
				staffinfo.put("ansBookletPath", (e.getExAnsBookletPath() == null || e.getExAnsBookletPath().equals("NA"))?"NA" :serverurl+e.getExAnsBookletPath());															
				staffinfo.put("evaluatedPath",  (e.getExEvaluatedPath() == null || e.getExEvaluatedPath().equals("NA"))?"NA" :serverurl+e.getExEvaluatedPath());
				//staffinfo.put("timeTaken", e.getExTimeTaken());	
				staffinfo.put("exIsEvaluated", e.getExIsEvaluated());	
				
				staffinfo.put("exCoursesCode", e.getCourses().getExCoursesCode());
				staffinfo.put("exCoursesName", e.getCourses().getExName());
				staffinfo.put("exCreditHourTitle", e.getCourses().getCreditHours().getExCreditHourTitle());
				//staffinfo.put("exCreditHourId", e.getCourses().getId());
				dataList.add(staffinfo); 
							
			}			
			info.put("details", dataList);
			info.put("status", "1");
			info.put("message", "success");
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> sendPhotocopy(PhotoCopyRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();	
		try {			
			
			
			  List<ExamBarcodes> ormmarks =super.exambarcode.findByExIsActiveAndExIsDeleteAndExRollNoAndExBarcode(true,false ,request.getExRollNo(),request.getBarcode()); 
			  if(ormmarks.size() <=0) {
				  info.put("status", "2");
			  info.put("message", "Barcode not present for selected student.");
			  return info; } 
			  // get the student details			  
				List<Studentpersonal> task = super.studentpersonal.findByStudentadmissionExIsActiveAndStudentadmissionId(true,ormmarks.get(0).getStudentadmission().getId());
				
				  if (task.size() <= 0) {
					  info.put("status", "2");
					  info.put("message","Student not Present"); 
					  return info; 
					  }
			  
			  String photocopy = ormmarks.get(0).getExAnsBookletPath();
			  photocopy = photocopy+"VerifiedAnswerSheet";	
			  String localurl = commonHelper.getSettingValue("DOCUMENT_PATH");
			  File tempFile = new File(localurl+photocopy);
				if(!tempFile.exists()) {
					info.put("status", "2");
					info.put("message", "Certificates Not Present");
					return info;
				}
			  		String destipath = photocopy+".zip";
				zipFolder(Paths.get(localurl+photocopy) , Paths.get(localurl+destipath));	
				 File destifile = new File(localurl+destipath);
				 
				 Path path = Paths.get(localurl+destipath);
				 byte[] content = Files.readAllBytes(path);		
				String messagebody = "<body> Hi "+ormmarks.get(0).getStudentadmission().getExName()+", <br><br> <p> As per the registration done for the course  <b>'"+ormmarks.get(0).getCourses().getExName()+"'</b>  Applied photocopy. </p> <br><p>Here is the attached Evaluated answer script of the respective course. </p>  <br><br><br>  <p> Thanks,</p><p> Team Exam360</p></body>";
				 
			boolean check  = emailSending.sendPhotocopyMail(task.get(0).getExEmailId() ,messagebody ,"Evluated answer script" , destifile);
					if(check) {
						info.put("status", "1");
						info.put("message", "Photocopy has been sent to register email.");
						return info;
					}	else {
						info.put("status", "1");
						info.put("message", "Email not sent to registered mail.");
						return info;
					}	
			
		
	
		}catch(Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Couldn't connect to host, please try after some time");
			return info;
    	}
	}
	private void zipFolder(Path sourceFolderPath, Path zipPath) throws Exception {
		ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipPath.toFile()));
		Files.walkFileTree(sourceFolderPath, new SimpleFileVisitor<Path>() {
			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
				zos.putNextEntry(new ZipEntry(sourceFolderPath.relativize(file).toString()));
				Files.copy(file, zos);
				zos.closeEntry();
				return FileVisitResult.CONTINUE;
			}
		});
		zos.close();
	}

	@Override
	public Map<String, Object> updateEvaluatorSelection(EvaluatorSelectionRequest request) {
		// TODO Auto-generated method stub
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<EvaluatorList> expertid = super.expertlist.findByIdAndExIsDeleteAndExIsActive(request.getEvaluatorId(),false,true);
			if (!expertid.isPresent()) {
				info.put("status", "2");
				info.put("message", "evaluatorid not present");
				return info;
			}		
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement.findByExIsDeleteAndExIsActiveAndId(false, true,request.getExamAnnouncement());
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "Examannouncement  not present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			
			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			
			Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(), false,true);
			if (!courses.isPresent()) {
				info.put("status", "2");
				info.put("message", "courses not  present");
				return info;

			}
			List<RegistrationType> registration = super.registrationType.findByIdAndExIsDeleteAndExIsActive(request.getRegistrationType(), false, true);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType not present");
				return info;
			}
			
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			  List<EvaluationType> evaluation = super.evaluationType.findByIdAndExIsDelete(request.getEvaluationType(), false);		
				if (evaluation.size() <= 0) {
					info.put("status", "2");
					info.put("message", "EvaluationType id not present");
					return info;
				}	
			User userresult = null;
			if (request.getUser() == null || request.getUser().equals("")) {
				userresult = null;
			} else {
				List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
				userresult = user.get(0);
			}


			Date date = new Date();
			SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");
			SimpleDateFormat time = new SimpleDateFormat("HH:MM");		
			EvaluatorSelection.updateEvaluatorSelection(date, time.parse(request.getExEvaluationTime()), date1.parse(request.getExEvaluationFrom() + " 00:00:00"), date1.parse(request.getExEvaluationTo() + " 23:59:00"), request.getExEvaluationVenue(), request.getAcademicYear(), request.getExamAnnouncement(), request.getEvaluatorId(), request.getCourses(), request.getProgrammes(), request.getDegree(), request.getRegistrationType(), request.getId());
		
			info.put("status", "1");
			info.put("message", "Evaluator updated successfully");
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getEvaluator(EvaluatorSelectionRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {											
			List<EvaluatorSelection> task = super.EvaluatorSelection.findByExIsActiveAndExIsDelete(true , false);		
			if(task.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No records found");
				return info;
			}									
			List dataList = new LinkedList();
			for (EvaluatorSelection e : task) {
				Map<Object, Object> evaluator = new HashMap<Object, Object>();
				evaluator.put("id", e.getId());
				evaluator.put("exEvaluationTime", e.getExEvaluationTime().toString().substring(0, 5));
				evaluator.put("exEvaluationFrom", e.getExEvaluationFrom().toString().substring(0, 10));
				
				evaluator.put("exEvaluationTo", e.getExEvaluationTo().toString().substring(0, 10));
				evaluator.put("exEvaluationVenue", e.getExEvaluationVenue());
				
				evaluator.put("examAnnouncement", e.getExamAnnouncement().getExName());
				evaluator.put("examAnnouncementId", e.getExamAnnouncement().getId());	
				
				evaluator.put("registrationType", e.getRegistrationType().getExName());
				evaluator.put("registrationTypeId", e.getRegistrationType().getId());
				
				evaluator.put("evaluationType", e.getEvaluation().getExName());
				evaluator.put("evaluationTypeId", e.getEvaluation().getId());	
												
				evaluator.put("courses",e.getCourses().getExName());
				evaluator.put("coursesId",e.getCourses().getId());				
				evaluator.put("courseCode", e.getCourses().getExCoursesCode());

				
				evaluator.put("academicYear", e.getAcademicYear().getExYear());
				evaluator.put("academicYearId", e.getAcademicYear().getId());	
				
				evaluator.put("collegesId", e.getColleges().getId());
				evaluator.put("colleges", e.getColleges().getExName());
				
				evaluator.put("degreeId", e.getDegree().getId());
				evaluator.put("degree", e.getDegree().getExName());
				
				evaluator.put("programmesId", e.getProgrammes().getId());
				evaluator.put("programmes", e.getProgrammes().getExName());	
				evaluator.put("evaluatorId", e.getExpert().getId());	
				evaluator.put("evaluator", e.getExpert().getExName());	
				
				dataList.add(evaluator);
			}
			info.put("status", "1");
			info.put("message", "success");
			info.put("details", dataList);
				return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> deleteEvaluatorSelection(EvaluatorSelectionRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<EvaluatorSelection> task = super.EvaluatorSelection.findById(request.getId());
			if (task.isPresent()) {
				if (task.get().getExIsDelete()) {
					info.put("status", "2");
					info.put("message", "Evaluator already deleted");
					return info;
				}
				Boolean exIsDelete = true;
				Boolean is_active = false;
				int result = super.EvaluatorSelection.deleteEvaluator(exIsDelete, is_active, task.get().getId());
				if (result == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "Evaluator deleted successfully");
				return info;
			}
			info.put("status", "2");
			info.put("message", "Evaluator id not present");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getLog(String log) {
	    Map<Long, String> strmap = new HashMap<Long, String>();
		Map<String, Object> info = new LinkedHashMap<>();
		int linesToRead = 20;
	    String str = "";
	    try {	    	
	    	logger.info("Log request :" +log); 
	    	RandomAccessFile raf = new RandomAccessFile(new File(commonHelper.getSettingValue("COMMAND")), "r");
	    	List<String> lines = new ArrayList<String>();

	    	final int chunkSize = 1024 * 32;
	    	long end = raf.length();
	    	boolean readMore = true;
	    	while (readMore) {
	    	    byte[] buf = new byte[chunkSize];

	    	    // Read a chunk from the end of the file
	    	    long startPoint = end - chunkSize;
	    	    long readLen = chunkSize;
	    	    if (startPoint < 0) {
	    	        readLen = chunkSize + startPoint;
	    	        startPoint = 0;
	    	    }
	    	    raf.seek(startPoint);
	    	    readLen = raf.read(buf, 0, (int)readLen);
	    	    if (readLen <= 0) {
	    	        break;
	    	    }

	    	    // Parse newlines and add them to an array
	    	    int unparsedSize = (int)readLen;
	    	    int index = unparsedSize - 1;
	    	    while (index >= 0) {
	    	        if (buf[index] == '\n') {
	    	            int startOfLine = index + 1;
	    	            int len = (unparsedSize - startOfLine);
	    	            if (len > 0) {
	    	                lines.add(new String(buf, startOfLine, len));
	    	            }
	    	            unparsedSize = index + 1;
	    	        }
	    	        --index;
	    	    }

	    	    // Move end point back by the number of lines we parsed
	    	    // Note: We have not parsed the first line in the chunked
	    	    // content because could be a partial line
	    	    end = end - (chunkSize - unparsedSize);

	    	    readMore = lines.size() < linesToRead && startPoint != 0;
	    	}

	    	// Only print the requested number of lines
	    	if (linesToRead > lines.size()) {
	    	    linesToRead = lines.size();
	    	}

	    	for (int i = linesToRead - 1; i >= 0; --i) {
	    		str = str+lines.get(i);
	    	  
	    	}
	    	
	    	//info.put("test", str);
	    	
	        
	    } catch (Exception e) {
	    	e.printStackTrace();
	    	logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
	    }
	   
	    info.put("status", "1");
		info.put("message", str);
		return info;
	}

	@Override
	public Map<String, Object> resultPublishCreate(PublishResultRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			logger.info("Inside generateGradeReport");	
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Batch> batch = super.batch.findByExIsDeleteAndExIsActiveAndId(false, true, request.getBatch());
			if (!batch.isPresent()) {
				info.put("status", "2");
				info.put("message", "Batch not present");
				return info;
			}
			
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),
					false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}
			
		
				List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
			
			String sectionval  = "";
		
			List<Semster> list = new ArrayList<Semster>();			
			if(request.getSemester().size()>0) {		
				for(int i =0 ; i<request.getSemester().size() ; i++) {
					Optional<Semster> semester  = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSemester().get(i));					
					  if(!semester.isPresent()) {
						  info.put("status", "2"); 
						  info.put("message","Semster not present");
						  return info;
					}
						
					list.add(semester.get());
				}	
				
			}else {
				  info.put("status", "2"); 
				  info.put("message","Semster not present");
				  return info;
			}
			//check duplicate
			
			List<PublishResult> duplicate  =  publishResult.findByBatchIdAndExResultTypeAndAcademicYearIdAndSemsterInAndDepartmentId(request.getBatch(), request.getExResultType(), request.getAcademicYear(), list,request.getDepartment());
			if(duplicate.size() >0) {
				  info.put("status", "2"); 
				  info.put("message","Result Already published");
				  return info;
			}else {
			
			Date date = new Date();			
			PublishResult publish = new PublishResult();
			publish.setBatch(batch.get());
			publish.setDepartment(dept.get());
			publish.setDegree(degree.get());
			publish.setColleges(collage.get());
			publish.setExCreateDate(date);
			publish.setExIsActive(true);
			publish.setExIsDelete(false);
			publish.setExIsPublish(request.getExIsPublish());
			publish.setExResultType(request.getExResultType());
			publish.setProgrammes(Prog.get());
			publish.setSemster(list);
			publish.setUser(user.get(0));
			publish.setAcademicYear(academicYear.get());
			
			publish = publishResult.save(publish);
			//publishResult.updatePublish(request.getBatch() ,request.getExResultType() , publish.getId() , request.getDepartment());
			  info.put("status", "1"); 
			  info.put("message","Results published successfully");
			  return info;
		}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}

	@Override
	public Map<String, Object> resultPublishUpdate(PublishResultRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {			
			Optional<PublishResult> publish1 = publishResult.findById(request.getId()) ;
			if (!publish1.isPresent()) {
				info.put("status", "2");
				info.put("message", "Id not Present");
				return info;
			}			
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Batch> batch = super.batch.findByExIsDeleteAndExIsActiveAndId(false, true, request.getBatch());
			if (!batch.isPresent()) {
				info.put("status", "2");
				info.put("message", "Batch not present");
				return info;
			}
			
			 Optional<Department> dept =super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),
			  false, true); 
			 if (!dept.isPresent()) 
			 { info.put("status", "2");
			  info.put("message", "department not  present"); return info;
			  
			  }
	
		
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}

			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			
			Optional<AcademicYear> academicYear = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
			if (!academicYear.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
		
				List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
			
			String sectionval  = "";
		
			List<Semster> list = new ArrayList<Semster>();			
			if(request.getSemester().size()>0) {		
				for(int i =0 ; i<request.getSemester().size() ; i++) {
					Optional<Semster> semester  = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSemester().get(i));					
					  if(!semester.isPresent()) {
						  info.put("status", "2"); 
						  info.put("message","Semster not present");
						  return info;
					}
						
					list.add(semester.get());
				}	
				
			}else {
				  info.put("status", "2"); 
				  info.put("message","Semster not present");
				  return info;
			}
			//check duplicate
			
			/*
			 * List<PublishResult> duplicate =
			 * publishResult.findByBatchIdAndExResultTypeAndAcademicYearIdAndSemsterIn(
			 * request.getBatch(), request.getExResultType(), request.getAcademicYear(),
			 * list); if(duplicate.size() >0) { info.put("status", "2");
			 * info.put("message","Result Already published"); return info; }
			 */
			
			Date date = new Date();			
			PublishResult publish = new PublishResult();
			publish.setId(request.getId());
			publish.setBatch(batch.get());
			publish.setDegree(degree.get());
			publish.setColleges(collage.get());
			publish.setExUpdateDate(date);
			publish.setExCreateDate(publish1.get().getExCreateDate());
			publish.setExIsActive(true);
			publish.setExIsDelete(false);
			publish.setDepartment(dept.get());
			publish.setExIsPublish(request.getExIsPublish());
			publish.setExResultType(request.getExResultType());
			publish.setProgrammes(Prog.get());
			publish.setSemster(list);
			publish.setUser(user.get(0));
			publish.setAcademicYear(academicYear.get());
			
			publishResult.save(publish);
			publishResult.updatePublish(request.getBatch() ,request.getExResultType() , publish.getId() , request.getDepartment());
			  info.put("status", "1"); 
			  info.put("message","Results has been published ");
			  return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong.");
			return info;
		}
	}

	@Override
	public Map<String, Object> resultPublishGet(PublishResultRequest request) {
		// TODO Auto-generated method stub
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<PublishResult> tasks = publishResult.findByExIsDelete(false);
			if (tasks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Record Not Present");
				return info;
			} else {
				List dataList = new LinkedList();
				for (PublishResult e : tasks) {
					List section = new LinkedList();
					List sectionId = new LinkedList();

					Map<Object, Object> Programmesdata = new HashMap<Object, Object>();
					Programmesdata.put("id", e.getId());
					
					
					Programmesdata.put("exIsActive", e.getExIsActive());
					Programmesdata.put("exIsDelete", e.getExIsDelete());
					Programmesdata.put("degree", e.getDegree().getExName());
					Programmesdata.put("degreeId", e.getDegree().getId());

					for (int i = 0; i < e.getSemster().size(); i++) {
						section.add(e.getSemster().get(i).getExName());
						sectionId.add(e.getSemster().get(i).getId());
					}

					Programmesdata.put("semesterId", sectionId);
					Programmesdata.put("semester", section);


					Programmesdata.put("academicYear", e.getAcademicYear().getExYear());
					Programmesdata.put("academicYearId", e.getAcademicYear().getId());

					

					Programmesdata.put("degree", e.getDegree().getExName());
					Programmesdata.put("degreeId", e.getDegree().getId());

					Programmesdata.put("colleges", e.getColleges().getExIdentifier());
					Programmesdata.put("collegesId", e.getColleges().getId());

					Programmesdata.put("batch", e.getBatch().getExName());
					Programmesdata.put("batchId", e.getBatch().getId());
					
					Programmesdata.put("batch", e.getBatch().getExName());
					Programmesdata.put("batchId", e.getBatch().getId());
					
					Programmesdata.put("programmes", e.getProgrammes().getExIdentifier());
					Programmesdata.put("programmesId", e.getProgrammes().getId());
					
					Programmesdata.put("department", e.getDepartment() == null ?"NA" :e.getDepartment().getExIdentifier());
					Programmesdata.put("departmentId", e.getDepartment() == null ?"NA" :e.getDepartment().getId());
					
					Programmesdata.put("exResultType", e.getExResultType());
					Programmesdata.put("exIsPublish", e.getExIsPublish());

					dataList.add(Programmesdata);
				}
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> resultPublishDelete(PublishResultRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<PublishResult> task = publishResult.findById(request.getId());
			if (task.isPresent()) {
				if (task.get().getExIsDelete()) {
					info.put("status", "2");
					info.put("message", "Record already deleted");
					return info;
				}
				Boolean exIsDelete = true;
				Boolean is_active = false;
				int result = publishResult.deletePublish(exIsDelete, is_active, task.get().getId());
				if (result == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "Record deleted successfully");
				return info;
			}
			info.put("status", "2");
			info.put("message", " id not present");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getCoursesOnExamAndDept(EvaluationDetailsRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {					
			
			
			List<ExamBarcodes> ormmarks = super.exambarcode.getCoursesDetailsOnDeptExam(request.getExamAnnouncement(),request.getAcademicYear(),request.getProgrammes(),  request.getRegistrationType() , request.getDeparment());			
			 if(ormmarks.size() <=0){
	        		info.put("status", "2");
	    			info.put("message", "Exam not conducted");		
	    			return info;
	        	}
			           
        	List dataList = new LinkedList();	
           for (ExamBarcodes e : ormmarks) {
        		Map<Object, Object> coursesdata = new HashMap<Object, Object>();
				coursesdata.put("id", e.getCourses().getId());
				coursesdata.put("exName", e.getCourses().getExName());
				coursesdata.put("exCoursesCode",e.getStudentadmission().getBatch().getExIdentifier()+"::"+ e.getCourses().getExCoursesCode()+"::"+e.getCourses().getExName());
				coursesdata.put("creditHours", e.getCourses().getCreditHours().getExCreditHourTitle());
				coursesdata.put("exIsSatisfactory", e.getCourses().getExIsSatisfactory());
				coursesdata.put("exIsElective", e.getCourses().getExIsElective());	
				coursesdata.put("exIsProject", e.getCourses().getExIsProject());				
				coursesdata.put("exIsSeminar", e.getCourses().getExIsSeminar());				
				dataList.add(coursesdata);
        	}	
			info.put("status", "1");
			info.put("message", "success");		
        	info.put("details", dataList);
        	return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getSemesterReport(GradeReportRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			logger.info("Inside generate Semester Progress Report > " + request);
				List<SemesterProgressReport> totalcgpa = super.semesterProgressReport.findByCollegesIdAndDegreeIdAndProgrammesIdAndSemesterIdAndAcademicYearIdAndProgrammeYearIdAndDepartmentIdAndStudentadmissionBatchIdAndExIsActive(
						request.getColleges(), request.getDegree(), request.getProgrammes(),  request.getSemester(),request.getAcademicYear()
						,request.getProgrammeYear(), request.getDepartment(),request.getBatch() , true);
		
				if (totalcgpa.size() <= 0) {
					info.put("status", "2");
	    			info.put("message", "Result not Announced");		
	    			return info;
				}
				
				List dataList = new LinkedList();
				for(SemesterProgressReport e :totalcgpa) {
					Map<String, Object> Coursesdata = new HashMap<String, Object>();
					
					Coursesdata.put("academicYearId", e.getAcademicYear().getId());
					Coursesdata.put("academicYear", e.getAcademicYear().getExYear());
					
					Coursesdata.put("degreeId", e.getDegree().getId());
					Coursesdata.put("degree", e.getDegree().getExName());
					
					Coursesdata.put("ProgramYear", e.getProgrammeYear().getExName());
					Coursesdata.put("ProgramYearId", e.getProgrammeYear().getId());
					
					
					Coursesdata.put("semesterId", e.getSemester().getId());
					Coursesdata.put("semester", e.getSemester().getExName());
					
					Coursesdata.put("collegeId", e.getColleges().getId());
					Coursesdata.put("college", e.getColleges().getExIdentifier());
					
					Coursesdata.put("programmesId", e.getProgrammes().getId());
					Coursesdata.put("programmes", e.getProgrammes().getExIdentifier());
					
					Coursesdata.put("departmentId", e.getDepartment().getId());
					Coursesdata.put("department", e.getDepartment().getExIdentifier());
					Coursesdata.put("id", e.getId());
					
					Coursesdata.put("rollNumber", e.getExRollNo());
					
					
					Coursesdata.put("streamId", e.getStudentadmission().getStream().get(0).getId());
					Coursesdata.put("stream",  e.getStudentadmission().getStream().get(0).getExIdentifier());
					
					dataList.add(Coursesdata);
				}

				info.put("status", "1");
				info.put("message", "success");		
	        	info.put("details", dataList);

					return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getSupplementaryCoursesForStudent(CoursesRegistrationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {	
			Optional<Studentadmission> status = super.studentadmission.findById(request.getStudent());
			if (!status.isPresent()) {
				info.put("status", "2");
				info.put("message", "Student is not present.");
				return info;
			}
			List<PublishResult> valu = super.publish.getRecord(status.get().getBatch().getId(),  status.get().getDepartment().getId());
			if (valu.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Result not Announced.");
				return info;
			}	
			
			Long sem  = valu.get(0).getSemster().get(0).getId();
			
			System.out.println("dddddddddddd"+sem);
			
			List<GradeReport> gradereport = super.gradeReport.getSuject( request.getStudent() , sem);	
			if(gradereport.size() <=0) {
				info.put("status", "2");
				info.put("message", "you don't have any supplementary courses courses");
					return info;
			}
			
			List dataList = new LinkedList();
			for (GradeReport e : gradereport) {							
				 List<GradeReport> spresent = super.gradeReport.findByExCoursesStatusAndStudentadmissionIdAndCoursesId(1 ,request.getStudent() , e.getCourses().getId());
				 if(spresent.size() <=0) {
					 Map<String, Object> Coursesdata = new HashMap<String, Object>();	
					 
					 
					String isRegistered = "NO";
					String isPaid = "NO";			
											
					 List<CoursesRegistration> cp = super.coursesRegistration.findByStudentadmissionIdAndRegistrationIdAndCoursesId(request.getStudent(), 2L, e.getCourses().getId());
					 if(cp.size() >0) {
						 isRegistered = "YES";
						 if(cp.get(0).getExIsPaid() !=null && cp.get(0).getExIsPaid() == true) {
							 isPaid = "YES";
						 }
					 }			 
					 
					Coursesdata.put("isPaid", isPaid);
					Coursesdata.put("isRegistered", isRegistered);
					Coursesdata.put("id", e.getCourses().getId());
					Coursesdata.put("exCoursesCode", e.getCourses().getExCoursesCode());
					Coursesdata.put("exName", e.getCourses().getExName());					
					Coursesdata.put("creditHours", e.getCourses().getCreditHours().getExCreditHourTitle());
					Coursesdata.put("programYear",e.getCourses().getProgrammeYear().getExName());
					Coursesdata.put("programYearId", e.getCourses().getProgrammeYear().getId());
					Coursesdata.put("semesterId",e.getCourses().getSemester().getId());
					Coursesdata.put("semester",e.getCourses().getSemester().getExName());
					dataList.add(Coursesdata);
					 
				 }
				 

		}
			if(dataList.size() <=0) {				
				info.put("status", "2");
				info.put("message", "you don't have any supplementary courses courses");
					return info;
			}
			
			info.put("status", "1");
			info.put("message", "success");
			info.put("details", dataList);	
			

			return info;
		}catch(Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}
}
