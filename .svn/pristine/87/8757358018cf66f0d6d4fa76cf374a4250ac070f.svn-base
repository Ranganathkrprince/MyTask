package com.niftem.app.implementation;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.concurrent.TimeUnit;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.transaction.Transactional;
import javax.validation.Valid;

import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.disk.DiskFileItem;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.commons.CommonsMultipartFile;

import com.niftem.app.entity.AcademicYear;
import com.niftem.app.entity.Batch;
import com.niftem.app.entity.Category;
import com.niftem.app.entity.Colleges;
import com.niftem.app.entity.Courses;
import com.niftem.app.entity.CoursesCoverage;
import com.niftem.app.entity.CoursesRegistration;
import com.niftem.app.entity.CoursesType;
import com.niftem.app.entity.Degree;
import com.niftem.app.entity.Department;
import com.niftem.app.entity.Designation;
import com.niftem.app.entity.ExamAcademicYearProgrammes;
import com.niftem.app.entity.ExamAnnouncement;
import com.niftem.app.entity.ExamAttendance;
import com.niftem.app.entity.ExamAttendanceLog;
import com.niftem.app.entity.ExamBarcodes;
import com.niftem.app.entity.ExamTimeTable;
import com.niftem.app.entity.ExamTimeTableLogs;
import com.niftem.app.entity.FeeCategory;
import com.niftem.app.entity.FeeHeadMaster;
import com.niftem.app.entity.FeeMaster;
import com.niftem.app.entity.FeeType;
import com.niftem.app.entity.Hostel;
import com.niftem.app.entity.HostelConfiguration;
import com.niftem.app.entity.InvigilatorAllocation;
import com.niftem.app.entity.InvigilatorDateAllocation;
import com.niftem.app.entity.InvigilatorDuty;
import com.niftem.app.entity.ProgramType;
import com.niftem.app.entity.ProgrammeYear;
import com.niftem.app.entity.Programmes;
import com.niftem.app.entity.QpSetterLog;
import com.niftem.app.entity.QuestionOptionMapping;
import com.niftem.app.entity.QuestionPaper;
import com.niftem.app.entity.QuestionPaperLog;
import com.niftem.app.entity.QuestionPaperPattern;
import com.niftem.app.entity.QuestionPaperTopic;
import com.niftem.app.entity.QuestionPaperType;
import com.niftem.app.entity.QuestionPaperUpload;
import com.niftem.app.entity.QuestionPaperVersion;
import com.niftem.app.entity.RegistrationType;
import com.niftem.app.entity.Role;
import com.niftem.app.entity.RoomMaster;
import com.niftem.app.entity.SeatArrangement;
import com.niftem.app.entity.SemesterRegistration;
import com.niftem.app.entity.Semster;
import com.niftem.app.entity.StaffEmpDetails;
import com.niftem.app.entity.StaffType;
import com.niftem.app.entity.Staffpersonal;
import com.niftem.app.entity.Stream;
import com.niftem.app.entity.StudentBankDetails;
import com.niftem.app.entity.StudentEnrollementNo;
import com.niftem.app.entity.StudentRollNo;
import com.niftem.app.entity.Studentadmission;
import com.niftem.app.entity.StudentadmissionLog;
import com.niftem.app.entity.Studentpersonal;
import com.niftem.app.entity.User;
import com.niftem.app.model.CoursesCoverageRequest;
import com.niftem.app.model.CreateStaffRequest;
import com.niftem.app.model.CreateStudentRequest;
import com.niftem.app.model.ExamAttendanceRequest;
import com.niftem.app.model.ExamTimeTableRequest;
import com.niftem.app.model.ExternalMarksRequest;
import com.niftem.app.model.FeeCategoryRequest;
import com.niftem.app.model.FeeHeadMasterRequest;
import com.niftem.app.model.FeeMasterRequest;
import com.niftem.app.model.HostelConfigureDetailRequest;
import com.niftem.app.model.InternalMarksRequest;
import com.niftem.app.model.InvigilatorAllocationRequest;
import com.niftem.app.model.QuestionPaperPatternRequest;
import com.niftem.app.model.QuestionPaperTopicRequest;
import com.niftem.app.model.QuestionPaperTypeRequest;
import com.niftem.app.model.QuestionpaperRequest;
import com.niftem.app.model.SeatArrangementRequest;
import com.niftem.app.model.SemesterRegistrationRequest;
import com.niftem.app.model.StudentEnrollementNoRequest;
import com.niftem.app.model.StudentProfile;
import com.niftem.app.model.StudentRollNoRequest;
import com.niftem.app.repository.InvigilatorDutyRepository;
import com.niftem.app.repository.QpSetterLogRepository;
import com.niftem.app.repository.QuestionPaperUploadRepository;
import com.niftem.app.repository.StudentBankDetailsRepository;
import com.niftem.app.service.AcademicService;
import com.niftem.app.util.AutoManager;

@Service
@Transactional

public class AcademicImpl extends AutoManager implements AcademicService {

	@PersistenceContext
	private EntityManager entityManager;
	
	@Autowired
	private QpSetterLogRepository qplog;
	
	@Autowired
	private StudentBankDetailsRepository studentBankDetailsRepository;

	@Autowired
	private QuestionPaperUploadRepository QuestionPaperUploadRepository;
	
	@Autowired
	private InvigilatorDutyRepository invigilatorduty;

	// private static final String request.getExPassword() = null;
	private static Logger logger = LoggerFactory.getLogger("master-log");
	private static Logger excellog = LoggerFactory.getLogger("excel-log");

	@Override
	public Map<String, String> createStudentProfile(CreateStudentRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {

			List<Studentadmission> tasks = new ArrayList<Studentadmission>();
			if (request.getExIsActive() == null) {
				info.put("status", "2");
				info.put("message", "IsActive is required 0/1");
				return info;
			}

			tasks = super.studentadmission.findByExIsDeleteAndExUserNameAndExIsActive(false, request.getExUserName(),true);
			if (tasks.size() > 0) {
				info.put("status", "2");
				info.put("message", "student User name already exists");
				return info;
			}
			
			List<Studentadmission> rollnumber  = super.studentadmission.findByExRollNoAndExIsActiveAndExIsDelete(request.getExRollNo(), true , false );
			if (rollnumber.size() > 0) {
				info.put("status", "2");
				info.put("message", "Roll No. already exists");
				return info;
			}
			
			List<Studentadmission> enrollno  = super.studentadmission.findByExEnrollementNoAndExIsDeleteAndExIsActive(request.getExEnrollementNo(), false , true );
			if (enrollno.size() > 0) {
				info.put("status", "2");
				info.put("message", "Enrollement No. already exists");
				return info;
			}

			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent() || !collage.get().getExIsActive()) {
				info.put("status", "2");
				info.put("message", "College not present");
				return info;
			}

			Category category = null;
			if (request.getCategory() == null || request.getCategory().equals("")) {
				category = null;
			} else {
				Optional<Category> categoryres = super.category.findByIdAndExIsDeleteAndExIsActive(request.getCategory(), false, true);
				if (!categoryres.isPresent() || !categoryres.get().getExIsActive()) {
					info.put("status", "2");
					info.put("message", "Category not present");
					return info;
				}
				category = categoryres.get();
			}

			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "degree not present");
				return info;
			}

			Optional<AcademicYear> year = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!year.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear not present");
				return info;
			}

			Optional<Programmes> program = super.programmes.findByIdAndExIsDeleteAndExIsActive(request.getProgrammes(),
					false, true);

			if (!program.isPresent()) {
				info.put("status", "2");
				info.put("message", "programmes not present");
				return info;
			}
			List<Stream> streams = new ArrayList<Stream>();
			if (program.get().getExIdentifier().equals("MBA")) {
				for (int i = 0; i < request.getStream().size(); i++) {
					long number = request.getStream().get(i);
					Long col = new Long(number);
					Optional<Stream> streamss = super.stream.findByIdAndExIsDeleteAndExIsActive(col, false, true);
					if (!streamss.isPresent()) {
						info.put("status", "2");
						info.put("message", "Selected stream type not present");
						return info;
					}
					if (streams.size() < 2) {
						streams.add(streamss.get());
					} else {
						info.put("status", "2");
						info.put("message", "Select only two streams");
						return info;
					}
				}
			} else if (!(program.get().getExIdentifier().equals("MBA"))) {
				for (int i = 0; i < request.getStream().size(); i++) {
					Object number = request.getStream().get(i);
					Long col = new Long((long) number);
					Optional<Stream> streamss = super.stream.findByIdAndExIsDeleteAndExIsActive(col, false, true);
					if (!streamss.isPresent()) {
						info.put("status", "2");
						info.put("message", "Selected stream type not present");
						return info;
					}
					if (streams.size() < 1) {
						streams.add(streamss.get());
					} else {
						info.put("status", "2");
						info.put("message", "Select only one stream");
						return info;
					}
				}
			}

			Optional<Department> department = super.department.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getDepartment());
			if (!department.isPresent()) {
				info.put("status", "2");
				info.put("message", "Department not present");
				return info;
			}

			Optional<Batch> batch = super.batch.findByExIsDeleteAndExIsActiveAndId(false, true, request.getBatch());
			if (!batch.isPresent()) {
				info.put("status", "2");
				info.put("message", "batch not present");
				return info;
			}

			Optional<ProgramType> programtype = super.programtype.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgramtype());
			if (!programtype.isPresent()) {
				info.put("status", "2");
				info.put("message", "programtype not present");
				return info;
			}

			Optional<AcademicYear> academicYear = super.academicYear.findByIdAndExIsDeleteAndExIsActive(request.getAcademicYear(), false, true);
			if (!academicYear.isPresent() || !academicYear.get().getExIsActive()) {
				info.put("status", "2");
				info.put("message", "academicYear not present");
				return info;
			}

			Optional<Category> allocatedCategory = super.category.findByIdAndExIsDeleteAndExIsActive(request.getAllocatedCategory(), false, true);
			if (!allocatedCategory.isPresent()) {
				info.put("status", "2");
				info.put("message", "allocatedCategory not present");
				return info;
			}
			
			/*
			 * Optional<StudentRollNo> StudentRollNo = super.studentRollNo.
			 * findByExIsDeleteAndExIsActiveAndCollegesIdAndDegreeIdAndExNameContaining(
			 * false, true, request.getColleges(), request.getDegree()
			 * ,department.get().getExDepartmentCode()+academicYear.get().getExDescription()
			 * .substring(0,academicYear.get().getExDescription().indexOf("-"))); if
			 * (!StudentRollNo.isPresent()) { info.put("status", "2"); info.put("message",
			 * "Pleases create StudentRollNo Formate"); return info; }
			 */		

			/*
			 * System.out.println("???????dddddddd??????????" +
			 * degree.get().getExName()+"/"+academicYear.get().getExDescription()+"/"+
			 * department.get().getExDepartmentCode());
			 * 
			 * Optional<StudentEnrollementNo> StudentEnrollementNo =
			 * super.studentEnrollment.
			 * findByExIsDeleteAndExIsActiveAndCollegesIdAndDegreeIdAndExNameContaining(
			 * false, true, request.getColleges(),request.getDegree() ,
			 * degree.get().getExName()+"/"+academicYear.get().getExDescription()+"/"+
			 * department.get().getExDepartmentCode()); if
			 * (!StudentEnrollementNo.isPresent()) { info.put("status", "2");
			 * info.put("message", "Pleases create StudentEnrollementNo Formate"); return
			 * info; }
			 */
			String Enrollement = "";
			Long idIncrement = 0L;

			/*
			 * if (request.getExEnrollementNo().isEmpty() || request.getExEnrollementNo() ==
			 * null|| request.getExEnrollementNo().equals("")) { List<Studentadmission>
			 * max_id = super.studentadmission
			 * .findByExIsDeleteAndExIsActiveAndCollegesIdAndDegreeId(false, true,
			 * request.getColleges(), request.getDegree()); if (max_id.size() > 0) {
			 * Optional<Studentadmission> task = super.studentadmission
			 * .findById(max_id.get(max_id.size() - 1).getId()); idIncrement =
			 * Long.parseLong(task.get().getExEnrollementNo().toString()
			 * .substring(task.get().getExEnrollementNo().lastIndexOf("/") + 1));
			 * System.out.println("???????idIncrement??????????" + idIncrement++);
			 * Enrollement = degree.get().getExName() + "/" +
			 * academicYear.get().getExDescription() + "/" +
			 * department.get().getExDepartmentCode() + "/" + idIncrement++; } else {
			 * idIncrement = Long.parseLong(StudentEnrollementNo.get().getExIdStartWith());
			 * Enrollement = degree.get().getExName() + "/" +
			 * academicYear.get().getExDescription() + "/" +
			 * department.get().getExDepartmentCode() + "/" + idIncrement; } } else {
			 * 
			 * }
			 */
			
			
			Enrollement = request.getExEnrollementNo();
			
			Studentadmission admision = new Studentadmission();
			String dcrypt = EncryptionAndDecryption.getDecryptedStringaddhexkey(request.getExPassword());
			Long privailageid = 28L;
			User userid = super.commonHelper.getuser(request.getUsers());
			String Description = university.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(false, Description, userid, privailageid);
			String rollno = "";
			Integer rollIncrement = 0;
			/*
			 * if (request.getExRollNo().isEmpty() || request.getExRollNo() == null ||
			 * request.getExRollNo().equals("")) {
			 * 
			 * List<Studentadmission> max_idroll =
			 * super.studentadmission.findByExIsDeleteAndExIsActiveAndCollegesIdAndDegreeId(
			 * false, true, request.getColleges(),request.getDegree()); if
			 * (max_idroll.size() > 0) { Optional<Studentadmission> task =
			 * super.studentadmission.findById(max_idroll.get(max_idroll.size() -
			 * 1).getId()); rollIncrement = task.get().getExRollNoInc().intValue() + 1; int
			 * incvalue = rollIncrement; rollno = department.get().getExDepartmentCode() +
			 * academicYear.get().getExDescription().substring(0,
			 * academicYear.get().getExDescription().indexOf("-")) + incvalue++; } else {
			 * String Increment = StudentRollNo.get().getExIdStartWith(); int inc =
			 * Integer.parseInt(Increment); rollIncrement = inc;
			 * admision.setExRollNoInc(inc); rollno = department.get().getExDepartmentCode()
			 * + academicYear.get().getExDescription().substring(0,academicYear.get().
			 * getExDescription().indexOf("-")) + Increment; } } else { rollno =
			 * request.getExRollNo(); rollIncrement =
			 * Integer.parseInt(rollno.trim().substring(rollno.trim().length() - 3)); }
			 */
			
			rollno = request.getExRollNo();
			rollIncrement = Integer.parseInt(rollno.trim().substring(rollno.trim().length() - 3));

			Date date = new Date();
			admision.setAllocatedCategory(allocatedCategory.get());
			admision.setColleges(collage.get());
			admision.setProgrammes(program.get());
			admision.setExIsApprove(1);
			admision.setExRollNoInc(rollIncrement);
			admision.setDegree(degree.get());
			admision.setDepartment(department.get());
			admision.setAcademicYear(academicYear.get());
			admision.setStream(streams);
			admision.setCategory(category);
			admision.setBatch(batch.get());
			admision.setProgramtype(programtype.get());
			admision.setExIsActive(request.getExIsActive());

			admision.setExUserName(request.getExUserName());

			admision.setExIsDelete(false);
			admision.setExName(request.getExName());
			System.out.println(">>>>>>>>>request>>>>" + admision);
			admision.setExNameInHindi(request.getExNameInHindi());

			
			admision.setExStudyStatus(request.getExStudyStatus());
			admision.setExPhoto(request.getExPhoto());
			admision.setExDocumentPath(request.getExDocumentPath());

			//admision.setExStudyStatus("Studying");
			admision.setExPhoto(request.getExPhoto());
			admision.setExDocumentPath(request.getExDocumentPath());

			admision.setExDetailsQualification(request.getExDetailsQualification());
			admision.setExAllIndiaRank(request.getExAllIndiaRank());
			admision.setExJeeReg(request.getExJeeReg());
			admision.setExPercentageOfMarks(request.getExPersentageOfMarks());
			admision.setExSignature(request.getExSignature());
			admision.setExEnrollementNo(Enrollement);
			admision.setExRollNo(rollno);
			admision.setExPassword(dcrypt);
			admision.setExCreateDate(date);
			super.studentadmission.save(admision);
			Boolean retvalue = validateStudentInfo(request, admision);

			info.put("status", "1");
			info.put("message", "studentprofile created successfully");
			info.put("id", admision.getId().toString());
			excellog.info("Student record Saved : " + retvalue);
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			e.printStackTrace();
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;

		}
	}

	// Optional<ExamAnnouncement> exam = null;

	// return info;
	/*
	 * 
	 * }
	 * 
	 * @Override public Boolean validateStudentInfo(CreateStudentRequest request ,
	 * Studentadmission admision) { Map<String, String> info = new
	 * LinkedHashMap<>(); try { SimpleDateFormat date1 = new
	 * SimpleDateFormat("dd/MM/yyyy"); // insert Record into ex_studentpersonal
	 * table Studentpersonal studentpersonal = new Studentpersonal();
	 * studentpersonal.setExAdhaarNumber(request.getExAdhaarNumber());
	 * studentpersonal.setAdmission(admision);
	 * studentpersonal.setExBloodGroup(request.getExBloodGroup());
	 * studentpersonal.setExDateOfBirth(date1.parse(request.getExDateOfBirth()));
	 * studentpersonal.setExEmail(request.getExEmail());
	 * studentpersonal.setExFirstName(request.getExFirstName());
	 * studentpersonal.setExLocalLangName(request.getExLocalLangName());
	 * studentpersonal.setExGender(request.getExGender());
	 * studentpersonal.setExLastName(request.getExLastName());
	 * studentpersonal.setExMiddleName(request.getExMiddleName());
	 * studentpersonal.setExMobile(request.getExMobile());
	 * studentpersonal.setExMotherTounge(request.getExMotherTounge());
	 * studentpersonal.setExNationality(request.getExNationality());
	 * studentpersonal.setExPhoto(request.getExPhoto());
	 * studentpersonal.setExReligion(request.getExReligion());
	 * studentpersonal.setExRuralUrban(request.getExRuralUrban());
	 * studentpersonal.setExSection(request.getExSection());
	 * studentpersonal.setExSpeciallyAbled(request.getExSpeciallyAbled());
	 * studentpersonal.setExState(request.getExState());
	 * studentpersonal.setExFatherEmail(request.getExFatherEmail());
	 * studentpersonal.setExFatherMobile(request.getExFatherMobile());
	 * studentpersonal.setExFatherName(request.getExFatherName());
	 * studentpersonal.setExGuardian(request.getExGuardian());
	 * studentpersonal.setExMotherName(request.getExMotherName());
	 * studentpersonal.setExOccupation(request.getExOccupation());
	 * 
	 * super.studentpersonal.save(studentpersonal); return true;
	 * 
	 * }catch(Exception e) { logger.error("Exception occured" + e); StringWriter
	 * errors = new StringWriter(); e.printStackTrace(new PrintWriter(errors));
	 * logger.error(errors.toString()); info.put("status", "0"); info.put("message",
	 * "something went wrong"); return false; } } private Boolean
	 * saveSemesterRegistration(String studentid_number, Optional<AcademicYear>
	 * academicYearid, Optional<ProgrammeYear> programyear, Optional<Semster> sem,
	 * Optional<Programmes> programs , Boolean is_active) { try { Date date = new
	 * Date(); SemesterRegistration semesterregistration = new
	 * SemesterRegistration();
	 * semesterregistration.setAcademicYear(academicYearid.get());
	 * semesterregistration.setProgrammes(programs.get());
	 * semesterregistration.setSemester(sem.get());
	 * semesterregistration.setProgrammeYear(programyear.get());
	 * semesterregistration.setExStudentId(studentid_number);
	 * semesterregistration.setExSemesterStatus(0);
	 * semesterregistration.setExIsRegistered(1);
	 * semesterregistration.setExCreateDate(date);
	 * semesterregistration.setExIsActive(is_active);
	 * semesterregistration.setExIsDelete(false);
	 * //semesterregistration.setDiscipline(discipline.get());
	 * super.semesterRegistration.save(semesterregistration); return true;
	 * 
	 * }catch(Exception e) { logger.error("Exception occured" + e); StringWriter
	 * errors = new StringWriter(); e.printStackTrace(new PrintWriter(errors));
	 * logger.error(errors.toString()); } return false; }
	 * 
	 * @Override public Map<String, Object>
	 * getAllStudentProfile(CreateStudentRequest request) { Map<String, Object> info
	 * = new LinkedHashMap<>(); try { List<Studentpersonal> task =
	 * super.studentpersonal.findByAdmissionExIsDelete(false); if(task.size() <=0) {
	 * info.put("status", "2"); info.put("message", "Student not created"); return
	 * info; }else { List dataList = new LinkedList(); for (Studentpersonal e :
	 * task) { Map<Object, Object> Studentadmissiondata = new HashMap<Object,
	 * Object>(); Studentadmissiondata.put("id", e.getId());
	 * Studentadmissiondata.put("exLoginName", e.getAdmission().getExLoginName());
	 * Studentadmissiondata.put("exStudentId", e.getAdmission().getExStudentId());
	 * Studentadmissiondata.put("allocatedCategory",
	 * e.getAdmission().getAllocatedCategory().getExName());
	 * Studentadmissiondata.put("actualCategory",
	 * e.getAdmission().getActualCategory()==null?"NA":e.getAdmission().
	 * getActualCategory().getExName());
	 * Studentadmissiondata.put("actualCategoryId",
	 * e.getAdmission().getActualCategory()==null?"NA":
	 * e.getAdmission().getActualCategory().getId());
	 * Studentadmissiondata.put("exCategoryId",
	 * e.getAdmission().getAllocatedCategory().getId());
	 * Studentadmissiondata.put("exPassword", e.getAdmission().getExPassword());
	 * Studentadmissiondata.put("exPassedOutYear",
	 * e.getAdmission().getExPassedOutYear()); Studentadmissiondata.put("exCollege",
	 * e.getAdmission().getColleges().getExName());
	 * Studentadmissiondata.put("exCollegeId",
	 * e.getAdmission().getColleges().getId()); Studentadmissiondata.put("exDegree",
	 * e.getAdmission().getDegree().getExName());
	 * Studentadmissiondata.put("exDegreeId", e.getAdmission().getDegree().getId());
	 * Studentadmissiondata.put("exProgrammes",
	 * e.getAdmission().getProgrammes().getExName());
	 * Studentadmissiondata.put("exProgrammesId",
	 * e.getAdmission().getProgrammes().getId());
	 * Studentadmissiondata.put("exAdmissionSource",
	 * e.getAdmission().getExAdmissionSource());
	 * Studentadmissiondata.put("firstName", e.getExFirstName());
	 * Studentadmissiondata.put("exLocalLangName",e.getExLocalLangName());
	 * Studentadmissiondata.put("email", e.getExEmail());
	 * Studentadmissiondata.put("mobile", e.getExMobile());
	 * dataList.add(Studentadmissiondata); } info.put("status", "1");
	 * info.put("message", "success"); info.put("details", dataList); return info; }
	 * 
	 * } catch (Exception e) { logger.error("Exception occured" + e); StringWriter
	 * errors = new StringWriter(); e.printStackTrace(new PrintWriter(errors));
	 * logger.error(errors.toString()); info.put("status", "0"); info.put("message",
	 * "Something went wrong"); return info; } }
	 * 
	 * @Override public Map<String, String>
	 * deleteStudentProfile(CreateStudentRequest request) { Map<String, String> info
	 * = new LinkedHashMap<>(); try { Optional<Studentadmission> task =
	 * super.studentadmission.findById(request.getId()); if (task.isPresent()) {
	 * if(task.get().getExIsDelete()) { info.put("status", "2"); info.put("message",
	 * "StudentProfile already deleted"); return info; } Boolean exIsDelete = true;
	 * Boolean is_active = false; int result =
	 * super.studentadmission.updateStudentProfilefordelete(exIsDelete,
	 * is_active,task.get().getId()); if (result == 0) { info.put("status", "2");
	 * info.put("message", "Something went wrong"); return info; }
	 * info.put("status", "1"); info.put("message",
	 * "StudentProfile deleted successfully"); return info; } info.put("status",
	 * "2"); info.put("message", "StudentProfile id not present"); return info; }
	 * catch (Exception e) { logger.error("Exception occured" + e); StringWriter
	 * errors = new StringWriter(); e.printStackTrace(new PrintWriter(errors));
	 * logger.error(errors.toString()); info.put("status", "0"); info.put("message",
	 * "Something went wrong"); return info; } }
	 * 
	 * @Override public Map<String, String> createStaff(CreateStaffRequest request)
	 * { Map<String, String> info = new LinkedHashMap<>(); return info; /* try {
	 * 
	 * Optional<Colleges> collage =
	 * super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(),false
	 * ,true); if (!collage.isPresent() || !collage.get().getExIsActive()) {
	 * info.put("status", "2"); info.put("message", "College not Present"); return
	 * info; } Optional<Degree> degree =
	 * super.degree.findByExIsDeleteAndExIsActiveAndId(false,true,request.getDegree(
	 * )); if (!degree.isPresent() || !degree.get().getExIsActive()) {
	 * info.put("status", "2"); info.put("message", "Degree not Present"); return
	 * info; } Optional<Discipline> discipline =
	 * super.discipline.findByIdAndExIsActiveAndExIsDelete(request.getDiscipline()
	 * ,true ,false); if (!discipline.isPresent()){ info.put("status", "2");
	 * info.put("message", " Discipline not present"); return info; }
	 * 
	 * Optional<Designation> designation =
	 * super.designation.findByExIsDeleteAndExIsActiveAndId(false , true ,
	 * request.getDesignation()); if (!designation.isPresent()) { info.put("status",
	 * "2"); info.put("message", "Designation not Present"); return info; }
	 * Optional<StaffType> safftype =
	 * super.staffType.findByExIsDeleteAndExIsActiveAndId(false , true ,
	 * request.getStafftype()); if (!safftype.isPresent()) { info.put("status",
	 * "2"); info.put("message", "StaffType not Present"); return info; }
	 * List<Staffpersonal> loginname
	 * =super.staffpersonal.findByExLoginNameAndExIsDelete(request.getExLoginName().
	 * trim(),false); if(loginname.size()>0) { info.put("status", "2");
	 * info.put("message", "LoginName is already exist"); return info; }
	 * 
	 * List<Staffpersonal> employee
	 * =super.staffpersonal.findByExEmployeeIdAndExIsDelete(request.getExEmployeeId(
	 * ).toString(),false); if(employee.size()>0) { info.put("status", "2");
	 * info.put("message", "EmployeeId is already exist"); return info; }
	 * 
	 * Date date = new Date(); SimpleDateFormat date1 = new
	 * SimpleDateFormat("dd/MM/yyyy"); Staffpersonal staffpersonal = new
	 * Staffpersonal(); staffpersonal.setExAddress(request.getExAddress());
	 * staffpersonal.setExBloodGroup(request.getExBloodGroup());
	 * staffpersonal.setExCity(request.getExCity());
	 * staffpersonal.setColleges(collage.get());
	 * staffpersonal.setExEmail(request.getExEmail());
	 * staffpersonal.setExEmployeeId(request.getExEmployeeId());
	 * staffpersonal.setExCreateDate(date); staffpersonal.setExIsActive(true); //
	 * staffpersonal.setExDateOfBirth(date1.parse(request.getExDateOfBirth()));
	 * staffpersonal.setExIsDelete(false);
	 * staffpersonal.setExFirstName(request.getExFirstName());
	 * staffpersonal.setExLastName(request.getExLastName());
	 * 
	 * staffpersonal.setExLoginName(request.getExLoginName());
	 * staffpersonal.setExMiddleName(request.getExMiddleName());
	 * staffpersonal.setExMobile(request.getExMobile());
	 * staffpersonal.setExPassword(request.getExPassword());
	 * staffpersonal.setExPhoto(request.getExPhoto());
	 * staffpersonal.setExPincode(request.getExPincode());
	 * staffpersonal.setExState(request.getExState());
	 * staffpersonal.setDegree(degree.get());
	 * super.staffpersonal.save(staffpersonal); saveStaffDetails(request ,
	 * staffpersonal , discipline,designation , safftype);
	 * 
	 * info.put("status", "1"); info.put("message", "Staff created successfully");
	 * return info; }catch(Exception e) { logger.error("Exception occured" + e);
	 * StringWriter errors = new StringWriter(); e.printStackTrace(new
	 * PrintWriter(errors)); logger.error(errors.toString()); info.put("status",
	 * "0"); info.put("message", "something went wrong"); return info; }
	 */

	/*
	 * @Override public Map<String, String> saveStaffDetails(CreateStaffRequest
	 * request, Staffpersonal staffpersonal, List<Designation> des,
	 * Optional<StaffType> safftype) { Map<String, String> info = new
	 * LinkedHashMap<>(); try { //SimpleDateFormat date1 = new
	 * SimpleDateFormat("dd/MM/yyyy"); StaffEmpDetails StaffEmpDetails = new
	 * StaffEmpDetails(); StaffEmpDetails.setExBankName(request.getExBankName());
	 * StaffEmpDetails.setExAdhaarNumber(request.getExAdhaarNumber());
	 * StaffEmpDetails.setExBankAccountNo(request.getExBankAccountNo());
	 * //StaffEmpDetails.setExDateOfJoing(request.getExDateOfJoing())); //
	 * StaffEmpDetails.setDiscipline(discipline.get());
	 * //StaffEmpDetails.setExDesignation(designation.get());
	 * StaffEmpDetails.setExIfscCode(request.getExIfscCode());
	 * StaffEmpDetails.setExPanNumber(request.getExPanNumber());
	 * StaffEmpDetails.setExSkill(request.getExSkill());
	 * StaffEmpDetails.setStaffpersonal(staffpersonal);
	 * StaffEmpDetails.setExQualification(request.getExQualification());
	 * //StaffEmpDetails.setStaffpersonal(staffpersonal);
	 * 
	 * super.staffEmpDetails.save(StaffEmpDetails);
	 * 
	 * info.put("status", "1"); info.put("message", "success"); return info;
	 * 
	 * } catch (Exception e) { logger.error("Exception occured" + e); StringWriter
	 * errors = new StringWriter(); e.printStackTrace(new PrintWriter(errors));
	 * logger.error(errors.toString()); info.put("status", "0"); info.put("message",
	 * "something went wrong"); return info; }
	 * 
	 * }
	 */
	@Override
	public Map<String, String> updateStaff(CreateStaffRequest request) {
		

		  Map<String, String> info = new LinkedHashMap<>();
		  try { 
				SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");
		
				if (request.getId() == null|| request.getId().equals("")|| request.getId().equals("NA")) {
					info.put("status", "2");
					info.put("message", "id is required");
					return info;
				}
				
				if (request.getExName()== null|| request.getExName().equals("")|| request.getExName().equals("NA")) {
					info.put("status", "2");
					info.put("message", "Name is required");
					return info;
				}
				
				if (request.getExEmail() == null|| request.getExEmail().equals("")||request.getExEmail().equals("NA")) {
					info.put("status", "2");
					info.put("message", "Email is required");
					return info;
				}
				
				if (request.getExContactDetails() == null|| request.getExContactDetails().equals("")||request.getExContactDetails().equals("NA")) {
					info.put("status", "2");
					info.put("message", "Mobile is required");
					return info;
				}
			
		  Optional<Staffpersonal> Staffpersonal = super.staffpersonal.findById(request.getId()); 
		  if (!Staffpersonal.isPresent()) {
			  info.put("status", "2"); 
			  info.put("message",  "Staff id not present");
			  return info; 
			  }
		  Date updatedate =new Date();
		 Date date = new Date(); 
		 int updatresult =  super.staffpersonal.updateStaffpersonal(request.getExName(),
		 request.getExEmail(), 
		 request.getExContactDetails(), request.isExIsActive(), request.getId() ,request.getExCity(),request.getExAddress(),date1.parse(request.getExDateOfBirth()),request.getExGender(),request.getExState(),request.getExEmployeeId(),updatedate,request.getExDateOfJoing(),request.getExNameInHindi() ,request.getInvigilator(),request.getExShortName()); 
		 if(updatresult == 0) {
			 info.put("status", "2");
			 info.put("message", "Something went wrong updateStaffpersonal ");
			 return info; 
		 }
				int empldetails = super.staffEmpDetails.updateStaffempldetails(request.getExAdhaarNumber(),request.getExBankAccountNo(), request.getExBankName(), request.getExIfscCode() ,request.getExPanNumber() ,request.getExQualification(),request.getExSkill() , request.getExNature() , request.getExBloodGroup(),request.getId());
				if (empldetails == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong updateStaffempldetails ");
					return info;
				}
		
				info.put("status", "1");
				info.put("message", "Staff personal details updated successfully");
				return info;
		  } catch (Exception e) { 
			  e.printStackTrace();
			  logger.error("Exception occured" + e); 
			  StringWriter errors = new StringWriter();
			  e.printStackTrace(new PrintWriter(errors));
		  logger.error(errors.toString()); 
		  info.put("status", "0"); 
		  info.put("message",
		 "Something went wrong");
		  return info; 
		  }
		 
		
	}

	@Override
	public Map<String, String> deleteStaff(CreateStaffRequest request) {
		/*
		 * Map<String, String> info = new LinkedHashMap<>(); try {
		 * Optional<Staffpersonal> task = super.staffpersonal.findById(request.getId());
		 * if (task.isPresent()) { if (task.get().isExIsDelete()) { info.put("status",
		 * "2"); info.put("message", "Staff already deleted"); return info; } Boolean
		 * exIsDelete = true; Boolean is_active = false; int result =
		 * super.staffpersonal.updateStafffordelete(exIsDelete, is_active,
		 * task.get().getId()); if (result == 0) { info.put("status", "2");
		 * info.put("message", "Something went wrong"); return info; }
		 * info.put("status", "1"); info.put("message", "Staff deleted successfully");
		 * return info; } info.put("status", "2"); info.put("message",
		 * "Staff id not present"); return info; } catch (Exception e) {
		 * logger.error("Exception occured" + e); StringWriter errors = new
		 * StringWriter(); e.printStackTrace(new PrintWriter(errors));
		 * logger.error(errors.toString()); info.put("status", "0"); info.put("message",
		 * "Something went wrong"); return info; }
		 */
		return null;
	}

	@Override
	public Map<String, Object> getAllStaff(CreateStaffRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<Staffpersonal> tasks = super.staffpersonal.findByExIsDelete(false);
			if (tasks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Staff not created");
				return info;
			} else {
				List<StaffEmpDetails> task = super.staffEmpDetails.findByStaffpersonalExIsDelete(false);
				List dataList = new LinkedList();
				for (StaffEmpDetails e : task) {
					List designation = new LinkedList();
					List designationId = new LinkedList();
					Map<Object, Object> Staffpersonaldata = new HashMap<Object, Object>();
					SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");

					Staffpersonaldata.put("id", e.getId());
					Staffpersonaldata.put("exLoginName", e.getStaffpersonal().getExLoginName());
					Staffpersonaldata.put("exEmail", e.getStaffpersonal().getExEmail());
					Staffpersonaldata.put("exContactDetail", e.getStaffpersonal().getExContactDetails());
					Staffpersonaldata.put("exAddress", e.getStaffpersonal().getExAddress());
					Staffpersonaldata.put("exCity", e.getStaffpersonal().getExCity());
					Staffpersonaldata.put("exState", e.getStaffpersonal().getExState());
					Staffpersonaldata.put("College", e.getStaffpersonal().getColleges().getExName());
					Staffpersonaldata.put("CollegeId", e.getStaffpersonal().getColleges().getId());
					Staffpersonaldata.put("Degree", e.getStaffpersonal().getDegree().getExName());
					Staffpersonaldata.put("DegreeId", e.getStaffpersonal().getDegree().getId());
					Staffpersonaldata.put("Programmes", e.getStaffpersonal().getProgrammes().getExIdentifier());
					Staffpersonaldata.put("ProgrammesId", e.getStaffpersonal().getProgrammes().getId());
					Staffpersonaldata.put("employeeId", e.getStaffpersonal().getExEmployeeId());
					Staffpersonaldata.put("exAdhaarNumber", e.getExAdhaarNumber());
					Staffpersonaldata.put("exBankAccountNo", e.getExBankAccountNo());
					Staffpersonaldata.put("exBankName", e.getExBankName());
					Staffpersonaldata.put("exIfscCode", e.getExIfscCode());
					
					Staffpersonaldata.put("exBloodGroup", e.getExBloodGroup());
					Staffpersonaldata.put("exNature", e.getExNature());
					Staffpersonaldata.put("exShortName", e.getStaffpersonal().getExShortName());
					Staffpersonaldata.put("exPanNumber", e.getExPanNumber());
					Staffpersonaldata.put("exSkill", e.getExSkill());
					Staffpersonaldata.put("Stafftype", e.getStaffpersonal().getStafftype().getExName());
					Staffpersonaldata.put("exCreateDate", e.getStaffpersonal().getExCreateDate() == null ? null
							: date1.format(e.getStaffpersonal().getExCreateDate()));
					Staffpersonaldata.put("exUpdateDate", e.getStaffpersonal().getExUpdateDate() == null ? null
							: date1.format(e.getStaffpersonal().getExUpdateDate()));

					Staffpersonaldata.put("exDateOfBirth", e.getStaffpersonal().getExDateOfBirth() == null ? null
							: date1.format(e.getStaffpersonal().getExDateOfBirth()));
					Staffpersonaldata.put("exDateOfJoin", e.getStaffpersonal().getExDateOfJoing());
					Staffpersonaldata.put("StafftypeId", e.getStaffpersonal().getStafftype().getExName());
					Staffpersonaldata.put("StafftypeId", e.getStaffpersonal().getStafftype().getId());
					Staffpersonaldata.put("exQualification", e.getExQualification());
					Staffpersonaldata.put("Department", e.getStaffpersonal().getDepartment().getExIdentifier());
					Staffpersonaldata.put("DepartmentId", e.getStaffpersonal().getDepartment().getId());
					Staffpersonaldata.put("exName", e.getStaffpersonal().getExName());
					Staffpersonaldata.put("exLoginName", e.getStaffpersonal().getExLoginName());
					Staffpersonaldata.put("exGender", e.getStaffpersonal().getExGender());
					Staffpersonaldata.put("invigilator", e.getStaffpersonal().getInvigilator());
					for (int i = 0; i < e.getStaffpersonal().getDesignation().size(); i++) {
						designation.add(e.getStaffpersonal().getDesignation().get(i).getExName());
						designationId.add(e.getStaffpersonal().getDesignation().get(i).getId());
					}
					Staffpersonaldata.put("Designation", designation);
					Staffpersonaldata.put("DesignationId", designationId);

					dataList.add(Staffpersonaldata);
				}
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> updateStudentInternalMarks(InternalMarksRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		return info;
		
	}

	

	@Override
	public Map<String, String> createExamAttendance(ExamAttendanceRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			if (request.getRegistrationType() == null || request.getRegistrationType().equals("")) {
				info.put("status", "2");
				info.put("message", "RegistrationType id is required");
				return info;
			}
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}

			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(), false,true);
			if (!courses.isPresent()) {
				info.put("status", "2");
				info.put("message", "courses not  present");
				return info;

			}
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}
			Optional<ProgrammeYear> programyear = super.programmeYear.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeYear(), false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "programyear not  present");
				return info;

			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}
			Optional<RoomMaster> room = super.roomMaster.findByExIsDeleteAndExIsActiveAndId(false, true,request.getRoomId());
			if (!room.isPresent()) {
				info.put("status", "2");
				info.put("message", "room not present");
				return info;
			}
			Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSemester());
			if (!sem.isPresent()) {
				info.put("status", "2");
				info.put("message", "semester not present");
				return info;
			}

			Optional<ExamAnnouncement> result = super.examAnnouncement.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}

			List<ExamAcademicYearProgrammes> examAcaprogram = super.examAcademicYearProgrammes.findByAcademicYearIdAndExamAnnouncementIdAndProgrammesId(request.getAcademicYear(),request.getExamAnnouncement(), request.getProgrammes());
			if (examAcaprogram.size() <= 0 || !examAcaprogram.get(0).getExIsTimeTable()) {
				info.put("status", "2");
				info.put("message", "TimeTable not generate for selected Programmes");
				return info;
			}

			Optional<Studentadmission> getExStudentIdFrom = super.studentadmission.findByExIsDeleteAndExIsActiveAndExRollNo(false, true, request.getExStudentIdFrom());
			if(!getExStudentIdFrom.isPresent()) {
				info.put("status", "2");
				info.put("message", "Student Id From not present");
				return info;
			}
			
			
			Optional<Studentadmission> getExStudentIdTo = super.studentadmission.findByExIsDeleteAndExIsActiveAndExRollNo(false, true, request.getExStudentIdTo());			
			if(!getExStudentIdTo.isPresent()) {
				info.put("status", "2");
				info.put("message", "Student Id To not present");
				return info;
			}
						
			List<CoursesRegistration> student1 = super.coursesRegistration.getStudentBetween(getExStudentIdFrom.get().getId(), getExStudentIdTo.get().getId(), request.getColleges(),request.getProgrammes(), request.getCourses(), request.getAcademicYear(),request.getRegistrationType(), request.getDegree() , request.getExamAnnouncement() , request.getSemester());
			if (student1.size() == 0) {
				info.put("status", "2");
				info.put("message", "Student not registered or approval process are pending");
				return info;
			}	
			
			if(student1.size() > room.get().getExRoomCapacity()) {
				info.put("status", "2");
				info.put("message", "Room capacity is:"+room.get().getExRoomCapacity());
				return info;
			}					
			// check room already allocated 			
			List<ExamAttendance> checkroom = super.examAttendance.findByExIsDeleteAndAcademicYearIdAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndRegistrationIdAndRoomIdId(false, request.getAcademicYear(), request.getColleges(), request.getCourses(), request.getDegree(), request.getExamAnnouncement(), request.getProgrammes(), request.getRegistrationType(), request.getRoomId());									
			if(checkroom.size() == room.get().getExRoomCapacity()) {
					info.put("status", "2");
					info.put("message", "selected room already full");
					return info;
				}					
			if(room.get().getExRoomCapacity() < (checkroom.size()+student1.size())){		
				info.put("status", "2");
				info.put("message", "Only "+(room.get().getExRoomCapacity()-checkroom.size())+" seat are avalable.");
				return info;
			}	
				
			List<RegistrationType> registration = super.registrationType.findByIdAndExIsDelete(request.getRegistrationType(), false);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType id not present");
				return info;
			}
			Optional<Stream> stream = super.stream.findByIdAndExIsDeleteAndExIsActive(request.getStream(), false, true);
			if (!stream.isPresent()) {
				info.put("status", "2");
				info.put("message", "stream not  present");
				return info;
			}
			User user1 = null;
			if (request.getUser() == null || request.getUser().equals("")) {
				// user1.setUser(null);
			} else {
				List<User> user = super.user.findByIdAndExIsDelete(request.getUser(), false);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
				user1 = user.get(0);
			}		
			Boolean is_exsit = false;
			Date date = new Date();
			for (CoursesRegistration e : student1) {			
				List<ExamAttendance> attendenceval = super.examAttendance.findByExIsDeleteAndAcademicYearIdAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndRegistrationIdAndDepartmentIdAndStudentadmissionId(
								false, request.getAcademicYear(), request.getColleges(), request.getCourses(),
								request.getDegree(), request.getExamAnnouncement(), request.getProgrammes(),
								request.getRegistrationType(), request.getDepartment(), e.getStudentadmission().getId());
				if (attendenceval.size() > 0) {
					info.put("status", "2");
					info.put("message", "Student already present");
					// is_exsit = false;
					// return info;
				} else {
					is_exsit = true;
					Long privailageid = 42L;
					User userid = super.commonHelper.getuser(request.getUser());
					String Description = request.toString();
					Boolean audit = super.commonHelper.saveauditlogdetails(false, Description, userid, privailageid);

					ExamAttendance examat = new ExamAttendance();
					examat.setUser(user1);
					examat.setAcademicYear(academicYearid.get());
					examat.setColleges(collage.get());
					examat.setDegree(degree.get());
					examat.setStream(stream.get());
					examat.setExamAnnouncement(result.get());
					examat.setProgrammes(Prog.get());
					examat.setCourses(courses.get());
					examat.setDepartment(dept.get());
					examat.setRoomId(room.get());
					examat.setSemester(sem.get());
					examat.setExCreateDate(date);
					examat.setStream(stream.get());
					examat.setExReportType(request.getExReportType());;
					examat.setRoomId(room.get());
					examat.setStudentadmission(e.getStudentadmission());
					examat.setExRollNo(e.getStudentadmission().getExRollNo());
					examat.setExIsActive(true);
					examat.setExIsDelete(false);
					String barcode = randomAlphaNumeric(super.examAttendance.getMaxId(),e.getId(), request.getRegistrationType());
					System.out.println(">>>>>>>>>>" + super.coursesRegistration.getMaxId());
					examat.setExBarcode(barcode);
					examat.setRegistration(registration.get(0));
					super.examAttendance.save(examat);

					Boolean retvalue = SaveBarcodeDetails(registration.get(0), programyear.get(), academicYearid.get(),
							dept.get(), collage.get(), degree.get(), result.get(), Prog.get(), sem.get(), courses.get(),
							date, barcode, null, request, examat, e.getStudentadmission(),e.getStudentadmission().getExRollNo());
					System.out.println("empgcg" + registration);
					Boolean retvalue1 = SaveExamAttendanceLogDetails(registration.get(0), programyear.get(),
							academicYearid.get(), dept.get(), collage.get(), degree.get(), result.get(), Prog.get(),
							sem.get(), courses.get(), date, barcode, null, request, examat,
							stream.get(), e.getStudentadmission(), barcode);
				}
			}
			if (is_exsit) {
				info.put("status", "1");
				info.put("message", "Exam Attendance created successfully");
				return info;

			} else {
				info.put("status", "2");
				info.put("message", "Exam Attendance already present");
				return info;
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}
	

	private String randomAlphaNumeric(Long maxId, Long maxId2, Long registrationType) {

		// private synchronized String randomAlphaNumeric(Long studentid, Long examid,
		// Long registrationid) {
		String retvalue = "";
		try {
			String sid = String.format("%0" + 5 + "d", maxId + 1);
			String eid = String.format("%0" + 3 + "d", maxId2);
			System.out.println("check" + eid);
			// String type = "1";

			retvalue = "00" + sid + "0" + eid + "" + registrationType;
			System.out.println("><><>>>>>>>>>>>>>>.." + retvalue);
			return retvalue;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
		}
		return retvalue;
	}

	private Boolean SaveBarcodeDetails(RegistrationType registrationType, ProgrammeYear programmeYear,
			AcademicYear academicYear, Department department, Colleges colleges, Degree degree,
			ExamAnnouncement examAnnouncement, Programmes programmes, Semster semster, Courses courses, Date date,
			String barcode, Object object, ExamAttendanceRequest request, ExamAttendance examat,
			Studentadmission studentadmission, String rollno) {

		Map<String, String> info = new LinkedHashMap<>();
		try {
			Date date1 = new Date();
			ExamBarcodes exambarcodes = new ExamBarcodes();
			exambarcodes.setExCreateDate(date1);
			exambarcodes.setAcademicYear(academicYear);
			exambarcodes.setRegistrationType(registrationType);
			exambarcodes.setCourses(courses);
			exambarcodes.setExIsReevaluated(false);
			exambarcodes.setColleges(colleges);
			exambarcodes.setDepartment(department);
			exambarcodes.setDegree(degree);
			exambarcodes.setProgrammes(programmes);
			exambarcodes.setSemester(semster);
			exambarcodes.setStudentadmission(studentadmission);
			exambarcodes.setProgrammeYear(programmeYear);
			exambarcodes.setExTimeLimit(request.getExTimeLimit());
			exambarcodes.setExBarcode(barcode);
			exambarcodes.setExIsAttendance(false);
			exambarcodes.setExIsEvaluated(0);
			exambarcodes.setExTimeTaken(request.getExTimeTaken());
			exambarcodes.setExIsActive(true);
			exambarcodes.setExIsDelete(false);
			exambarcodes.setExRollNo(rollno);
			exambarcodes.setExAnsBookletPath(request.getExAnsBookletPath());
			exambarcodes.setExEvaluatedPath(request.getExEvaluatedPath());
			exambarcodes.setExamAnnouncement(examAnnouncement);
			super.ExamBarcodes.save(exambarcodes);

			info.put("status", "0");
			info.put("message", "record inserted successfully");
			return true;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return false;
		}

	}

	private Boolean SaveExamAttendanceLogDetails(RegistrationType registrationType, ProgrammeYear programmeYear,
			AcademicYear academicYear, Department department, Colleges colleges, Degree degree,
			ExamAnnouncement examAnnouncement, Programmes programmes, Semster semster, Courses courses, Date date, String barcode, Object object, ExamAttendanceRequest request,
			ExamAttendance examat, Stream stream, Studentadmission studentadmission, String barcode2) {

		Map<String, String> info = new LinkedHashMap<>();
		try {
			List<User> user = super.user.findByIdAndExIsDelete(request.getUser(), false);
			Date date1 = new Date();
			ExamAttendanceLog examlog = new ExamAttendanceLog();
			examlog.setUser(user.get(0));
			examlog.setExCreateDate(date1);
			examlog.setAcademicYear(academicYear);
			examlog.setRegistration(registrationType);
			examlog.setColleges(colleges);
			examlog.setCourses(courses);
			examlog.setExamAnnouncement(examAnnouncement);
			examlog.setDepartment(department);
			examlog.setDegree(degree);
			examlog.setProgrammes(programmes);
			examlog.setSemster(semster);
			examlog.setProgrammeYear(programmeYear);
			examlog.setDepartment(department);
			examlog.setStream(stream);
			examlog.setExReportType(request.getExReportType());
			examlog.setStudentadmission(studentadmission);
			examlog.setExBarcode(barcode2);
			super.attendancelog.save(examlog);
			info.put("status", "0");
			info.put("message", "record inserted successfully");
			return true;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return false;
		}

	}

	@Override
	public Map<String, Object> checkAttendance(ExamAttendanceRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {		
			List<CoursesRegistration> student  =super.coursesRegistration.findByExIsDeleteAndExIsActiveAndProgrammesIdAndCollegesIdAndDegreeIdAndAcademicYearIdAndProgrammeYearIdAndSemesterIdAndDepartmentIdAndCoursesId(false, true, request.getProgrammes(), request.getColleges(),request.getDegree(),request.getAcademicYear(),request.getProgrammeYear(),request.getSemester(),request.getDepartment(),request.getCourses());
			if(student.size() <=0) {
				info.put("status", "2");
				info.put("message", "No record found");
				return info;				
			}			
			List<ExamAttendance> attndence = super.examAttendance.findByExIsDeleteAndAcademicYearIdAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndRegistrationId(false, request.getAcademicYear(), request.getColleges(), request.getCourses(),request.getDegree(), request.getExamAnnouncement(), request.getProgrammes(),request.getRegistrationType());
			if (attndence.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Exam Attendance not created");
			}

			if (student.size() == attndence.size()) {
				info.put("status", "1");
				info.put("message", "Exam Attendance already created");
			} else {
				info.put("status", "2");
				info.put("message", "Exam Attendance not created");
			}

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
		return info;
	}

	@Override
	public Map<String, Object> checkRoomCapacity(ExamAttendanceRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<RoomMaster> task = super.roomMaster.findByExIsDeleteAndExIsActiveAndCollegesId(false, true,request.getColleges());
			if (task.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Room not created");
				return info;
			}
			List dataList = new LinkedList();
			logger.info(">>>>>>>>>>>>>>>>>>"+task.size());
			for (RoomMaster e : task) {
				logger.info(">>>>>>>>>>>>>>>>>>"+e.getExName());
				Map<Object, Object> RoomMasterdata = new HashMap<Object, Object>();
				RoomMasterdata.put("id", e.getId());
				RoomMasterdata.put("roomName", e.getExName());
				RoomMasterdata.put("colleges", e.getColleges().getExName());
				RoomMasterdata.put("roomNumber", e.getExRoomNumber());
				RoomMasterdata.put("roomCapacity", e.getExRoomCapacity());
				// check Avalability for seates
				List<ExamAttendance> checkroom = super.examAttendance
						.findByExIsDeleteAndAcademicYearIdAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndRegistrationIdAndRoomIdId(
								false, request.getAcademicYear(), request.getColleges(), request.getCourses(),
								request.getDegree(), request.getExamAnnouncement(), request.getProgrammes(),
								request.getRegistrationType(), e.getId());
				if (checkroom.size() > 0) {
					RoomMasterdata.put("availableSeat", e.getExRoomCapacity() - checkroom.size());
				} else {
					RoomMasterdata.put("availableSeat", e.getExRoomCapacity());
				}
				dataList.add(RoomMasterdata);
			}
			info.put("status", "1");
			info.put("details", dataList);
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Boolean validateStudentInfo(CreateStudentRequest request, Studentadmission admision) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {

			Date date = new Date();

			Studentpersonal studentpersonal = new Studentpersonal();
			// studentpersonal.setExIsActive(request.getExIsActive());
			// studentpersonal.setExIsDelete(false);
			studentpersonal.setExCreateDate(date);
			studentpersonal.setStudentadmission(admision);
			studentpersonal.setExContactDetails(request.getExContactDetails());
			studentpersonal.setExGender(request.getExGender());
			studentpersonal.setExNationality(request.getExNationality());
			studentpersonal.setExNativeState(request.getExNativeState());
			studentpersonal.setExReligion(request.getExReligion());
			studentpersonal.setExMotherName(request.getExMotherTounge());
			studentpersonal.setExWeight(request.getExWeight());
			studentpersonal.setExHeight(request.getExHeight());
			studentpersonal.setExBloodGroup(request.getExBloodGroup());
			studentpersonal.setExEmailId(request.getExEmailId());
			studentpersonal.setExAdhaarNumber(request.getExAdhaarNumber());
			studentpersonal.setExIdentificationMark(request.getExIdentificationMark());
			studentpersonal.setExFatherName(request.getExFatherName());
			studentpersonal.setExFatherNameInHindi(request.getExFatherName());
			studentpersonal.setExParentContactDetails(request.getExParentContactDetails());
			studentpersonal.setExAnnualIncome(request.getExAnnualIncome());
			studentpersonal.setExFatherOccupation(request.getExFatherOccupation());
			studentpersonal.setExMotherName(request.getExMotherName());
			studentpersonal.setExMotherNameInHindi(request.getExMotherNameInHindi());
			studentpersonal.setExLocalGurdian(request.getExLocalGurdian());
			studentpersonal.setExlocalGurdianInHindi(request.getExlocalGurdianInHindi());
			studentpersonal.setExPermanentAddress(request.getExPermanentAddress());
			studentpersonal.setExDateOfBirth(request.getExDateOfBirth());
			studentpersonal.setExMotherTounge(request.getExMotherTounge());
			studentpersonal.setExPresentAddress(request.getExPresentAddress());

			super.studentpersonal.save(studentpersonal);
			return true;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return false;
		}

	}

	@Override
	public Map<String, Object> getAllStudentProfile(CreateStudentRequest request) {
		// TODO Auto-generated method stub
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<Studentpersonal> task = super.studentpersonal.findByStudentadmissionExIsDelete(false);
			if (task.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Student not created");
				return info;
			} else {
				List dataList = new LinkedList();
				for (Studentpersonal e : task) {
					List stmtype = new LinkedList();
					List stmTypeId = new LinkedList();
					Map<Object, Object> Studentadmissiondata = new HashMap<Object, Object>();
					Studentadmissiondata.put("id", e.getId());
					//Studentadmissiondata.put("exIsDelete", e.getStudentadmission().getExIsDelete());
					//Studentadmissiondata.put("exIsActive", e.getStudentadmission().getExIsActive());
					Studentadmissiondata.put("College", e.getStudentadmission().getColleges().getExName());
					//Studentadmissiondata.put("CollegeId", e.getStudentadmission().getColleges().getId());
					Studentadmissiondata.put("Degree", e.getStudentadmission().getDegree().getExName());
					//Studentadmissiondata.put("DegreeId", e.getStudentadmission().getDegree().getId());
					Studentadmissiondata.put("Programmes", e.getStudentadmission().getProgrammes().getExIdentifier());
					//Studentadmissiondata.put("ProgrammesId", e.getStudentadmission().getProgrammes().getId());
					Studentadmissiondata.put("Department", e.getStudentadmission().getDepartment().getExName());
					//Studentadmissiondata.put("DepartmentId", e.getStudentadmission().getDepartment().getId());
					Studentadmissiondata.put("Batch", e.getStudentadmission().getBatch().getExName());
					//Studentadmissiondata.put("BatchId", e.getStudentadmission().getBatch().getId());
					Studentadmissiondata.put("ProgramType", e.getStudentadmission().getProgramtype().getExName());
					//Studentadmissiondata.put("ProgramTypeId", e.getStudentadmission().getProgramtype().getId());
					Studentadmissiondata.put("Category", e.getStudentadmission().getCategory() == null ? null: e.getStudentadmission().getCategory().getExName());
					//Studentadmissiondata.put("CategoryId", e.getStudentadmission().getCategory() == null ? null: e.getStudentadmission().getCategory().getId());
					//Studentadmissiondata.put("allocatedCategoryId",e.getStudentadmission().getAllocatedCategory().getId());
					Studentadmissiondata.put("allocatedCategory",e.getStudentadmission().getAllocatedCategory().getExName());
					
					Studentadmissiondata.put("section", e.getStudentadmission().getSection() == null ? "NA": e.getStudentadmission().getSection().getExName());
				//	Studentadmissiondata.put("sectionId", e.getStudentadmission().getSection() == null ? null: e.getStudentadmission().getSection().getId());
				/*	Studentadmissiondata.put("stream", e.getStudentadmission().getStream() == null ? null
							: e.getStudentadmission().getStream().get(0).getExName());
					Studentadmissiondata.put("streamId", e.getStudentadmission().getStream() == null ? null
							: e.getStudentadmission().getStream().get(0).getId());*/
					
					for (int i = 0; i < e.getStudentadmission().getStream().size(); i++) {
						stmtype.add(e.getStudentadmission().getStream().get(i).getExName());
					//	stmTypeId.add(e.getStudentadmission().getStream().get(i).getId());
					}

					Studentadmissiondata.put("stream", stmtype);
					//Studentadmissiondata.put("streamId", stmTypeId);
					
					
					
					//Studentadmissiondata.put("exIsActive", e.getStudentadmission().getExIsActive());

					Studentadmissiondata.put("exName", e.getStudentadmission().getExName());
					//Studentadmissiondata.put("exNameInHindi", e.getStudentadmission().getExNameInHindi());
					Studentadmissiondata.put("exEnrollementNo", e.getStudentadmission().getExEnrollementNo());
					Studentadmissiondata.put("exRollNo", e.getStudentadmission().getExRollNo());

					//Studentadmissiondata.put("exIsActive", e.getStudentadmission().getExIsActive());
					//Studentadmissiondata.put("exBloodGroup", e.getExBloodGroup());
					//Studentadmissiondata.put("exAdhaarNumber", e.getExAdhaarNumber());
					//Studentadmissiondata.put("exGender", e.getExGender());
					//Studentadmissiondata.put("exDateOfBirth", e.getExDateOfBirth());
					//Studentadmissiondata.put("exEmailId", e.getExEmailId());
					//Studentadmissiondata.put("exReligion", e.getExReligion());
					//Studentadmissiondata.put("exMotherTounge", e.getExMotherTounge());
					//Studentadmissiondata.put("exNationality", e.getExNationality());
					//Studentadmissiondata.put("exNativeState", e.getExNativeState());
					//Studentadmissiondata.put("exFatherName", e.getExFatherName());
					//Studentadmissiondata.put("exFatherNameInHindi", e.getExFatherNameInHindi());
					//Studentadmissiondata.put("exMotherName", e.getExMotherName());
					//Studentadmissiondata.put("exMotherNameInHindi", e.getExMotherNameInHindi());
					//Studentadmissiondata.put("exMotherTounge", e.getExMotherTounge());
					//Studentadmissiondata.put("exLocalGurdian", e.getExLocalGurdian());
					//Studentadmissiondata.put("exlocalGurdianInHindi", e.getExlocalGurdianInHindi());
					//Studentadmissiondata.put("exPermanentAddress", e.getExPermanentAddress());
					//Studentadmissiondata.put("exPresentAddress", e.getExPresentAddress());
					//Studentadmissiondata.put("exIdentificationMark", e.getExIdentificationMark());
					//Studentadmissiondata.put("exContactDetails", e.getExContactDetails());
					//Studentadmissiondata.put("exParentContactDetails", e.getExParentContactDetails());
					//Studentadmissiondata.put("exAnnualIncome", e.getExAnnualIncome());
					//Studentadmissiondata.put("exFatherOccupation", e.getExFatherOccupation());
					//Studentadmissiondata.put("exWeight", e.getExWeight());
					//Studentadmissiondata.put("exHeight", e.getExHeight());
					Studentadmissiondata.put("exStudyStatus", e.getStudentadmission().getExStudyStatus());
					dataList.add(Studentadmissiondata);
				}
				info.put("status", "1");
				info.put("message", "success");

				info.put("details", dataList);
				return info;
			}

			
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			e.printStackTrace();
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> deleteStudentProfile(CreateStudentRequest request) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Map<String, String> createStaff(CreateStaffRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();

		try {

			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent() || !collage.get().getExIsActive()) {
				info.put("status", "2");
				info.put("message", "College not present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "degree not present");
				return info;
			}
			Optional<Department> department = super.department.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getDepartment());
			if (!department.isPresent()) {
				info.put("status", "2");
				info.put("message", "Department not present");
				return info;
			}

			//Optional<Role> role = super.role.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDepartment());
			/*
			 * if (!role.isPresent()) { info.put("status", "2"); info.put("message",
			 * "role not present"); return info; }
			 */

			Optional<StaffType> staffType = super.staffType.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getStafftype());
			if (!staffType.isPresent()) {
				info.put("status", "2");
				info.put("message", "StaffType not Present");
				return info;
			}
			Optional<Programmes> programmes = super.programmes
					.findByIdAndExIsDeleteAndExIsActive(request.getProgrammes(), false, true);
			if (!programmes.isPresent()) {
				info.put("status", "2");
				info.put("message", "programmes not present");
				return info;
			}

			List<Designation> designation = super.designation.findByExIsDeleteAndExIsActiveAndIdInAndDepartmentId(false,
					true, request.getDesignation(), department.get().getId());
			if (designation.size() != request.getDesignation().size()) {
				info.put("status", "2");
				info.put("message", ":Designation with particual Department not present ");
				return info;
			}

			List<Staffpersonal> employee = super.staffpersonal
					.findByExEmployeeIdAndExIsDelete(request.getExEmployeeId().toString(), false);
			if (employee.size() > 0) {
				info.put("status", "2");
				info.put("message", "EmployeeId is already exist");
				System.out.println(">>request" + staffpersonal);
				return info;
			}

			List<Staffpersonal> loginname = super.staffpersonal
					.findByExLoginNameAndExIsDelete(request.getExLoginName().trim(), false);
			if (loginname.size() > 0) {
				info.put("status", "2");
				info.put("message", "LoginName is already exist");
				return info;
			}
			List<Designation> des = new ArrayList<Designation>();
			for (int i = 0; i < request.getDesignation().size(); i++) {
				Long number = request.getDesignation().get(i);
				Long col = new Long(number);
				Optional<Designation> designationre = super.designation
						.findByExIsDeleteAndExIsActiveAndIdAndDepartmentId(false, true, col, department.get().getId());
				des.add(designationre.get());
			}
			String dcrypt = EncryptionAndDecryption.getDecryptedStringaddhexkey(request.getExPassword());
			
			Long privailageid = 28L;
			User userid = super.commonHelper.getuser(request.getUsers());
			String Description = university.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(false, Description, userid, privailageid);
			Date date = new Date();
			SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");
			Date dod = date1.parse(request.getExDateOfBirth());
			Staffpersonal staffpersonal = new Staffpersonal();
			staffpersonal.setColleges(collage.get());
			staffpersonal.setDegree(degree.get());
			staffpersonal.setDepartment(department.get());
			staffpersonal.setStafftype(staffType.get());
			staffpersonal.setDesignation(des);
			staffpersonal.setExName(request.getExName());
			staffpersonal.setExNameInHindi(request.getExNameInHindi());
			staffpersonal.setExShortName(request.getExShortName());
			staffpersonal.setExDateOfBirth(dod);
			staffpersonal.setExDateOfJoing(request.getExDateOfJoing());
			staffpersonal.setExContactDetails(request.getExContactDetails());
			staffpersonal.setExAddress(request.getExAddress());
			staffpersonal.setExCity(request.getExCity());
			staffpersonal.setExEmail(request.getExEmail());
			staffpersonal.setExEmployeeId(request.getExEmployeeId());
			staffpersonal.setExCreateDate(date);
			staffpersonal.setExIsActive(request.isExIsActive());
			staffpersonal.setExIsDelete(false);
			staffpersonal.setProgrammes(programmes.get());
			staffpersonal.setExLoginName(request.getExLoginName());
			staffpersonal.setExPassword(dcrypt);
			staffpersonal.setExPhoto(request.getExPhoto());
			staffpersonal.setExState(request.getExState());
			staffpersonal.setExCity(request.getExCity());
			staffpersonal.setExGender(request.getExGender());
			staffpersonal.setInvigilator(request.getInvigilator());
			super.staffpersonal.save(staffpersonal);
			saveStaffDetails(request, staffpersonal, des, staffType);

			info.put("status", "1");
			info.put("message", "Staff created successfully");
			info.put("id", staffpersonal.getId().toString());
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace();
			// e.printStackTrace(e);
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}

	}

	private Map<String, String> saveStaffDetails(CreateStaffRequest request, Staffpersonal staffpersonal,
			List<Designation> des, Optional<StaffType> staffType) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			// SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");
			StaffEmpDetails StaffEmpDetails = new StaffEmpDetails();
			StaffEmpDetails.setExBankName(request.getExBankName());
			StaffEmpDetails.setExAdhaarNumber(request.getExAdhaarNumber());
			StaffEmpDetails.setExBankAccountNo(request.getExBankAccountNo());
			// StaffEmpDetails.setExDateOfJoing(request.getExDateOfJoing()));
			// StaffEmpDetails.setDiscipline(discipline.get());
			// StaffEmpDetails.setExDesignation(designation.get());
			StaffEmpDetails.setExIfscCode(request.getExIfscCode());
			StaffEmpDetails.setExPanNumber(request.getExPanNumber());
			StaffEmpDetails.setExNature(request.getExNature());
			StaffEmpDetails.setExBloodGroup(request.getExBloodGroup());
			StaffEmpDetails.setExSkill(request.getExSkill());
			StaffEmpDetails.setStaffpersonal(staffpersonal);
			StaffEmpDetails.setExQualification(request.getExQualification());
			// StaffEmpDetails.setStaffpersonal(staffpersonal);

			super.staffEmpDetails.save(StaffEmpDetails);

			info.put("status", "1");
			info.put("message", "success");
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;

		}
	}

	@Override
	public Map<String, String> saveStaffDetails(CreateStaffRequest request, Staffpersonal staffpersonal,
			Optional<Designation> designation, Optional<StaffType> safftype) {
		// TODO Auto-generated method stub
		/*
		 * Map<String, String> info = new LinkedHashMap<>(); try { //SimpleDateFormat
		 * date1 = new SimpleDateFormat("dd/MM/yyyy"); StaffEmpDetails StaffEmpDetails =
		 * new StaffEmpDetails();
		 * StaffEmpDetails.setExBankName(request.getExBankName());
		 * StaffEmpDetails.setExAdhaarNumber(request.getExAdhaarNumber());
		 * StaffEmpDetails.setExBankAccountNo(request.getExBankAccountNo());
		 * //StaffEmpDetails.setExDateOfJoing(request.getExDateOfJoing())); //
		 * StaffEmpDetails.setDiscipline(discipline.get());
		 * //StaffEmpDetails.setExDesignation(designation.get());
		 * StaffEmpDetails.setExIfscCode(request.getExIfscCode());
		 * StaffEmpDetails.setExPanNumber(request.getExPanNumber());
		 * StaffEmpDetails.setExSkill(request.getExSkill());
		 * StaffEmpDetails.setStaffpersonal(staffpersonal);
		 * StaffEmpDetails.setExQualification(request.getExQualification());
		 * //StaffEmpDetails.setStaffpersonal(staffpersonal);
		 * 
		 * super.staffEmpDetails.save(StaffEmpDetails);
		 * 
		 * info.put("status", "1"); info.put("message", "success"); return info;
		 * 
		 * } catch (Exception e) { logger.error("Exception occured" + e); StringWriter
		 * errors = new StringWriter(); e.printStackTrace(new PrintWriter(errors));
		 * logger.error(errors.toString()); info.put("status", "0"); info.put("message",
		 * "something went wrong"); return info; }
		 * 
		 */ return null;

	}

	@Override
	public Map<String, String> createStudentEnrollementNo(StudentEnrollementNoRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {

			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "degree Id not Present");
				return info;
			}
			Optional<StudentEnrollementNo> duplicates = super.studentEnrollment
					.findByExIsDeleteAndExIsActiveAndCollegesIdAndDegreeIdAndExIdStartWith(false, true, request.getColleges(),
							request.getDegree(),request.getExIdStartWith());
			if (duplicates.isPresent()) {
				info.put("status", "2");
				info.put("message", duplicates.get().getExName() + ": StudentEnrollement format already Present");
				return info;
			}

			Long privailageid = 12L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(false, Description, userid, privailageid);

			StudentEnrollementNo studentidformate = new StudentEnrollementNo();
			Date date = new Date();
			studentidformate.setExIsDelete(false);
			studentidformate.setExIsActive(request.getExIsActive());
			studentidformate.setExIdStartWith(request.getExIdStartWith());
			studentidformate.setExName(request.getExName());
			studentidformate.setExCreateDate(date);
			studentidformate.setDegree(degree.get());
			studentidformate.setColleges(collage.get());
			logger.info("Insert  Record " + studentidformate.toString());
			studentEnrollment.save(studentidformate);

			info.put("status", "1");
			info.put("message", request.getExName() + " : format created successfully");
			info.put("id", studentidformate.getId().toString());

			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getStudentEnrollementNo(StudentEnrollementNoRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<StudentEnrollementNo> task = super.studentEnrollment.findByExIsDelete(false);
			if (task.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No record found");
				return info;
			} else {
				List dataList = new LinkedList();
				for (StudentEnrollementNo e : task) {
					Map<Object, Object> studentEnrollment = new HashMap<Object, Object>();
					studentEnrollment.put("id", e.getId());
					studentEnrollment.put("colleges", e.getColleges().getExName());
					studentEnrollment.put("collegesId", e.getColleges().getId());
					studentEnrollment.put("degree", e.getDegree().getExName());
					studentEnrollment.put("degreeId", e.getDegree().getId());
					studentEnrollment.put("exIsActive", e.isExIsActive());
					// studentEnrollment.put("exDepartmentId", e.getDepartment().getId());
					// studentEnrollment.put("exDepartment", e.getDepartment().getId());
					studentEnrollment.put("exName", e.getExName());
					studentEnrollment.put("exIdStartWith", e.getExIdStartWith());
					
					studentEnrollment.put("exCreateDate", e.getExCreateDate() == null ? "NA" : e.getExCreateDate().toString().substring(0, 10));
					studentEnrollment.put("exUpdateDate", e.getExUpdateDate() == null ? "NA" : e.getExUpdateDate().toString().substring(0, 10));
					dataList.add(studentEnrollment);
				}
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;
			}
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, String> createStudentRollNo(StudentRollNoRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {

			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "degree Id not Present");
				return info;
			}
			Optional<StudentRollNo> duplicates = super.studentRollNo
					.findByExIsDeleteAndExIsActiveAndCollegesIdAndDegreeIdAndExIdStartWith(false, true, request.getColleges(),
							request.getDegree(),request.getExIdStartWith());
			if (duplicates.isPresent()) {
				info.put("status", "2");
				info.put("message", duplicates.get().getExName() + ": StudentRollNo format already Present");
				return info;
			}
			Long privailageid = 25L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(false, Description, userid, privailageid);

			// User userid =CommonHelper.getuser(studentidrequest.getUser()) ;
			// String Description=studentidrequest.toString();
			// Boolean audit =CommonHelper.saveauditlogdetails(false , Description
			// ,userid,28L);
			StudentRollNo studentidformate = new StudentRollNo();
			Date date = new Date();
			studentidformate.setExIsDelete(false);
			studentidformate.setExIsActive(request.getExIsActive());
			studentidformate.setExIdStartWith(request.getExIdStartWith());
			studentidformate.setExName(request.getExName());
			studentidformate.setExCreateDate(date);
			studentidformate.setDegree(degree.get());
			studentidformate.setColleges(collage.get());
			logger.info("Insert  Record " + studentidformate.toString());
			studentRollNo.save(studentidformate);

			info.put("status", "1");
			info.put("message", request.getExName() + " : format created successfully");
			info.put("id", studentidformate.getId().toString());
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getstudentRollNo(StudentEnrollementNoRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<StudentRollNo> task = super.studentRollNo.findByExIsDelete(false);
			if (task.size() <= 0) {
				info.put("status", "2");
				info.put("message", "No record found");
				return info;
			} else {
				List dataList = new LinkedList();
				for (StudentRollNo e : task) {
					Map<Object, Object> studentEnrollment = new HashMap<Object, Object>();
					studentEnrollment.put("id", e.getId());
					studentEnrollment.put("colleges", e.getColleges().getExName());
					studentEnrollment.put("collegesId", e.getColleges().getId());
					studentEnrollment.put("degree", e.getDegree().getExName());
					studentEnrollment.put("degreeId", e.getDegree().getId());
					studentEnrollment.put("exIsActive", e.isExIsActive());
					// studentEnrollment.put("exDepartmentId", e.getDepartment().getId());
					// studentEnrollment.put("exDepartment", e.getDepartment().getId());
					studentEnrollment.put("exName", e.getExName());
					studentEnrollment.put("exIdStartWith", e.getExIdStartWith());
					studentEnrollment.put("exCreateDate", e.getExCreateDate() == null ? "NA" : e.getExCreateDate().toString().substring(0, 10));
					studentEnrollment.put("exUpdateDate", e.getExUpdateDate() == null ? "NA" : e.getExUpdateDate().toString().substring(0, 10));
			
					dataList.add(studentEnrollment);
				}
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;
			}
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, String> updatefeeHeadMaster(FeeHeadMasterRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			List<FeeHeadMaster> tasks = new ArrayList<FeeHeadMaster>();
			if (request.getExIsActive() == null) {
				info.put("status", "2");
				info.put("message", "IsActive is required 0/1");
				return info;
			}
			if (request.getExName() == null || request.getExName().equals("") || request.getExName().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Name is required");
				return info;
			}

		//	tasks = super.feeHeadMaster.findByExNameAndExIsDelete(request.getExName(), false);
			Date date = new Date();
			int updateresult = super.feeHeadMaster.Update(request.getExName(), request.getId(),request.getExIsActive(), request.getExDescription());
			if (updateresult == 0) {
				info.put("status", "2");
				info.put("message", "Something went wrong");
				return info;
			}

			info.put("status", "1");
			info.put("message", "FeeHeadmaster updated successfully");
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			e.printStackTrace();
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, String> feeHeadMaster(FeeHeadMasterRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			List<FeeHeadMaster> tasks = new ArrayList<FeeHeadMaster>();
			if (request.getExIsActive() == null) {
				info.put("status", "2");
				info.put("message", "IsActive is required 0/1");
				return info;
			}
			if (request.getExName() == null || request.getExName().equals("") || request.getExName().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Name is required");
				return info;
			}
			tasks = super.feeHeadMaster.findByExNameAndExIsDelete(request.getExName(), false);

			if (tasks.size() > 0) {
				info.put("status", "2");
				info.put("message", "FeeHeadMaster name already exists");
				return info;
			}
			
			request.setId(null);
			Date date = new Date();
			FeeHeadMaster fee = new FeeHeadMaster();
			fee.setExCreateDate(date);
			fee.setExIsDelete(false);
			fee.setExDescription(request.getExDescription());
			fee.setExIsActive(request.getExIsActive());
			fee.setExName(request.getExName());
			// fee.setFeetype(feetype.get());
			super.feeHeadMaster.save(fee);
			info.put("status", "1");
			info.put("message", "FeeHeadMaster created successfully");
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
		}
		return info;

	}

	@Override
	public Map<String, Object> getfeeHeadMaster(FeeHeadMasterRequest request) {
		// TODO Auto-generated method stub
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<FeeHeadMaster> tasks = super.feeHeadMaster.findByExIsDelete(false);
			if (tasks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "FeeHeadMaster not created");
				return info;
			} else {
				List dataList = new LinkedList();
				for (FeeHeadMaster e : tasks) {
					Map<Object, Object> FeeHeadMaster = new HashMap<Object, Object>();
					FeeHeadMaster.put("id", e.getId());
					FeeHeadMaster.put("exIsActive", e.getExIsActive());
					FeeHeadMaster.put("exIsDelete", e.getExIsDelete());
					FeeHeadMaster.put("exName", e.getExName());
					FeeHeadMaster.put("exDescription", e.getExDescription());

					dataList.add(FeeHeadMaster);
				}
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> deletefeeHeadMaster(FeeHeadMasterRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<FeeHeadMaster> task = super.feeHeadMaster.findById(request.getId());

			if (task.isPresent()) {
				if (task.get().getExIsDelete()) {
					info.put("status", "2");
					info.put("message", "Feeheadmaster already deleted");
					return info;
				}
				Boolean exIsDelete = true;
				Boolean is_active = false;
				int result = super.feeHeadMaster.deleteFeeHeadMaster(exIsDelete, is_active, task.get().getId());
				if (result == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "FeeHeadMaster deleted successfully");
				return info;
			}
			info.put("status", "2");
			info.put("message", "FeeHeadMaster not present");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> createfeeCategory(FeeCategoryRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			List<com.niftem.app.entity.FeeCategory> tasks = new ArrayList<com.niftem.app.entity.FeeCategory>();
			if (request.getExIsActive() == null) {
				info.put("status", "2");
				info.put("message", "IsActive is required 0/1");
				return info;
			}
			if (request.getExName() == null || request.getExName().equals("") || request.getExName().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Name is required");
				return info;
			}
			tasks = super.feecategory.findByExNameAndExIsDeleteAndFeeheadmasterId(request.getExName(), false , request.getFeeheadmaster());

			if (tasks.size() > 0) {
				info.put("status", "2");
				info.put("message", "feecategory name already exists");
				return info;
			}
			Optional<FeeHeadMaster> FeeHeadMaster = super.feeHeadMaster.findByIdAndExIsDeleteAndExIsActive(request.getFeeheadmaster(), false, true);
			if (!FeeHeadMaster.isPresent()) {
				info.put("status", "2");
				info.put("message", "FeeHeadMaster not present");
				return info;
			}
			
			
			
			Long privailageid = 40L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			request.setId(null);
			Date date = new Date();
			FeeCategory fees = new FeeCategory();
			fees.setFeeheadmaster(FeeHeadMaster.get());
			fees.setExCreateDate(date);
			fees.setExIsDelete(false);
			fees.setExName(request.getExName());
			fees.setExIsActive(request.getExIsActive());
			// fee.setFeetype(feetype.get());
			super.feecategory.save(fees);
			info.put("status", "1");
			info.put("message", "FeeCategory created successfully");
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
		}
		return info;

	}

	@Override
	public Map<String, String> updatefeeCategory(FeeCategoryRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			List<com.niftem.app.entity.FeeCategory> tasks = new ArrayList<com.niftem.app.entity.FeeCategory>();
			if (request.getExIsActive() == null) {
				info.put("status", "2");
				info.put("message", "IsActive is required 0/1");
				return info;
			}
			if (request.getExName() == null || request.getExName().equals("") || request.getExName().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Name is required");
				return info;
			}

			tasks = super.feecategory.findByExNameAndExIsDeleteAndFeeheadmasterId(request.getExName(), false , request.getFeeheadmaster());

			Optional<FeeHeadMaster> feetype = super.feeHeadMaster
					.findByIdAndExIsDeleteAndExIsActive(request.getFeeheadmaster(), false, true);
			if (!feetype.isPresent()) {
				info.put("status", "2");
				info.put("message", "Feeheadmaster not present");
				return info;
			}

			Date date = new Date();
			int updateresult = super.feecategory.Update(request.getExName(), request.getId(), request.getExIsActive());
			if (updateresult == 0) {
				info.put("status", "2");
				info.put("message", "Something went wrong");
				return info;
			}

			info.put("status", "1");
			info.put("message", "FeeCategory updated successfully");
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			e.printStackTrace();
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, Object> getfeeCategory(FeeCategoryRequest request) {
		// TODO Auto-generated method stub
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<com.niftem.app.entity.FeeCategory> tasks = super.feecategory.findByExIsDelete(false);
			if (tasks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "FeeHeadMaster not created");
				return info;
			} else {
				List dataList = new LinkedList();
				for (com.niftem.app.entity.FeeCategory e : tasks) {
					Map<Object, Object> FeeCategory = new HashMap<Object, Object>();
					FeeCategory.put("id", e.getId());
					FeeCategory.put("exIsActive", e.getExIsActive());
					FeeCategory.put("exIsDelete", e.getExIsDelete());
					FeeCategory.put("feeheadmaster", e.getFeeheadmaster().getExName());
					FeeCategory.put("feeheadmasterId", e.getFeeheadmaster().getId());
					FeeCategory.put("exName", e.getExName());

					dataList.add(FeeCategory);
				}
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> deletefeeCategory(FeeCategoryRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<com.niftem.app.entity.FeeCategory> task = super.feecategory.findById(request.getId());

			if (task.isPresent()) {
				if (task.get().getExIsDelete()) {
					info.put("status", "2");
					info.put("message", "feecategory already deleted");
					return info;
				}
				Boolean exIsDelete = true;
				Boolean is_active = false;
				int result = super.feecategory.deleteFeeCategory(exIsDelete, is_active, task.get().getId());
				if (result == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "FeeCategory deleted successfully");
				return info;
			}
			info.put("status", "2");
			info.put("message", "Feecategory not present");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> createfeeMaster(FeeMasterRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			FeeMaster fee = new FeeMaster();
			
			List<FeeMaster> tasks = new ArrayList<FeeMaster>();
			if (request.getExIsActive() == null) {
				info.put("status", "2");
				info.put("message", "IsActive is required 0/1");
				return info;
			}
			tasks = super.feeMaster.findByExFeeNameAndExIsDeleteAndSemsterIdAndProgrammeyearIdAndAcademicYearIdAndProgrammesId(request.getExFeeName(), false, request.getSemster() , request.getProgrammeyear() , request.getAcademicYear() , request.getProgrammes());
			if (tasks.size() > 0) {
				info.put("status", "2");
				info.put("message", "feeMaster name already exists");
				return info;
			}

			Optional<Batch> batch = super.batch.findByExIsDeleteAndExIsActiveAndId(false, true, request.getBatch());
			if (!batch.isPresent()) {
				info.put("status", "2");
				info.put("message", "batch not present");
				return info;
			}	
			
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}

			
			Optional<FeeCategory> fcategory = super.feecategory.findByExIsDeleteAndExIsActiveAndId(false, true, request.getExFeeCategory());
			if (!fcategory.isPresent()) {
				fee.setFeecategory(null);
			}else {
				fee.setFeecategory(fcategory.get());
			}

			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "degree not present");
				return info;
			}

			Optional<Programmes> programmes = super.programmes.findByIdAndExIsDeleteAndExIsActive(request.getProgrammes(), false, true);
			if (!programmes.isPresent()) {
				info.put("status", "2");
				info.put("message", "programmes not present");
				return info;
			}
			Optional<ProgrammeYear> programmeyear = super.programmeYear.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeyear(), false, true);
			if (!programmeyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programmeyear not present");
				return info;
			}

			Optional<Semster> semster = super.semester.findByIdAndExIsDeleteAndExIsActive(request.getSemster(), false,true);
			if (!semster.isPresent()) {
				info.put("status", "2");
				info.put("message", "semster not present");
				return info;
			}
		

			List<Category> category1 = new ArrayList<Category>();
			for (int i = 0; i < request.getCategory().size(); i++) {
				Long number = request.getCategory().get(i);
				Long col = new Long(number);
				Optional<Category> category = super.category.findByIdAndExIsDeleteAndExIsActive(col, false, true);
				if (!category.isPresent()) {
					info.put("status", "2");
					info.put("message", "category not present");
					return info;
				}
				category1.add(category.get());
			}

			List<FeeType> feetype1 = new ArrayList<FeeType>();
			for (int i = 0; i < request.getFeetype().size(); i++) {
				Long number = request.getFeetype().get(i);
				Long col = new Long(number);
				Optional<FeeType> feetype = super.feeType.findByIdAndExIsDeleteAndExIsActive(col, false, true);
				if (!feetype.isPresent()) {
					info.put("status", "2");
					info.put("message", "Selected FeeType not present");
					return info;
				}
				feetype1.add(feetype.get());
			}
			Long privailageid = 41L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			Date date = new Date();
			
			fee.setExCreateDate(date);
			fee.setFeetype(feetype1);
			fee.setCategory(category1);
			fee.setDegree(degree.get());
			fee.setBatch(batch.get());
			fee.setAcademicYear(academicYearid.get());
			fee.setProgrammes(programmes.get());
			fee.setProgrammeyear(programmeyear.get());
			fee.setSemster(semster.get());
			fee.setExFeeAmount(request.getExFeeAmount());
			fee.setExFeeCode(request.getExFeeCode());
			fee.setExIsDelete(false);
			fee.setExFeeName(request.getExFeeName());
			
			System.out.println(">>>>category" + request.getExFeeCategory());
			fee.setExIsActive(request.getExIsActive());
			super.feeMaster.save(fee);
			info.put("status", "1");
			info.put("message", "FeeMaster created successfully");
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
		}
		return info;

	}

	@Override
	public Map<String, String> updatefeeMaster(FeeMasterRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			System.out.println("update fee "+request.toString());

			Optional<Batch> batch = super.batch.findByExIsDeleteAndExIsActiveAndId(false, true, request.getBatch());
			if (!batch.isPresent()) {
				info.put("status", "2");
				info.put("message", "batch not present");
				return info;
			}

			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "degree not present");
				return info;
			}
			
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}

			Optional<Programmes> programmes = super.programmes.findByIdAndExIsDeleteAndExIsActive(request.getProgrammes(), false, true);
			if (!programmes.isPresent()) {
				info.put("status", "2");
				info.put("message", "programmes not present");
				return info;
			}
			Optional<ProgrammeYear> programmeyear = super.programmeYear.findByIdAndExIsDeleteAndExIsActive(request.getProgrammeyear(), false, true);
			if (!programmeyear.isPresent()) {
				info.put("status", "2");
				info.put("message", "programmeyear not present");
				return info;
			}

			Optional<Semster> semster = super.semester.findByIdAndExIsDeleteAndExIsActive(request.getSemster(), false,true);
			if (!semster.isPresent()) {
				info.put("status", "2");
				info.put("message", "semster not present");
				return info;
			}
			List<FeeMaster> tasks = new ArrayList<FeeMaster>();

			tasks = super.feeMaster.findByExFeeNameAndExIsDeleteAndSemsterIdAndProgrammeyearIdAndAcademicYearIdAndProgrammesId(request.getExFeeName(), false, request.getSemster() , request.getProgrammeyear() , request.getAcademicYear() , request.getProgrammes());

			if (tasks.size() > 0  && tasks.get(0).getId() != request.getId()) {
				info.put("status", "2");
				info.put("message", "feeMaster name already exists");
				return info;
			}

			List<Category> category1 = new ArrayList<Category>();
			for (int i = 0; i < request.getCategory().size(); i++) {
				Long number = request.getCategory().get(i);
				Long col = new Long(number);
				Optional<Category> category = super.category.findByIdAndExIsDeleteAndExIsActive(col, false, true);
				if (!category.isPresent()) {
					info.put("status", "2");
					info.put("message", "category not present");
					return info;
				}
				category1.add(category.get());
			}

			List<FeeType> feetype1 = new ArrayList<FeeType>();
			for (int i = 0; i < request.getFeetype().size(); i++) {
				Long number = request.getFeetype().get(i);
				Long col = new Long(number);
				Optional<FeeType> feetype = super.feeType.findByIdAndExIsDeleteAndExIsActive(col, false, true);
				if (!feetype.isPresent()) {
					info.put("status", "2");
					info.put("message", "Selected FeeType not present");
					return info;
				}
				feetype1.add(feetype.get());
			}
			Date date = new Date();
			int retval = super.feeMaster.updateFeeMaster(request.getExFeeName(), request.getExIsActive(),
					request.getExFeeAmount(), request.getExFeeCode(),
					request.getExFeeCategory(), request.getId() , request.getAcademicYear());
			if (retval == 0) {
				info.put("status", "0");
				info.put("message", "Something went wrong");
				return info;
			} else {
				String hql = "delete from ex_fee_master_fee_type where fee_master_id = " + request.getId();
				Query query = entityManager.createNativeQuery(hql);
				query.executeUpdate();
				entityManager.close();

				// super.feeMaster.deletefeeMasterfeeType(request.getId(),request.getFeetype());
				for (int i = 0; i < request.getFeetype().size(); i++) {
					Long number = request.getFeetype().get(i);
					Long col = new Long(number);
					super.feeMaster.savefeeMasterfeeType(request.getId(), col);
				}
				System.out.println("request>>>" + request);

				String hql1 = "delete from ex_fee_master_category where fee_master_id = " + request.getId();
				Query query1 = entityManager.createNativeQuery(hql1);
				query1.executeUpdate();
				entityManager.close();
				// super.feeMaster.deletefeeMasterfeeCategory(request.getId(),request.getCategory());
				for (int i = 0; i < request.getCategory().size(); i++) {
					Long number = request.getCategory().get(i);
					Long col = new Long(number);
					super.feeMaster.savefeeMasterCategory(request.getId(), col);
				}

			}
			info.put("status", "1");
			info.put("message", "feeMaster updated successfully");
			return info;

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			e.printStackTrace();
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, Object> getfeeMaster(FeeMasterRequest request) {
		// TODO Auto-generated method stub
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<FeeMaster> tasks = super.feeMaster.findByExIsDelete(false);
			if (tasks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "FeeMaster not created");
				return info;
			} else {
				List dataList = new LinkedList();
				for (FeeMaster e : tasks) {
					Map<Object, Object> FeeMaster = new HashMap<Object, Object>();
					FeeMaster.put("id", e.getId());
					FeeMaster.put("exFeeName", e.getExFeeName());				
					FeeMaster.put("exFeeCategory", e.getFeecategory() == null ?"NA":e.getFeecategory().getExName());
					FeeMaster.put("exFeeCategoryId", e.getFeecategory() == null ?"NA":e.getFeecategory().getId());
					
					FeeMaster.put("exFeeAmount", e.getExFeeAmount());
					FeeMaster.put("exFeeCode", e.getExFeeCode());

					FeeMaster.put("exIsActive", e.getExIsActive());
					FeeMaster.put("exIsDelete", e.getExIsDelete());
					FeeMaster.put("batch", e.getBatch().getExName());
					FeeMaster.put("batchId", e.getBatch().getId());
					FeeMaster.put("programmes", e.getProgrammes().getExName());
					FeeMaster.put("programmesId", e.getProgrammes().getId());
					FeeMaster.put("programmeYear", e.getProgrammeyear().getExName());
					FeeMaster.put("programmeYearId", e.getProgrammeyear().getId());
					FeeMaster.put("semster", e.getSemster().getExName());
					FeeMaster.put("semsterId", e.getSemster().getId());
					FeeMaster.put("degree", e.getDegree().getExName());
					FeeMaster.put("degreeId", e.getDegree().getId());
					
					FeeMaster.put("academicYear", e.getAcademicYear().getExYear());
					FeeMaster.put("academicYearId", e.getAcademicYear().getId());
									
					List feetype = new LinkedList();
					List feetypeId = new LinkedList();					
					for (int i = 0; i < e.getFeetype().size(); i++) {
						feetype.add(e.getFeetype().get(i).getExName());
						feetypeId.add(e.getFeetype().get(i).getId());
					}										
					FeeMaster.put("feetype", feetype);
					FeeMaster.put("feetypeId", feetypeId);
					
					
					List category = new LinkedList();
					List categoryId = new LinkedList();					
					for (int i = 0; i < e.getCategory().size(); i++) {
						category.add(e.getCategory().get(i).getExName());
						categoryId.add(e.getCategory().get(i).getId());
					}														
					FeeMaster.put("category", category);
					FeeMaster.put("categoryId", categoryId);
					dataList.add(FeeMaster);
				}
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;
			}
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> deletefeeMaster(FeeMasterRequest request) {
		// TODO Auto-generated method stub
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<FeeMaster> task = super.feeMaster.findById(request.getId());

			if (task.isPresent()) {
				if (task.get().getExIsDelete()) {
					info.put("status", "2");
					info.put("message", "FeeMaster already deleted");
					return info;
				}
				Boolean exIsDelete = true;
				Boolean is_active = false;
				int result = super.feeMaster.deleteFeeMaster(exIsDelete, is_active, task.get().getId());
				if (result == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "FeeMaster deleted successfully");
				return info;
			}
			info.put("status", "2");
			info.put("message", "FeeMaster not present");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> createExamTimeTable(ExamTimeTableRequest request) {
		Map<String, String> info = new LinkedHashMap<>();

		try {

			Optional<ExamAnnouncement> examAnnouncement = super.examAnnouncement.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!examAnnouncement.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement not present");
				return info;
			}
			
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDeparment(),false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}

			Optional<Programmes> programmes = super.programmes.findByIdAndExIsDeleteAndExIsActive(request.getProgrammes(), false, true);
			if (!programmes.isPresent()) {
				info.put("status", "2");
				info.put("message", "programmes not present");
				return info;
			}
			if (examAnnouncement.get().getProgrammes().getId() != request.getProgrammes()&& examAnnouncement.get().getDegree().getId() != request.getDegree()) {
				info.put("status", "2");
				info.put("message", "Exam Announcement is not created for particular degree or programmes");
				return info;
			}
			Date date = new Date();
			SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");
			SimpleDateFormat time = new SimpleDateFormat("HH:mm");

			List<User> user = super.user.findByIdAndExIsDelete(request.getUser(), false);
			if (user.size() <= 0) {
				info.put("status", "2");
				info.put("message", "User id not present");
				return info;
			}


			RegistrationType regType =null;
			Long regTypeId=0L;
			if (request.getExExamType() == 0L || request.getRegistrationType().equals("0")) {
				regType=null;
				
				List<ExamTimeTable> examlist = super.examtimetable
					.findByExIsDeleteAndAcademicYearIdAndProgrammesIdAndExamAnnouncementIdAndProgrammeYearIdAndExExamTypeAndDepartmentId(
						false, examAnnouncement.get().getAcademicYear().getId(), programmes.get().getId(),
						request.getExamAnnouncement(), 
						examAnnouncement.get().getProgrammeYear().getId(),request.getExExamType() , request.getDeparment());
				if (examlist.size() > 0) {
					info.put("status", "2");
					info.put("message", "MidTerm TimeTable already present");
					return info;
				}
				
				
			} else {
				List<RegistrationType> registration = super.registrationType.findByIdAndExIsDelete(request.getRegistrationType(), false);
				if (registration.size() <= 0) {
					info.put("status", "2");
					info.put("message", "RegistrationType id not present");
					return info;
				}
				

				regType =registration.get(0);
				regTypeId=registration.get(0).getId();

				List<ExamTimeTable> examlist = super.examtimetable
					.findByExIsDeleteAndAcademicYearIdAndProgrammesIdAndExamAnnouncementIdAndRegistrationIdAndProgrammeYearIdAndExExamTypeAndDepartmentId(
								false, examAnnouncement.get().getAcademicYear().getId(), programmes.get().getId(),
								request.getExamAnnouncement(), regTypeId,
							examAnnouncement.get().getProgrammeYear().getId(),request.getExExamType() , request.getDeparment());
				if (examlist.size() > 0) {
					info.put("status", "2");
					info.put("message", "End Term TimeTable already present");
					return info;
				}
	
			}
					
			List<Department> depart = super.department.findByProgrammesIdAndExIsDeleteAndExIsActive(request.getProgrammes(), false, true);
			if (depart.size() == 0) {
				info.put("status", "2");
				info.put("message", "Department not present");
				return info;
			}
			Boolean departs = true;
			Boolean courses = true;
			//for (Department e : depart) {
				System.out.println(">>>.." + programmes);
				System.out.println(">>>>>.." + courses);
				departs = false;

				List<Courses> task = null;
				
				if((regTypeId == 2 )|| (regTypeId == 5)) {
					// get register courses list for supply 
					List<CoursesRegistration>  clist = 	coursesRegistration.getSupplyCourses(request.getExamAnnouncement(), 2L, programmes.get().getId(), request.getDeparment());
					
					List<Long> dataList = new LinkedList<Long>();
		 			for(CoursesRegistration el : clist) {
		 				dataList.add(el.getCourses().getId());	 				
		 			}
		 			 task = super.courses.findByIdIn(dataList);	
				}else {
					List<CoursesRegistration>  clist1 = super.coursesRegistration.getSupplyCourses(request.getExamAnnouncement(), 1L, programmes.get().getId(), request.getDeparment());
				
					List<Long> dataList = new LinkedList<Long>();
		 			for(CoursesRegistration el : clist1) {
		 				dataList.add(el.getCourses().getId());	 				
		 			}
		 			 task = super.courses.findByIdIn(dataList);
				}
				

				
				for (Courses course : task) {
					for (CoursesType courseType : course.getCoursesType()) {
						if (courseType.getExName().equalsIgnoreCase("theory") ) {
							courses = false;
							ExamTimeTable table = new ExamTimeTable();
							table.setExIsUpdate(false);
							table.setAcademicYear(examAnnouncement.get().getAcademicYear());
							table.setCourses(course);
							table.setDegree(programmes.get().getDegree());
							table.setStream(course.getStream());
							table.setExamAnnouncement(examAnnouncement.get());
							table.setExStartDate(date1.parse(request.getExStartDate()));
							table.setExEndDate(date1.parse(request.getExEndDate()));
							table.setExIsActive(true);
							table.setExIsDelete(false);
							
							table.setUser(user.get(0));
							table.setExStartTime(time.parse(request.getExStartTime()));
							table.setExEndTime(time.parse(request.getExEndTime()));
							table.setExCreateDate(date);
							table.setProgrammes(programmes.get());
							table.setExExamType(request.getExExamType());
							table.setDepartment(course.getDepartment());
							table.setProgrammeYear(examAnnouncement.get().getProgrammeYear());
							table.setSemester(examAnnouncement.get().getSemester());
							table.setRegistration(regType);

							super.examtimetable.save(table);
						}
						
						
					}
				}
				
			
				Boolean rets	=saveExamAcademicYearProgrammes(examAnnouncement.get().getProgrammes(), examAnnouncement.get(),
						examAnnouncement.get().getAcademicYear(), regType, request.getUser(), examAnnouncement.get().getDegree(), dept, request.getExExamType());
				
		//	}
			Boolean ret = createExamTimeTableLog(examAnnouncement.get().getAcademicYear(),
					examAnnouncement.get(), request.getUser(), examAnnouncement.get().getDegree(),
					examAnnouncement.get().getProgrammes(),request.getExExamType());
			
			System.out.println("Testing "+ ret);

			if (!ret) {
				info.put("status", "0");
				info.put("message", "Something went wrong");
				 return info;
			}
			if (departs) {
				info.put("status", "2");
				info.put("message", "program department  not  mapped with any AcademicYear");
				return info;
			}

			if (courses) {
				info.put("status", "2");
				info.put("message", "Courses  not  mapped with any Program");
				return info;
			}
			Long privailageid = 42L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			info.put("status", "1");
			info.put("message", "Exam Time Table created successfully");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	private Boolean createExamTimeTableLog(AcademicYear academicYear, ExamAnnouncement examAnnouncement, Long users,
			Degree degree, Programmes programmes, Long exexamtype ) {
		// TODO Auto-generated method stub
		ExamTimeTableLogs examlog = new ExamTimeTableLogs();

		Date date = new Date();
		try {

		
			if (users == null || users.equals("")) {
				System.out.println("CCCCCCCCCc" + users);
				examlog.setUser(null);
			} else {
				List<User> user = super.user.findByIdAndExIsDelete(users, false);
				if (user.size() <= 0) {

					return false;
				}
				examlog.setUser(user.get(0));
			}
			examlog.setAcademicYear(academicYear);
			examlog.setExamAnnouncement(examAnnouncement);
			examlog.setReportType(false);
			examlog.setDegree(degree);
			examlog.setProgrammes(programmes);
			examlog.setExExamType(exexamtype);
			examlog.setExCreateDate(date);
			super.examTimeTableLogs.save(examlog);
			return true;
		} catch (Exception e) {
			// TODO: handle exception
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			return false;
		}

	}

	public Boolean saveExamAcademicYearProgrammes(Programmes program, ExamAnnouncement examAnnouncement,
			AcademicYear academicYear, RegistrationType registrationType, Long users, Degree degree, Optional<Department> dept, Long type ) {
		System.out.println("XXXXXXXXXX" + program);
		try {
			ExamAcademicYearProgrammes ExamAcademicYearProgrammes = new ExamAcademicYearProgrammes();
			if (users == null || users.equals("")) {
				System.out.println("CCCCCCCCCc" + users);
				ExamAcademicYearProgrammes.setUser(null);
			} else {
				List<User> user = super.user.findByIdAndExIsDelete(users, false);
				if (user.size() <= 0) {

					return false;
				}

				ExamAcademicYearProgrammes.setUser(user.get(0));

			}

			ExamAcademicYearProgrammes.setProgrammes(program);
			ExamAcademicYearProgrammes.setDegree(degree);
			ExamAcademicYearProgrammes.setDepartment(dept.get());
			ExamAcademicYearProgrammes.setExamAnnouncement(examAnnouncement);
			ExamAcademicYearProgrammes.setAcademicYear(academicYear);
			// ExamAcademicYearProgrammes.setExIsAttendence(false);
			// ExamAcademicYearProgrammes.setExIsBarcode(false);
			ExamAcademicYearProgrammes.setExIsInvigilator(false);
			ExamAcademicYearProgrammes.setExIsTimeTable(false);
			ExamAcademicYearProgrammes.setRegistration(registrationType);
			ExamAcademicYearProgrammes.setExExamType(type); 
			super.examAcademicYearProgrammes.save(ExamAcademicYearProgrammes);

			return true;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			return false;
		}
	}

	@Override
	public Map<String, String> updateExamTimeTable(ExamTimeTableRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			if (request.getExTimeTableId() == null || request.getExTimeTableId().equals("")) {
				info.put("status", "2");
				info.put("message", "ExExamTimeTableId not present");
			}

			Optional<ExamTimeTable> task = super.examtimetable.findById(request.getExTimeTableId());
			if (!task.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExExamTimeTableId not present");
			}

			SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");
			SimpleDateFormat time = new SimpleDateFormat("HH:MM");
			Boolean is_update = true;
			System.out.println("?????????" + is_update);
			Date modifieddate = new Date();
			int updateresult = super.examtimetable.updateExamtimeTable(date1.parse(request.getExStartDate()), is_update,
					request.getExTimeTableId(), modifieddate);
			if (updateresult == 0) {
				info.put("status", "2");
				info.put("message", "Something went wrong");
				return info;
			}
			
			Long privailageid = 42L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			info.put("status", "1");
			info.put("message", "ExamTimeTable updated successfully");
			return info;

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;

		}
	}

	@Override
	public Map<String, Object> getExamTimeTable(ExamTimeTableRequest request) {
		List tasks = new ArrayList();
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			

			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDeparment(),
					false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}

			Optional<Programmes> Prog = super.programmes.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			
			
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}


			List<ExamAnnouncement> result = super.examAnnouncement.findByIdAndExIsDelete(request.getExamAnnouncement(),
					false);
			if (result.size() <= 0) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}
			logger.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>"+request);
			
			if(request.getExExamType()==0L ) {
			
				List<ExamTimeTable> examlistmid = super.examtimetable
						.findByExIsDeleteAndAcademicYearIdAndProgrammesIdAndExamAnnouncementIdAndExExamTypeAndDegreeIdAndDepartmentId(false,
								request.getAcademicYear(), request.getProgrammes(), request.getExamAnnouncement(),
								request.getExExamType(),request.getDegree() , request.getDeparment());

				if (examlistmid.size() <= 0) {
					info.put("status", "2");
					info.put("message", "Midterm TimeTable not present");
					return info;
				}

				List dataList = new LinkedList();
				for (ExamTimeTable e : examlistmid) {
					Map<Object, Object> timetabledata = new HashMap<Object, Object>();
					timetabledata.put("exTimeTableId", e.getId());
					timetabledata.put("courses", e.getCourses().getExName());
					timetabledata.put("programmes", e.getProgrammes().getExName());
					timetabledata.put("academicYear", e.getAcademicYear().getExYear());
					timetabledata.put("examAnnouncement", e.getExamAnnouncement().getExName());
					timetabledata.put("programmesId", e.getProgrammes().getId());
					timetabledata.put("academicYearId", e.getAcademicYear().getId());
					timetabledata.put("examAnnouncementId", e.getExamAnnouncement().getId());
					timetabledata.put("coursesId", e.getCourses().getId());
					timetabledata.put("coursesCode", e.getCourses().getExCoursesCode());
					timetabledata.put("exStartDate",
							e.getExStartDate() == null ? "NA" : e.getExStartDate().toString().substring(0, 10));
					timetabledata.put("exEndDate",
							e.getExEndDate() == null ? "NA" : e.getExEndDate().toString().substring(0, 10));
					timetabledata.put("exStartTime",
							e.getExStartTime() == null ? "NA" : e.getExStartTime().toString().substring(0, 5));
					timetabledata.put("exEndTime",
							e.getExEndTime() == null ? "NA" : e.getExEndTime().toString().substring(0, 5));
					timetabledata.put("exIsActive", e.getExIsActive());
					timetabledata.put("exIsUpdate", e.getExIsUpdate());
					dataList.add(timetabledata);
				}

				List<ExamAcademicYearProgrammes> examprogram = super.examAcademicYearProgrammes
						.findByAcademicYearIdAndExamAnnouncementIdAndProgrammesIdAndExExamTypeAndDegreeIdAndDepartmentId(request.getAcademicYear(),
								request.getExamAnnouncement(), request.getProgrammes(),request.getExExamType(),request.getDegree() , request.getDeparment());
				if (examprogram.size() > 0) {
					info.put("timetablestatus", examprogram.get(0).getExIsTimeTable());
				} else {
					info.put("timetablestatus", false);
				}
				
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;

			}
			if(request.getExExamType()==1L ) {
			List<RegistrationType> registration = super.registrationType.findByIdAndExIsDelete(request.getRegistrationType(), false);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType id not present");
				return info;
			}
			
			List<ExamTimeTable> examlist = super.examtimetable
					.findByExIsDeleteAndAcademicYearIdAndProgrammesIdAndExamAnnouncementIdAndRegistrationIdAndExExamTypeAndDegreeIdAndDepartmentId(false,
							request.getAcademicYear(), request.getProgrammes(), request.getExamAnnouncement(),
							request.getRegistrationType(),request.getExExamType(),request.getDegree() , request.getDeparment());

			if (examlist.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Endterm TimeTable not present");
				return info;
			}

			List dataList = new LinkedList();
			for (ExamTimeTable e : examlist) {
				Map<Object, Object> timetabledata = new HashMap<Object, Object>();
				timetabledata.put("exTimeTableId", e.getId());
				timetabledata.put("courses", e.getCourses().getExName());
				timetabledata.put("programmes", e.getProgrammes().getExName());
				timetabledata.put("academicYear", e.getAcademicYear().getExYear());
				timetabledata.put("registrationType", e.getRegistration().getExName());
				timetabledata.put("examAnnouncement", e.getExamAnnouncement().getExName());
				timetabledata.put("programmesId", e.getProgrammes().getId());
				timetabledata.put("academicYearId", e.getAcademicYear().getId());
				timetabledata.put("registrationTypeId", e.getRegistration().getId());
				timetabledata.put("examAnnouncementId", e.getExamAnnouncement().getId());
				timetabledata.put("coursesId", e.getCourses().getId());
				timetabledata.put("coursesCode", e.getCourses().getExCoursesCode());
				timetabledata.put("exStartDate",
						e.getExStartDate() == null ? "NA" : e.getExStartDate().toString().substring(0, 10));
				timetabledata.put("exEndDate",
						e.getExEndDate() == null ? "NA" : e.getExEndDate().toString().substring(0, 10));
				timetabledata.put("exStartTime",
						e.getExStartTime() == null ? "NA" : e.getExStartTime().toString().substring(0, 5));
				timetabledata.put("exEndTime",
						e.getExEndTime() == null ? "NA" : e.getExEndTime().toString().substring(0, 5));
				timetabledata.put("exIsActive", e.getExIsActive());
				timetabledata.put("exIsUpdate", e.getExIsUpdate());
				dataList.add(timetabledata);
			}

			List<ExamAcademicYearProgrammes> examprogram = super.examAcademicYearProgrammes
					.findByAcademicYearIdAndExamAnnouncementIdAndProgrammesIdAndExExamTypeAndDegreeIdAndDepartmentId(request.getAcademicYear(),
							request.getExamAnnouncement(), request.getProgrammes(),request.getExExamType(),request.getDegree() , request.getDeparment());
			if (examprogram.size() > 0) {
				info.put("timetablestatus", examprogram.get(0).getExIsTimeTable());
			} else {
				info.put("timetablestatus", false);
			}
			
			info.put("status", "1");
			info.put("message", "success");
			info.put("details", dataList);
			return info;
			
			}
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, String> generateTimetable(ExternalMarksRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree id not present");
				return info;
			}
			Optional<Programmes> Prog = super.programmes.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes id not present");
				return info;
			}
			List<ExamAnnouncement> result = super.examAnnouncement.findByIdAndExIsDelete(request.getExamAnnouncement(),
					false);
			if (result.size() <= 0) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}
			Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),false, true);
			if (!dept.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not  present");
				return info;

			}
			
			int retvalue = 0;
			RegistrationType regType =null;

			if (request.getExIdentifier().equalsIgnoreCase("timetable")) {
				if (request.getExExamType() == 0L || request.getRegistrationType().equals("0")) {
					
					regType=null;
					List<ExamTimeTable> examlist = super.examtimetable.findByExIsDeleteAndAcademicYearIdAndProgrammesIdAndExamAnnouncementIdAndExIsUpdateAndDegreeIdAndExExamTypeAndDepartmentId(
									false, request.getAcademicYear(), request.getProgrammes(),
									request.getExamAnnouncement(),  false,
									request.getDegree(),request.getExExamType() , request.getDepartment());
					if (examlist.size() > 0) {
						info.put("status", "2");
						info.put("message", "time table not updated for : " + examlist.get(0).getCourses().getExName());
						return info;
					}
					Boolean timetable = true;
					retvalue = super.examAcademicYearProgrammes.updateTimeTables(timetable, request.getProgrammes(),
							request.getAcademicYear(), request.getExamAnnouncement(),
							request.getUser(),request.getExExamType());
					System.out.println("aaaaaaa" + retvalue);

					if (retvalue >= 1) {
						info.put("status", "1");
						info.put("message", "Time table generated successfully");
						return info;
					} else {
						info.put("status", "2");
						info.put("message", "Time table generated successfully");
						return info;
					}
					
					
				}
			
				if (request.getExExamType() == 1L || request.getExExamType().equals("1")) {
					List<RegistrationType> registration = super.registrationType
							.findByIdAndExIsDelete(request.getRegistrationType(), false);
					if (registration.size() <= 0) {
						info.put("status", "2");
						info.put("message", "RegistrationType id not present");
						return info;
					}
					
					regType=registration.get(0);
					
					List<ExamTimeTable> examlist = super.examtimetable
							.findByExIsDeleteAndAcademicYearIdAndProgrammesIdAndExamAnnouncementIdAndRegistrationIdAndExIsUpdateAndDegreeIdAndExExamTypeAndDepartmentId(
									false, request.getAcademicYear(), request.getProgrammes(),
									request.getExamAnnouncement(),request.getRegistrationType() , false,
									request.getDegree(),request.getExExamType() , request.getDepartment());
					if (examlist.size() > 0) {
						info.put("status", "2");
						info.put("message", "time table not updated for : " + examlist.get(0).getCourses().getExName());
						return info;
					}
					Boolean timetable = true;
					retvalue = super.examAcademicYearProgrammes.updateTimeTablestatus(timetable, request.getProgrammes(),
							request.getAcademicYear(), request.getExamAnnouncement(), request.getRegistrationType(),
							request.getUser(),request.getExExamType() , request.getDepartment());
					System.out.println("aaaaaaa" + retvalue);

					
						info.put("status", "1");
						info.put("message", "Time table generated successfully");
						return info;
				
					
				}

			}// check timetable updated or not for all the courses based on program

				return info;
		
			

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, String> createQuestionPaperType(QuestionPaperTypeRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			List<QuestionPaperType> tasks = new ArrayList<QuestionPaperType>();
			tasks = super.questionpaperType.findByExQpTypeAndExIsDelete(request.getExQpType().trim(), false);
			if (tasks.size() > 0) {
				info.put("status", "2");
				info.put("message", "QuestionPaperType already exists");
				return info;
			}
			Date date = new Date();
			Long privailageid = 43L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			QuestionPaperType questionpaper = new QuestionPaperType();
			request.setId(null);
			questionpaper.setExCreateDate(date);
			questionpaper.setExIsDelete(false);
			questionpaper.setExIsActive(request.getExIsActive());
			questionpaper.setExQpType(request.getExQpType());
			questionpaper.setExDescription(request.getExDescription());
			super.questionpaperType.save(questionpaper);

			info.put("status", "1");
			info.put("message", "QuestionPaperType created successfully");

			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getQuestionPaperType(QuestionPaperTypeRequest request) {

		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<QuestionPaperType> tasks = super.questionpaperType.findByExIsDelete(false);
			if (tasks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "QuestionPaperType not created");
				return info;
			} else {
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", tasks);
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> deleteQuestionPaperType(QuestionPaperTypeRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<QuestionPaperType> task = super.questionpaperType.findById(request.getId());
			if (task.isPresent()) {
				if (task.get().getExIsDelete()) {
					info.put("status", "2");
					info.put("message", "QuestionPaperType already deleted");
					return info;
				}
				Boolean exIsDelete = true;
				Boolean is_active = false;
				int result = super.questionpaperType.deleteQuestionPaperType(exIsDelete, is_active, task.get().getId());
				if (result == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "QuestionPaperType deleted successfully");
				return info;
			}
			info.put("status", "2");
			info.put("message", "QuestionPaperType id not present");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> updateQuestionPaperType(QuestionPaperTypeRequest request) {

		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<QuestionPaperType> QuestionPaperType = super.questionpaperType.findById(request.getId());
			if (request.getId() == null || !QuestionPaperType.isPresent()) {
				info.put("status", "2");
				info.put("message", "Question Paper Type id not present");
				return info;
			}
			List<QuestionPaperType> tasks = new ArrayList<QuestionPaperType>();
			tasks = super.questionpaperType.findByExQpTypeAndExIsDelete(request.getExQpType().trim(), false);
			if (tasks.size() > 0 && tasks.get(0).getId() != request.getId()) {
				info.put("status", "2");
				info.put("message", "Question Paper Type already exists");
				return info;
			}

			Date date = new Date();
			Long privailageid = 43L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			int retval = super.questionpaperType.updateQuestionPaperType(request.getExQpType(),
					request.getExDescription(), request.getExIsActive(), date, request.getId());
			if (retval == 1) {
				info.put("status", "1");
				info.put("message", "Question Paper Type updated successfully");
				return info;
			} else {
				info.put("status", "2");
				info.put("message", "Question Paper Type  id not present");
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, String> createQuestionPaperTopic(QuestionPaperTopicRequest request) {

		Map<String, String> info = new LinkedHashMap<>();
		try {
			List<QuestionPaperTopic> tasks = new ArrayList<QuestionPaperTopic>();
			tasks = super.QuestionPaperTopic.findByExQpTopicAndExIsDelete(request.getExQpTopic().trim(), false);
			if (tasks.size() > 0) {
				info.put("status", "2");
				info.put("message", "QuestionPaperTopic already exists");
				return info;
			}
			Date date = new Date();
			Long privailageid = 44L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			QuestionPaperTopic questionpapertopic = new QuestionPaperTopic();
			request.setId(null);
			questionpapertopic.setExCreateDate(date);
			questionpapertopic.setExIsDelete(false);
			questionpapertopic.setExIsActive(request.getExIsActive());
			questionpapertopic.setExQpTopic(request.getExQpTopic());
			questionpapertopic.setExIdentifier(request.getExIdentifier());
			questionpapertopic.setExDescription(request.getExDescription());
			super.QuestionPaperTopic.save(questionpapertopic);

			info.put("status", "1");
			info.put("message", "QuestionPaperTopic created successfully");

			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> getQuestionPaperTopic(QuestionPaperTopicRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<QuestionPaperTopic> tasks = super.QuestionPaperTopic.findByExIsDelete(false);
			if (tasks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "QuestionPaperTopic not created");
				return info;
			} else {
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", tasks);
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> deleteQuestionPaperTopic(QuestionPaperTopicRequest request) {

		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<QuestionPaperTopic> task = super.QuestionPaperTopic.findById(request.getId());
			if (task.isPresent()) {
				if (task.get().getExIsDelete()) {
					info.put("status", "2");
					info.put("message", "QuestionPaperTopic already deleted");
					return info;
				}
				Boolean exIsDelete = true;
				Boolean is_active = false;
				int result = super.QuestionPaperTopic.QuestionPaperTopic(exIsDelete, is_active, task.get().getId());
				if (result == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "QuestionPaperTopic deleted successfully");
				return info;
			}
			info.put("status", "2");
			info.put("message", "QuestionPaperTopic id not present");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> updateQuestionPaperTopic(QuestionPaperTopicRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<QuestionPaperTopic> QuestionPaperTopic = super.QuestionPaperTopic.findById(request.getId());
			if (request.getId() == null || !QuestionPaperTopic.isPresent()) {
				info.put("status", "2");
				info.put("message", "Question Paper Topic id not present");
				return info;
			}
			List<QuestionPaperTopic> tasks = new ArrayList<QuestionPaperTopic>();
			tasks = super.QuestionPaperTopic.findByExQpTopicAndExIsDelete(request.getExQpTopic().trim(), false);
			if (tasks.size() > 0 && tasks.get(0).getId() != request.getId()) {
				info.put("status", "2");
				info.put("message", "Question Paper Topic already exists");
				return info;
			}

			Date date = new Date();
			Long privailageid = 44L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			int retval = super.QuestionPaperTopic.updateQuestionPaperTopic(request.getExQpTopic(),
					request.getExDescription(), request.getExIsActive(), date, request.getId(),
					request.getExIdentifier());
			if (retval == 1) {
				info.put("status", "1");
				info.put("message", "QuestionPaperTopic updated successfully");
				return info;
			} else {
				info.put("status", "2");
				info.put("message", "QuestionPaperTopic  id not present");
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> createQuestionPaperPattern(QuestionPaperPatternRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {

			Optional<Programmes> uid = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgramme());
			if (!uid.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}

			Optional<Degree> Degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!Degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}
			Optional<ExamAnnouncement> Examannouncement = super.examAnnouncement
					.findByExIsDeleteAndExIsActiveAndId(false, true, request.getExamAnnouncement());
			if (!Examannouncement.isPresent()) {
				info.put("status", "2");
				info.put("message", "Examannouncement id not present");
				return info;
			}
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			
			Optional<Department> department = super.department.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getDepartment());
			if (!department.isPresent()) {
				info.put("status", "2");
				info.put("message", "Department id not present");
				return info;
			}

			Optional<QuestionPaperType> questionPaperType = super.questionpaperType
					.findByIdAndExIsDeleteAndExIsActive(request.getQuestionPaperType(), false, true);
			if (!questionPaperType.isPresent()) {
				info.put("status", "2");
				info.put("message", "QuestionPaperType not present");
				return info;
			}
			Optional<QuestionPaperTopic> questionPaperTopic = super.QuestionPaperTopic
					.findByIdAndExIsDeleteAndExIsActive(request.getQuestionPaperTopic(), false, true);
			if (!questionPaperTopic.isPresent()) {
				info.put("status", "2");
				info.put("message", "QuestionPaperTopic not present");
				return info;
			}

			List<Courses> Courseslist = super.courses.findByExIsDeleteAndExIsActiveAndProgrammesIdAndProgrammeYearIdAndSemesterIdAndDepartmentIdAndCoursesTypeIdAndAcademicYearId(false, true,request.getProgramme(), Examannouncement.get().getProgrammeYear().getId(),Examannouncement.get().getSemester().getId(),request.getDepartment(),1L,request.getAcademicYear());
			if (Courseslist.size() <= 0) {
				info.put("status", "2");
				info.put("message", "course not present for particular programe/programyear/semeste");
				return info;
			}
			
			List<QuestionPaperPattern> QuestionPaperPattern = super.QuestionPaperPattern
					.findByExIsDeleteAndExIsActiveAndProgrammesIdAndDegreeIdAndAcademicYearIdAndQuestionPaperTopicIdAndQuestionPaperTypeIdAndExamAnnouncementId(false, true,request.getProgramme(),request.getDegree(),request.getAcademicYear(),request.getQuestionPaperTopic(),request.getQuestionPaperType(),request.getExamAnnouncement());
			if (QuestionPaperPattern.size()>0) {
				info.put("status", "2");
				info.put("message", "QuestionPaperPattern already present");
				return info;
			}
			
			logger.info(">>>>>>>>>>>>>>Courseslist>>>>>>>>>>>>>>>" + Courseslist.size());
			List dataList = new LinkedList();
			for (Courses c : Courseslist) {
				Date date = new Date();
				Long privailageid = 45L;
				User userid = super.commonHelper.getuser(request.getUser());
				String Description = request.toString();
				Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
				QuestionPaperPattern questionPaperPattern = new QuestionPaperPattern();

				questionPaperPattern.setExEndNo(request.getExEndNo());
				questionPaperPattern.setExStartNo(request.getExStartNo());
				questionPaperPattern.setDepartment(department.get());
				questionPaperPattern.setExIsActive(request.getExIsActive());
				questionPaperPattern.setExEachQuestionMark(request.getExEachQuestionMark());
				questionPaperPattern.setExNoOfQuestion(request.getExNoOfQuestion());
				questionPaperPattern.setProgrammes(uid.get());
				questionPaperPattern.setQuestionPaperType(questionPaperType.get());
				questionPaperPattern.setQuestionPaperTopic(questionPaperTopic.get());
				questionPaperPattern.setExCreateDate(date);
				questionPaperPattern.setExIsDelete(false);
				questionPaperPattern.setAcademicYear(academicYearid.get());
				questionPaperPattern.setExamAnnouncement(Examannouncement.get());
				questionPaperPattern.setCourses(c);
				questionPaperPattern.setDegree(Degree.get());
			//	dataList.add(questionPaperPattern);
				super.QuestionPaperPattern.save(questionPaperPattern);
				}

			
		//	System.out.println("?????????????????????"+dataList.size());
		//	super.QuestionPaperPattern.saveAll(dataList);
			info.put("status", "1");
			info.put("message", "QuestionPaperPattern created successfully");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}

	}

	@Override
	public Map<String, Object> getQuestionPaperPattern(QuestionPaperPatternRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			List<QuestionPaperPattern> tasks = super.QuestionPaperPattern.findByExIsDelete(false);
			if (tasks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "QuestionPaperPattern not created");
				return info;
			} else {
				List dataList = new LinkedList();
				for (QuestionPaperPattern e : tasks) {
					Map<Object, Object> QuestionPaperPatterndata = new HashMap<Object, Object>();
					QuestionPaperPatterndata.put("id", e.getId());
					QuestionPaperPatterndata.put("programme", e.getProgrammes().getExName());
					QuestionPaperPatterndata.put("programmeId", e.getProgrammes().getId());
					QuestionPaperPatterndata.put("questionPaperType", e.getQuestionPaperType().getExQpType());
					QuestionPaperPatterndata.put("questionPaperTypeId", e.getQuestionPaperType().getId());
					QuestionPaperPatterndata.put("questionPaperTopic", e.getQuestionPaperTopic().getExQpTopic());
					QuestionPaperPatterndata.put("questionPaperTopicId", e.getQuestionPaperTopic().getId());
					QuestionPaperPatterndata.put("exStartNo", e.getExStartNo());
					QuestionPaperPatterndata.put("exEndNo", e.getExEndNo());
					QuestionPaperPatterndata.put("exEachQuestionMark", e.getExEachQuestionMark());
					QuestionPaperPatterndata.put("exNoOfQuestion", e.getExNoOfQuestion());
					QuestionPaperPatterndata.put("exIsActive", e.getExIsActive());
					QuestionPaperPatterndata.put("examAnnouncement", e.getExamAnnouncement().getExName());
					QuestionPaperPatterndata.put("examAnnouncementId", e.getExamAnnouncement().getId());
					QuestionPaperPatterndata.put("academicYear", e.getAcademicYear().getExYear());
					QuestionPaperPatterndata.put("academicYearId", e.getAcademicYear().getId());
					QuestionPaperPatterndata.put("degreeId", e.getDegree().getId());
					QuestionPaperPatterndata.put("degree", e.getDegree().getExName());
					QuestionPaperPatterndata.put("departmentId", e.getDepartment().getId());
					QuestionPaperPatterndata.put("department", e.getDepartment().getExName());
					QuestionPaperPatterndata.put("coursesId", e.getCourses().getId());
					QuestionPaperPatterndata.put("courses", e.getDepartment().getExName());

					

					dataList.add(QuestionPaperPatterndata);
				}
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> deleteQuestionPaperPattern(QuestionPaperPatternRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<QuestionPaperPattern> task = super.QuestionPaperPattern.findById(request.getId());
			if (task.isPresent()) {
				if (task.get().getExIsDelete()) {
					info.put("status", "2");
					info.put("message", "QuestionPaperPattern already deleted");
					return info;
				}
				Boolean exIsDelete = true;
				Boolean is_active = false;
				int result = super.QuestionPaperPattern.deleteQuestionPaperPattern(exIsDelete, is_active,
						task.get().getId());
				if (result == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "QuestionPaperPattern deleted successfully");
				return info;
			}
			info.put("status", "2");
			info.put("message", "QuestionPaperPattern id not present");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> updateQuestionPaperPattern(QuestionPaperPatternRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<Degree> Degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!Degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}
			Optional<ExamAnnouncement> Examannouncement = super.examAnnouncement
					.findByExIsDeleteAndExIsActiveAndId(false, true, request.getExamAnnouncement());
			if (!Examannouncement.isPresent()) {
				info.put("status", "2");
				info.put("message", "Examannouncement id not present");
				return info;
			}
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}

			Optional<Programmes> uid = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgramme());
			if (!uid.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}

			Optional<QuestionPaperType> questionPaperType = super.questionpaperType
					.findByIdAndExIsDeleteAndExIsActive(request.getQuestionPaperType(), false, true);
			if (!questionPaperType.isPresent()) {
				info.put("status", "2");
				info.put("message", "QuestionPaperType not present");
				return info;
			}
			Optional<QuestionPaperTopic> questionPaperTopic = super.QuestionPaperTopic
					.findByIdAndExIsDeleteAndExIsActive(request.getQuestionPaperTopic(), false, true);
			if (!questionPaperTopic.isPresent()) {
				info.put("status", "2");
				info.put("message", "QuestionPaperTopic not present");
				return info;
			}
			/*
			 * List<QuestionPaperPattern> tasks = new ArrayList(); tasks =
			 * QuestionPaperPatternRepository.findByProgrammesIdAndExIsDelete(
			 * questionPaperPatternRequest.getProgramme() , false); if (tasks.size() > 0 &&
			 * tasks.get(0).getId() != questionPaperPatternRequest.getId()) {
			 * info.put("status", "2"); info.put("message",
			 * "QuestionPaperPattern already exists for the Programme "); return info; }
			 */
			
			Long privailageid = 45L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			Date date = new Date();
			int retval = super.QuestionPaperPattern.updateQuestionPaperPattern(request.getProgramme(),
					request.getExIsActive(), request.getQuestionPaperTopic(), request.getQuestionPaperType(),
					request.getExEndNo(), request.getExStartNo(), request.getExNoOfQuestion(),
					request.getExEachQuestionMark(), date,request.getDepartment(), request.getId());
			if (retval == 1) {
				info.put("status", "1");
				info.put("message", "QuestionPaperPattern updated successfully");
				return info;
			} else {
				info.put("status", "2");
				info.put("message", "QuestionPaperPattern  id not present");
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> createInvigilatorAllocation(InvigilatorAllocationRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {

			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}

			Optional<Programmes> Programmes = super.programmes.findByIdAndExIsDeleteAndExIsActive(request.getProgrammes(), false,
					true);
			if (!Programmes.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes Id not Present");
				return info;
			}
			Optional<RoomMaster> room = super.roomMaster.findByExIsDeleteAndExIsActiveAndId(false, true,request.getRoomId());
			if (!room.isPresent()) {
				info.put("status", "2");
				info.put("message", "room not present");
				return info;
			}
			
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}

			List<ExamAnnouncement> result = super.examAnnouncement.findByIdAndExIsDelete(request.getExamAnnouncement(),
					false);
			if (result.size() <= 0) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}

			Optional<StaffType> stafftype = super.staffType.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getStaffType());
			if (!stafftype.isPresent()) {
				info.put("status", "2");
				info.put("message", "StaffType not present");
				return info;
			}
			Optional<Staffpersonal> Staffpersonal = super.staffpersonal.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getStaff());
			if (!Staffpersonal.isPresent()) {
				info.put("status", "2");
				info.put("message", "Staff not present");
				return info;
			}
			Optional<Department> department = super.department.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDepartment());
			if (!department.isPresent()) {
				info.put("status", "2");
				info.put("message", "Department not present");
				return info;
			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "degree not present");
				return info;
			}
			List<InvigilatorAllocation> value = super.InvigilatorAllocation
					.findByExIsDeleteAndStaffIdAndExamAnnouncementId(false, request.getStaff(),
							request.getExamAnnouncement());
			if (value.size() > 0) {
				info.put("status", "2");
				info.put("message", "staff already allocated");
				return info;
			}
			Long privailageid = 46L;
			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, privailageid);
			Date date = new Date();
			InvigilatorAllocation allocation = new InvigilatorAllocation();
			if (request.getUser() == null || request.getUser().equals("")) {
				allocation.setUser(null);
			} else {
				List<User> user = super.user.findByIdAndExIsDelete(request.getUser(), false);
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}

				allocation.setUser(user.get(0));

			}
			allocation.setRoomid(room.get());
			allocation.setAcademicYear(academicYearid.get());
			allocation.setColleges(collage.get());
			allocation.setExamAnnouncement(result.get(0));
			allocation.setExCreateDate(date);
			allocation.setExIsActive(request.getExIsActive());
			allocation.setExIsDelete(false);
			allocation.setDepartment(department.get());
			allocation.setDegree(degree.get());
			allocation.setStaff(Staffpersonal.get());
			allocation.setStafftype(stafftype.get());
			allocation.setProgrammes(Programmes.get());

			super.InvigilatorAllocation.save(allocation);
			Boolean retvalue = saveInvigilatorAllocationDate(request, allocation);
			if (retvalue) {
				info.put("status", "1");
				info.put("message", "Invigilator Allocated successfully");
				return info;
			} else {
				super.InvigilatorAllocation.delete(allocation);
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}

	}

	public Boolean saveInvigilatorAllocationDate(InvigilatorAllocationRequest request,
			InvigilatorAllocation allocation) {
		try {
			super.InvigilatorDateAllocation.deleteAllocationDate(allocation.getId());
			SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");
			SimpleDateFormat time = new SimpleDateFormat("HH:MM");
			for (int i = 0; i < request.getExStartDate().size(); i++) {
				InvigilatorDateAllocation dateallocation = new InvigilatorDateAllocation();
				dateallocation.setExStartDate(date1.parse((String) request.getExStartDate().get(i)));
				dateallocation.setExStartTime(time.parse(request.getExStartTime()));
				dateallocation.setExEndTime(time.parse(request.getExEndTime()));
				dateallocation.setInvigilator(allocation);
				super.InvigilatorDateAllocation.save(dateallocation);
			}

			return true;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			return false;
		}
	}

	@Override
	public Map<String, Object> getInvigilatorAllocation(InvigilatorAllocationRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		// List<InvigilatorAllocation> tasks = new ArrayList();
		try {
			List<InvigilatorAllocation> task = super.InvigilatorAllocation.findByExIsDelete(false);
			List dataList = new LinkedList();
			System.out.println("????????????"+task.size());

			for (InvigilatorAllocation e : task) {
				System.out.println("????????q????"+task.size());
				
				Map<Object, Object> info1 = new HashMap<Object, Object>();
				info1.put("academicYear", e.getAcademicYear().getExYear());
				info1.put("college", e.getColleges().getExName());
				info1.put("examAnnouncement", e.getExamAnnouncement().getExName());
				info1.put("staff", e.getStaff().getExName());
				info1.put("department", e.getDepartment().getExName());
				info1.put("programmes", e.getProgrammes().getExName());
				info1.put("degree", e.getDegree().getExName());
				info1.put("academicYearId", e.getAcademicYear().getId());
				info1.put("collegeId", e.getColleges().getId());
				info1.put("examAnnouncementId", e.getExamAnnouncement().getId());
				info1.put("staffId", e.getStaff().getId());
				info1.put("exContactDetails", e.getStaff().getExContactDetails());
				info1.put("StafftypeId", e.getStafftype().getId());
				info1.put("Stafftype", e.getStafftype().getExName());
				info1.put("exEmployeeId", e.getStaff().getExEmployeeId());
				info1.put("departmentId", e.getDepartment().getId());
				info1.put("programmesId", e.getProgrammes().getId());
				info1.put("degreeId", e.getDegree().getId());
				
				info1.put("room", e.getRoomid() == null ?"NA" :e.getRoomid().getExName());
				info1.put("roomId", e.getRoomid() == null ?"NA" :e.getRoomid().getId());
				info1.put("exIsActive", e.getExIsActive());
				info1.put("id", e.getId());

				// List dataList1 = new LinkedList();
				List<InvigilatorDateAllocation> result = super.InvigilatorDateAllocation.findByInvigilatorId(e.getId());

				List<String> Feename = new ArrayList<String>();
				SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");

				for (int j = 0; j < result.size(); j++) {
					String[] startdate = result.get(j).getExStartDate() == null ? "NA".split("")
							: result.get(j).getExStartDate().toString().substring(0, 10).split(",");
					for (int i = 0; i < startdate.length; i++) {
						Feename.add(startdate[i]);
					}
				}
				HashMap<String, ArrayList<String>> multiMap = new HashMap<String, ArrayList<String>>();
				multiMap.put("allocateddate", (ArrayList<String>) Feename);
				info1.put("exStartDate", multiMap);
				info1.put("exStartTime", result.get(0).getExEndTime() == null ? "NA"
						: result.get(0).getExEndTime().toString().substring(0, 5));

				dataList.add(info1);
			}
			info.put("status", "2");
			info.put("details", dataList);
			return info;
			

		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			return info;
		}
		//return info;

	}

	@Override
	public Map<String, String> deleteInvigilatorAllocation(InvigilatorAllocationRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<InvigilatorAllocation> task = super.InvigilatorAllocation.findById(request.getId());
			System.out.println(">>" + request);
			if (task.isPresent()) {
				if (task.get().getExIsDelete()) {
					info.put("status", "2");
					info.put("message", "InvigilatorAllocation already deleted");
					return info;
				}
				Boolean exIsDelete = true;
				Boolean is_active = false;
				int result = super.InvigilatorAllocation.Invigilatorfordelete(exIsDelete, is_active,
						task.get().getId());
				if (result == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "InvigilatorAllocation deleted successfully");
				return info;
			}
			info.put("status", "2");
			info.put("message", "InvigilatorAllocation id not present");
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, String> updateInvigilatorAllocation(InvigilatorAllocationRequest request) {
		Map<String, String> info = new LinkedHashMap<>();
		try {
			Optional<InvigilatorAllocation> value = super.InvigilatorAllocation.findById(request.getId());
			System.out.println("ADF" + value);
			if (!value.isPresent()) {
				info.put("status", "2");
				info.put("message", "Id is not Present");
				return info;
			}
			Date date = new Date();

			int is_updated = super.InvigilatorAllocation.updateInvigilatorAllocationMethod(request.getExIsActive(),date, request.getId());
			if (is_updated == 1) {
				Boolean retvalue = saveInvigilatorAllocationDate(request, value.get());
				if (!retvalue) {
					super.InvigilatorAllocation.delete(value.get());
					info.put("status", "0");
					info.put("message", "something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "Invigilator Updeted successfully");
				return info;
			}

		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
		info.put("status", "0");
		info.put("message", "something went wrong");
		return info;
	}

	@Override
	public Map<String, Object> getExamAttendance(ExamAttendanceRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {

			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
					true);
			if (!collage.isPresent()) {
				info.put("status", "2");
				info.put("message", "College Id not Present");
				return info;
			}

			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActiveAndAcademicYearId(
					request.getCourses(), false, true, request.getAcademicYear());
			if (!courses.isPresent()) {
				info.put("status", "2");
				info.put("message", "courses not  present");
				return info;

			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}
			Optional<ExamAnnouncement> result = super.examAnnouncement
					.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!result.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}

			List<RegistrationType> registration = super.registrationType
					.findByIdAndExIsDelete(request.getRegistrationType(), false);
			if (registration.size() <= 0) {
				info.put("status", "2");
				info.put("message", "RegistrationType id not present");
				return info;
			}

			List<ExamTimeTable> examlist = super.examtimetable
					.findByExIsDeleteAndAcademicYearIdAndProgrammesIdAndExamAnnouncementIdAndRegistrationIdAndCoursesId(
							false, request.getAcademicYear(), request.getProgrammes(), request.getExamAnnouncement(),
							request.getRegistrationType(), request.getCourses());
			if (examlist.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Time table Not created");
				return info;
			}

			List<ExamAttendance> attendence = super.examAttendance
					.findByExIsDeleteAndAcademicYearIdAndCollegesIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndRegistrationId(
							false, request.getAcademicYear(), request.getColleges(), request.getCourses(),
							request.getDegree(), request.getExamAnnouncement(), request.getProgrammes(),
							request.getRegistrationType());

			if (attendence.size() == 0) {
				info.put("status", "2");
				info.put("message", "No record found");
				return info;
			}

			List dataList = new LinkedList();
			for (ExamAttendance e : attendence) {
				Map<Object, Object> timetabledata = new HashMap<Object, Object>();

				timetabledata.put("exExamAttendanceId", e.getId());
				timetabledata.put("exRemarks", e.getExRemarks());

				timetabledata.put("exBarcode", e.getExBarcode());
				timetabledata.put("exIsActive", e.getExIsActive());
				timetabledata.put("registrationType", e.getRegistration().getExName());
				timetabledata.put("exName", collage.get().getExName());
				timetabledata.put("exAddress", collage.get().getExAddress());
				timetabledata.put("exPlace", collage.get().getExPlace());
				timetabledata.put("exEmail", collage.get().getExEmail());
				timetabledata.put("academicYear", academicYearid.get().getExYear());
				timetabledata.put("programmes", Prog.get().getExName());
				timetabledata.put("degree", degree.get().getExName());
				// timetabledata.put("degree", degree.get().getExName());
				timetabledata.put("courses", courses.get().getExName());
				timetabledata.put("coursesCode", courses.get().getExCoursesCode());
				timetabledata.put("creditHour", courses.get().getCreditHours().getExCreditHourTitle());
				timetabledata.put("examAnnouncement", result.get().getExName());
				timetabledata.put("examDate", examlist.get(0).getExStartDate() == null ? "NA"
						: examlist.get(0).getExStartDate().toString().substring(0, 10));
				timetabledata.put("examTime", examlist.get(0).getExStartTime());
				dataList.add(timetabledata);
				info.put("details", dataList);

			}

			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> updateExamTimeTableDetails(ExamTimeTableRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			if (request.getExTimeTableId() == null || request.getExTimeTableId().equals("")) {
				info.put("status", "2");
				info.put("message", "ExTimeTableId is required");
				return info;
			}

			if (request.getExStartDate() == null || request.getExStartDate().equals("")) {
				info.put("status", "2");
				info.put("message", "ExStartDate is required");
				return info;
			}

			Optional<ExamTimeTable> task = super.examtimetable.findById(request.getExTimeTableId());
			if (!task.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExTimeTableId not present");
				return info;
			}

			SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");
			SimpleDateFormat time = new SimpleDateFormat("HH:MM");
			Boolean is_update = true;
			Date modifieddate = new Date();

			User userid = super.commonHelper.getuser(request.getUser());
			String Description = request.toString();
			Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, 39L);
			int updatresult = super.examtimetable.updateExamTimeTable(date1.parse(request.getExStartDate()), is_update,
					request.getExTimeTableId(), modifieddate);
			if (updatresult == 0) {
				info.put("status", "2");
				info.put("message", "Something went wrong");
				return info;
			}
			info.put("status", "1");
			info.put("message", "ExamTimeTable updated successfully");
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;

		}
	}
private Workbook getWorkBook(MultipartFile File) {
		
	    Workbook workbook = null;
	      String extention = FilenameUtils.getExtension(File.getOriginalFilename());
	       try {
	           if(extention.equalsIgnoreCase("xlsx")) {
	               workbook =  new XSSFWorkbook(File.getInputStream());

	           }else if (extention.equalsIgnoreCase("xls")) {
	             workbook = new XSSFWorkbook(File.getInputStream());  
	           }
	    } catch (Exception e) {
	        e.printStackTrace();
	    }

	    return workbook;
	} 

	@Override
	public Map<String, Object> uploadQuestionPaper(QuestionpaperRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		String extention = FilenameUtils.getExtension(request.getExQuestionpaperFile().getOriginalFilename());
		if (extention.equalsIgnoreCase("xls") || extention.equalsIgnoreCase("xlsx")) {
			Map<String, Object> result = readDataFromQuestionExcel(request.getExQuestionpaperFile(),request);
			return result;
		}
		info.put("status", "2");
		info.put("message", "File should be xls / xlsx extention");
		return info;
	}
	private Map<String, Object> readDataFromQuestionExcel(MultipartFile exquestionpaperFile,QuestionpaperRequest request) {

	List<Object> list = new ArrayList<Object>();
	List<String> ATQsuccessList = new ArrayList<String>();
	Map<String, Object> info = new LinkedHashMap<>();
	
	Map<String, Object> mcqvalue = new LinkedHashMap<>();
	Map<String, Object> TOFvalue = new LinkedHashMap<>();
	Map<String, Object> MTFvalue = new LinkedHashMap<>();
	Map<String, Object> ATQvalue = new LinkedHashMap<>();
	Map<String, Object> AFQvalue = new LinkedHashMap<>();


	try {
		
		Workbook workbook = getWorkBook(exquestionpaperFile);
		
		
		Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
				request.getAcademicYear());
		if (!academicYearid.isPresent()) {
			info.put("status", "2");
			info.put("message", "AcademicYear id not present");
			return info;
		}
		Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
				request.getProgrammes());
		if (!Prog.isPresent()) {
			info.put("status", "2");
			info.put("message", "Programmes not present");
			return info;
		}
		Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActiveAndAcademicYearId(
				request.getCourses(), false, true, request.getAcademicYear());
		if (!courses.isPresent()) {
			info.put("status", "2");
			info.put("message", "courses not  present");
			return info;

		}
		Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
		if (!degree.isPresent()) {
			info.put("status", "2");
			info.put("message", "Degree not present");
			return info;
		}
		Optional<Department> departments = super.department.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDepartment());
		if (!departments.isPresent()) {
			info.put("status", "2");
			info.put("message", "department not present");
			return info;
		}
		Optional<ExamAnnouncement> examann = super.examAnnouncement
				.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
		if (!examann.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncement id not present");
			return info;
		}
		
			User userresult=null ;
			if(request.getUser()== null || request.getUser().equals("")) {
				userresult=null;
			}else {
				List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false,true);		
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
				}
				userresult=user.get(0);
			}
			
			
	     List<QuestionPaperPattern> QuestionPaperPatternresult =super.QuestionPaperPattern.findByExIsDeleteAndExIsActiveAndCoursesIdAndProgrammesId( false, true ,request.getCourses(),request.getProgrammes());
			 if (QuestionPaperPatternresult.size()<=0) {
				 info.put("status", "2");
				 info.put("message", "QuestionPaperPattern not created for particular program course.");
					return info;	
				}
			
			
			
			  List<QuestionPaper> Questionpapercheck =super.QuestionPaper. findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesId(  false , true ,request.getAcademicYear(),request.getCourses(),request.getDegree(),request. getExamAnnouncement(),request.getProgrammes());
			  if (Questionpapercheck.size()>0) {
			  info.put("status", "2");
			  info.put("message", "Questionpaper already present"); 
			  return info;
			  
			  }
			
			 for(int n=0;n<workbook.getNumberOfSheets();n++){
					Sheet sheet = workbook.getSheetAt(n);
					Optional<QuestionPaperTopic> QuestionPaperTopic = super.QuestionPaperTopic.findByExIsDeleteAndExIsActiveAndExIdentifier( false, true ,sheet.getSheetName());
					 if (!QuestionPaperTopic.isPresent()) {
						 mcqvalue.put("status", "2");
						 mcqvalue.put("message", "QuestionPaperTopic not present");
							return mcqvalue;	
						}
				
					 Optional<QuestionPaperPattern> QuestionPaperPattern =super.QuestionPaperPattern.findByExIsDeleteAndExIsActiveAndQuestionPaperTopicIdAndCoursesId( false, true ,QuestionPaperTopic.get().getId(),request.getCourses());

					 if (!QuestionPaperPattern.isPresent()) {
						 mcqvalue.put("status", "2");
						 mcqvalue.put("message", "QuestionPaperPattern not mapped with question paper topic::"+sheet.getSheetName()+"for particular course::"+courses.get().getExCoursesCode());
							return mcqvalue;	
						}
					 
					 
					 Optional<QuestionPaperType> QuestionPaperType =super.questionpaperType.findByIdAndExIsDeleteAndExIsActive(QuestionPaperPattern.get().getQuestionPaperType().getId(), false, true );
					 if (!QuestionPaperType.isPresent()) {
						 mcqvalue.put("status", "2");
						 mcqvalue.put("message", "QuestionPaper Type");
							return mcqvalue;	
						}
					}
			 
			 
			 
			int totalmcq; 
		for(int l=0;l<=workbook.getNumberOfSheets();l++){			
		if(l==0){

			     int qpnum=1;
				 TOFvalue = TOFQuestionsheet(exquestionpaperFile,request,l,academicYearid,examann,courses,degree,qpnum,departments,Prog);				
				 excellog.info("Data  Inserted : " + TOFvalue);
				 System.out.println("????????info0?????????"+TOFvalue);  	
		 }
		 if(l==1){
			 int i=Integer.parseInt( TOFvalue.toString().substring(9).replace("}",""));
			 int qpnum=i+1;
			 MTFvalue = MTFQuestionsheet(exquestionpaperFile,request,l,academicYearid,examann,courses,degree,qpnum,departments,Prog);				
			 excellog.info("Data  Inserted : " + MTFvalue);
			 System.out.println("????????info1?????????"+MTFvalue);
		  }	
	 if(l==2){
		int j=Integer.parseInt(TOFvalue.toString().substring(9).replace("}",""));
		int	 k=Integer.parseInt( MTFvalue.toString().substring(9).replace("}",""));					
	    int qpnum=k+j+1;
        mcqvalue = MCQuestionsheet(exquestionpaperFile,request,l,academicYearid,examann,courses,degree,qpnum,departments,Prog);				
        excellog.info("Data  Inserted : " + mcqvalue);
        System.out.println("????????info2?????????"+mcqvalue);
	}	
	 if(l==3){
			int m=Integer.parseInt(MTFvalue.toString().substring(9).replace("}",""));
			int j=Integer.parseInt(TOFvalue.toString().substring(9).replace("}",""));
			int	 k=Integer.parseInt(mcqvalue.toString().substring(9).replace("}",""));					
			int qpnum=m+k+j+1;
			AFQvalue =  AFQQuestionsheet(exquestionpaperFile,request,l,academicYearid,examann,courses,degree,qpnum,departments,Prog);				
			excellog.info("Data  Inserted : " + AFQvalue);
			System.out.println("????????info3?????????"+AFQvalue);

	}	 
	 
	 
	if(l==4){
			int m=Integer.parseInt(MTFvalue.toString().substring(9).replace("}",""));
			int j=Integer.parseInt(TOFvalue.toString().substring(9).replace("}",""));
			int	k=Integer.parseInt( mcqvalue.toString().substring(9).replace("}",""));	
			int n=Integer.parseInt(AFQvalue.toString().substring(9).replace("}",""));

			int qpnum=m+k+j+1+n;
				ATQvalue =  AFQQuestionsheet(exquestionpaperFile,request,l,academicYearid,examann,courses,degree,qpnum,departments,Prog);				
					 excellog.info("Data  Inserted : " + AFQvalue);
					 System.out.println("????????info4?????????"+AFQvalue);

			}	
		if(l==5){
			int n=Integer.parseInt(ATQvalue.toString().substring(9).replace("}",""));
			int g=Integer.parseInt(AFQvalue.toString().substring(9).replace("}",""));
			int m=Integer.parseInt(MTFvalue.toString().substring(9).replace("}",""));
			int j=Integer.parseInt(TOFvalue.toString().substring(9).replace("}",""));
			int	k=Integer.parseInt(mcqvalue.toString().substring(9).replace("}",""));					
			int qpnum=g+n+m+k+j+1;
			
			Sheet Sheet = workbook.getSheetAt(5);
			Optional<QuestionPaperTopic> QuestionPaperTopics =super.QuestionPaperTopic.findByExIsDeleteAndExIsActiveAndExIdentifier( false, true ,Sheet.getSheetName());
			 if (!QuestionPaperTopics.isPresent()) {
				 info.put("status", "2");
				 info.put("message", "QuestionPaperTopic not present.");
					return info;	
				}

			 Optional<QuestionPaperPattern> QuestionPaperPatterns =super.QuestionPaperPattern.findByExIsDeleteAndExIsActiveAndQuestionPaperTopicIdAndCoursesId( false, true ,QuestionPaperTopics.get().getId(),request.getCourses());
			 if (!QuestionPaperPatterns.isPresent()) {
				 info.put("status", "2");
				 info.put("message", "QuestionPaperPattern not mapped with question paper topic::"+Sheet.getSheetName());
					return info;	
				}

			 Optional<QuestionPaperType> QuestionPaperTypes =super.questionpaperType.findByIdAndExIsDeleteAndExIsActive(QuestionPaperPatterns.get().getQuestionPaperType().getId(), false, true );
			 if (!QuestionPaperTypes.isPresent()) {
				 info.put("status", "2");
				 info.put("message", "QuestionPaper Type");
					return info;	
				}

			Iterator<Row> rows = Sheet.iterator();
			rows.next();

				while (rows.hasNext()) {
					Row row = rows.next();

				for (int cn = 0; cn <=0; cn++) {
						Cell c = row.getCell(cn);
						try {
							if (c == null) {
								info.put("status", "2");
								info.put("message", "Excel cell should not be null in"+Sheet.getSheetName());
								return info;
							}

						} catch (Exception e) {
							e.printStackTrace();
							logger.error("Exception occured" + e);
							StringWriter errors = new StringWriter();
							e.printStackTrace(new PrintWriter(errors));
							logger.error(errors.toString());
							info.put("status", "0");
							info.put("message", "something went wrong");
						}

					}

						    Date date = new Date();
						    QuestionPaper Questionpaper = new QuestionPaper();
						    Questionpaper.setExCreateDate(date);
						    Questionpaper.setExQuestion(row.getCell(0).getStringCellValue());
						    Questionpaper.setQuestionPaperPattern(QuestionPaperPatterns.get());
							Questionpaper.setExIsDelete(false);
							Questionpaper.setExIsActive(true);
							Questionpaper.setCourses(courses.get());
							Questionpaper.setAcademicYear(academicYearid.get());
							Questionpaper.setDegree(degree.get());
							Questionpaper.setDepartment(departments.get());
							Questionpaper.setProgrammes(Prog.get());
							Questionpaper.setExamAnnouncement(examann.get());
							Questionpaper.setProgrammes(examann.get().getProgrammes());
							Questionpaper.setExtype("1");
							Questionpaper.setExQuestionType(Sheet.getSheetName());
							Questionpaper.setExQuestionNum(qpnum);
							Questionpaper.setExCourseCodeNo(request.getExCourseCodeNo());
							Questionpaper.setQuestionPaperType(QuestionPaperTypes.get());
							Questionpaper.setExversion("Version-1");

							QuestionpaperRepository.save(Questionpaper);
							qpnum++;
							ATQsuccessList.add("Success" + Questionpaper);
						 }
					 excellog.info("Data  Inserted : " + ATQvalue);

			}
		
		}
		Date date =new Date();
		//User userid =CommonHelper.getuser(request.getUser()) ;
		//String Description=request.toString();			
		//Boolean audit = CommonHelper.saveauditlogdetails(false , Description ,userid, 49L);	
			
			  QuestionPaperLog QuestionPaperLog =new QuestionPaperLog();
			  QuestionPaperLog.setAcademicYear(academicYearid.get());
			  QuestionPaperLog.setCourses(courses.get());
			  QuestionPaperLog.setDegree(degree.get());
			  QuestionPaperLog.setExamAnnouncement(examann.get());
			  QuestionPaperLog.setExCreateDate(date); 
			  QuestionPaperLog.setDepartment(departments.get());
			  QuestionPaperLog.setProgrammes(Prog.get());
			  QuestionPaperLog.setExIsActive(true);
			  QuestionPaperLog.setExIsDelete(false);
			  QuestionPaperLog.setExReportType("upload");
			  QuestionPaperLog.setExVersion("Version");
			  QuestionPaperLog.setExFileName(exquestionpaperFile.getOriginalFilename());
			  QuestionPaperLog.setUser(userresult);
			  super.questionPaperLog.save(QuestionPaperLog);
			 
		
		info.put("status", "1");
		info.put("message", exquestionpaperFile.getOriginalFilename() + "Excel Uploaded Succesfully ");
		return info;
	} catch (Exception e) {
		logger.error("Exception occured" + e);
		StringWriter errors = new StringWriter();
		e.printStackTrace(new PrintWriter(errors));
		logger.error(errors.toString());
		info.put("status", "0");
		info.put("message", "something went wrong");
		return info;
	}
}

private Map<String, Object> AFQQuestionsheet(MultipartFile exquestionpaperFile, QuestionpaperRequest request,
		int l, Optional<AcademicYear> academicYearid, Optional<ExamAnnouncement> examannouncement,
		Optional<Courses> course, Optional<Degree> degree, int qpnum, Optional<Department> departments, Optional<Programmes> prog) {
Map<String, Object> info = new LinkedHashMap<>();
List<String>AFQsuccessList = new ArrayList<String>();

try {
	Workbook workbook = getWorkBook(exquestionpaperFile);
	Sheet Sheet = workbook.getSheetAt(l);
    logger.info(">>>>>>>>>>>>>>>>>Sheet.getSheetName()>>>>>>>>>>>>>"+Sheet.getSheetName());

	Optional<QuestionPaperTopic> QuestionPaperTopic =super.QuestionPaperTopic.findByExIsDeleteAndExIsActiveAndExIdentifier( false, true ,Sheet.getSheetName());
	 if (!QuestionPaperTopic.isPresent()) {
		 info.put("status", "2");
		 info.put("message", "QuestionPaperTopic not present");
			return info;	
		}
        logger.info(">>>>>>>>>>>>>>>>>QuestionPaperTopic>>>>>>>>>>>>>"+QuestionPaperTopic.get().getId());

	 Optional<QuestionPaperPattern> QuestionPaperPattern =super.QuestionPaperPattern.findByExIsDeleteAndExIsActiveAndQuestionPaperTopicIdAndCoursesId( false, true ,QuestionPaperTopic.get().getId(),request.getCourses());
	 if (!QuestionPaperPattern.isPresent()) {
		 info.put("status", "2");
		 info.put("message", "QuestionPaperPattern not mapped with question paper topic");
		 return info;	
		}
        logger.info(">>>>>>>>>>>>>>dsfd>>>QuestionPaperPattern.get().QuestionPaperPattern().getId()>>>>>>>>>>>>>"+QuestionPaperPattern.get().getId());

        logger.info(">>>>>>>>>>>>>>>>>QuestionPaperPattern.get().getQuestionPaperType().getId()>>>>>>>>>>>>>"+QuestionPaperPattern.get());

	 Optional<QuestionPaperType> QuestionPaperType =super.questionpaperType.findByIdAndExIsDeleteAndExIsActive(QuestionPaperPattern.get().getQuestionPaperType().getId(), false, true );
	 if (!QuestionPaperType.isPresent()) {
		 info.put("status", "2");
		 info.put("message", "QuestionPaper Type");
			return info;	
		}
    logger.info(">>>>>>>>>>>>>>>>>QuestionPaperType>>>>>>>>>>>>>"+QuestionPaperType.get().getId());
	Iterator<Row> rows = Sheet.iterator();
	rows.next();

		while (rows.hasNext()) {
			Row row = rows.next();

		for (int cn = 0; cn <=0; cn++) {
				Cell c = row.getCell(cn);
				try {
					if (c == null) {
						info.put("status", "2");
						info.put("message", "Excel cell should not be null in"+Sheet.getSheetName());
						return info;
					}

				} catch (Exception e) {
					e.printStackTrace();
					logger.error("Exception occured" + e);
					StringWriter errors = new StringWriter();
					e.printStackTrace(new PrintWriter(errors));
					logger.error(errors.toString());
					info.put("status", "0");
					info.put("message", "something went wrong");
				}

			}

				    Date date = new Date();
				    QuestionPaper Questionpaper = new QuestionPaper();
				    Questionpaper.setExCreateDate(date);
				    Questionpaper.setExQuestion(row.getCell(0).getStringCellValue());
				    Questionpaper.setQuestionPaperPattern(QuestionPaperPattern.get());
					Questionpaper.setExIsDelete(false);
					Questionpaper.setExIsActive(true);
					Questionpaper.setCourses(course.get());
					Questionpaper.setAcademicYear(academicYearid.get());
					Questionpaper.setDegree(degree.get());
					Questionpaper.setExamAnnouncement(examannouncement.get());
					Questionpaper.setExtype("1");
					Questionpaper.setDepartment(departments.get());
					Questionpaper.setExQuestionType(Sheet.getSheetName());
					Questionpaper.setExQuestionNum(qpnum);
					Questionpaper.setProgrammes(examannouncement.get().getProgrammes());
					Questionpaper.setExversion("Version-1");
					Questionpaper.setExCourseCodeNo(request.getExCourseCodeNo());
					Questionpaper.setQuestionPaperType(QuestionPaperType.get());
				    QuestionpaperRepository.save(Questionpaper);
					qpnum++;
					AFQsuccessList.add("Success" + Questionpaper);
				 }

		info.put("success",AFQsuccessList.size());
		return info;

}catch (Exception e) {
	logger.error("Exception occured" + e);
	StringWriter errors = new StringWriter();
	e.printStackTrace(new PrintWriter(errors));
	logger.error(errors.toString());
	info.put("status", "0");
	info.put("message", "something went wrong");
	return info;
}
}

private Map<String, Object> MTFQuestionsheet(MultipartFile exquestionpaperFile, QuestionpaperRequest request,
		int l, Optional<AcademicYear> academicYearid, Optional<ExamAnnouncement> examannouncement,
		Optional<Courses> course, Optional<Degree> degree, int qpnum, Optional<Department> departments, Optional<Programmes> prog) {
Map<String, Object> info = new LinkedHashMap<>();
List<String> MTFsuccessList = new ArrayList<String>();

try {
	Workbook workbook = getWorkBook(exquestionpaperFile);
	Sheet Sheet = workbook.getSheetAt(l);
	Optional<QuestionPaperTopic> QuestionPaperTopic =super.QuestionPaperTopic.findByExIsDeleteAndExIsActiveAndExIdentifier( false, true ,Sheet.getSheetName());
	 if (!QuestionPaperTopic.isPresent()) {
		 info.put("status", "2");
		 info.put("message", "QuestionPaperTopic not present.");
			return info;	
		}
	 Optional<QuestionPaperPattern> QuestionPaperPattern =super.QuestionPaperPattern.findByExIsDeleteAndExIsActiveAndQuestionPaperTopicIdAndCoursesId( false, true ,QuestionPaperTopic.get().getId(),request.getCourses());
	 if (!QuestionPaperPattern.isPresent()) {
		 info.put("status", "2");
		 info.put("message", "QuestionPaperPattern not mapped with question paper topic");
			return info;	
		}

	 Optional<QuestionPaperType> QuestionPaperType =super.questionpaperType.findByIdAndExIsDeleteAndExIsActive(QuestionPaperPattern.get().getQuestionPaperType().getId(), false, true );
	 if (!QuestionPaperType.isPresent()) {
		 info.put("status", "2");
		 info.put("message", "QuestionPaper Type");
			return info;	
		}
	
	Iterator<Row> rows = Sheet.iterator();
	rows.next();

	while (rows.hasNext()) {
		Row row = rows.next();

	for (int cn = 0; cn <=1; cn++) {
			Cell c = row.getCell(cn);
			try {
				if (c == null) {
					// The spreadsheet is empty in this cell
					info.put("status", "2");
					info.put("message", "Excel cell should not be null"+Sheet.getSheetName());
					return info;
				}

			} catch (Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
			}

		}

	Date date = new Date();
    QuestionPaper Questionpaper = new QuestionPaper();
    Questionpaper.setExCreateDate(date);
    Questionpaper.setExQuestion(row.getCell(0).getStringCellValue());
    Questionpaper.setExkeyAnswer(row.getCell(1).getStringCellValue());
    Questionpaper.setQuestionPaperPattern(QuestionPaperPattern.get());
	Questionpaper.setExIsDelete(false);
	Questionpaper.setDepartment(departments.get());
	Questionpaper.setExIsActive(true);
	Questionpaper.setCourses(course.get());
	Questionpaper.setAcademicYear(academicYearid.get());
	Questionpaper.setDegree(degree.get());
	Questionpaper.setExamAnnouncement(examannouncement.get());
	Questionpaper.setProgrammes(prog.get());

	Questionpaper.setExversion("Version-1");
	Questionpaper.setExtype("1");
	Questionpaper.setExQuestionType(Sheet.getSheetName());
	Questionpaper.setExQuestionNum(qpnum);
	Questionpaper.setExCourseCodeNo(request.getExCourseCodeNo());
	Questionpaper.setQuestionPaperType(QuestionPaperType.get());
    QuestionpaperRepository.save(Questionpaper);
	qpnum++;
	MTFsuccessList.add("Success" + Questionpaper);
	excellog.info("Data  Inserted : " + MTFsuccessList.size()+ " Records Inserted Successfully."+Sheet.getSheetName());

			 }
  

		info.put("success",MTFsuccessList.size());
		return info;

}catch (Exception e) {
	logger.error("Exception occured" + e);
	StringWriter errors = new StringWriter();
	e.printStackTrace(new PrintWriter(errors));
	logger.error(errors.toString());
	info.put("status", "0");
	info.put("message", "something went wrong");
	return info;

}
}

private Map<String, Object> TOFQuestionsheet(MultipartFile exquestionpaperFile,QuestionpaperRequest request, int l,Optional<AcademicYear> academicYearid,Optional<ExamAnnouncement> examannouncement,	Optional<Courses> course, Optional<Degree> degree, int qpnum, Optional<Department> departments, Optional<Programmes> prog) {
Map<String, Object> info = new LinkedHashMap<>();
List<String> TOFsuccessList = new ArrayList<String>();

try {
	Workbook workbook = getWorkBook(exquestionpaperFile);
	Sheet Sheet = workbook.getSheetAt(l);
	Optional<QuestionPaperTopic> QuestionPaperTopic =super.QuestionPaperTopic.findByExIsDeleteAndExIsActiveAndExIdentifier( false, true ,Sheet.getSheetName());
	 if (!QuestionPaperTopic.isPresent()) {
		 info.put("status", "2");
		 info.put("message", "QuestionPaperTopic not present");
			return info;	
		}
	
	 Optional<QuestionPaperPattern> QuestionPaperPattern =super.QuestionPaperPattern.findByExIsDeleteAndExIsActiveAndQuestionPaperTopicIdAndCoursesId( false, true ,QuestionPaperTopic.get().getId(),request.getCourses());
	 if (!QuestionPaperPattern.isPresent()) {
		 info.put("status", "2");
		 info.put("message", "QuestionPaperPattern not mapped with question paper topic");
			return info;	
		}

	 
	 Optional<QuestionPaperType> QuestionPaperType =super.questionpaperType.findByIdAndExIsDeleteAndExIsActive(QuestionPaperPattern.get().getQuestionPaperType().getId(), false, true );
	 if (!QuestionPaperType.isPresent()) {
		 info.put("status", "2");
		 info.put("message", "QuestionPaper Type");
			return info;	
		}
	Iterator<Row> rows = Sheet.iterator();
	rows.next();

		while (rows.hasNext()) {
			Row row = rows.next();

		for (int cn = 0; cn <=1; cn++) {
				Cell c = row.getCell(cn);
				try {
					if (c == null) {
						info.put("status", "2");
						info.put("message", "Excel cell should not be null in"+Sheet.getSheetName());
						return info;
					}

				} catch (Exception e) {
					e.printStackTrace();
					logger.error("Exception occured" + e);
					StringWriter errors = new StringWriter();
					e.printStackTrace(new PrintWriter(errors));
					logger.error(errors.toString());
					info.put("status", "0");
					info.put("message", "something went wrong");
				}

			}
		
		System.out.println("????????????Sheet.getSheetName()1??????????????????"+Sheet.getSheetName());

				    Date date = new Date();
				    QuestionPaper Questionpaper = new QuestionPaper();
				    Questionpaper.setExCreateDate(date);
				    Questionpaper.setExQuestion(row.getCell(0).getStringCellValue());
				    Questionpaper.setExkeyAnswer(row.getCell(1).getStringCellValue());
				    Questionpaper.setQuestionPaperPattern(QuestionPaperPattern.get());
					Questionpaper.setExIsDelete(false);
					Questionpaper.setDepartment(departments.get());
					Questionpaper.setExIsActive(true);
					Questionpaper.setCourses(course.get());
					Questionpaper.setAcademicYear(academicYearid.get());
					Questionpaper.setDegree(degree.get());
					Questionpaper.setExamAnnouncement(examannouncement.get());
					Questionpaper.setProgrammes(prog.get());

					Questionpaper.setExversion("Version-1");
					Questionpaper.setExtype("1");
					Questionpaper.setExQuestionType(Sheet.getSheetName());
					Questionpaper.setExQuestionNum(qpnum);
					Questionpaper.setExCourseCodeNo(request.getExCourseCodeNo());
					Questionpaper.setQuestionPaperType(QuestionPaperType.get());
				    QuestionpaperRepository.save(Questionpaper);
					qpnum++;
				    TOFsuccessList.add("Success" + Questionpaper);
				 }

		info.put("success",TOFsuccessList.size());
		return info;

}catch (Exception e) {
	logger.error("Exception occured" + e);
	StringWriter errors = new StringWriter();
	e.printStackTrace(new PrintWriter(errors));
	logger.error(errors.toString());
	info.put("status", "0");
	info.put("message", "something went wrong");
	return info;

}
}

private Map<String, Object> MCQuestionsheet(
		MultipartFile exquestionpaperFile,
		QuestionpaperRequest request, int l, Optional<AcademicYear> academicYearid, Optional<ExamAnnouncement> examannouncement, Optional<Courses> course, Optional<Degree> degree, int qpnum, Optional<Department> departments, Optional<Programmes> prog) {
Map<String, Object> mcqvalue = new LinkedHashMap<>();
try {
	Workbook workbook = getWorkBook(exquestionpaperFile);
	Sheet sheet = workbook.getSheetAt(l);
	
	Optional<QuestionPaperTopic> QuestionPaperTopic =super.QuestionPaperTopic.findByExIsDeleteAndExIsActiveAndExIdentifier( false, true ,sheet.getSheetName());
	 if (!QuestionPaperTopic.isPresent()) {
		 mcqvalue.put("status", "2");
		 mcqvalue.put("message", "QuestionPaperTopic not present");
			return mcqvalue;	
		}

	 Optional<QuestionPaperPattern> QuestionPaperPattern =super.QuestionPaperPattern.findByExIsDeleteAndExIsActiveAndQuestionPaperTopicIdAndCoursesId( false, true ,QuestionPaperTopic.get().getId(),request.getCourses());

	 if (!QuestionPaperPattern.isPresent()) {
		 mcqvalue.put("status", "2");
		 mcqvalue.put("message", "QuestionPaperPattern not mapped with question paper topic");
			return mcqvalue;	
		}
	 
	 
	 Optional<QuestionPaperType> QuestionPaperType =super.questionpaperType.findByIdAndExIsDeleteAndExIsActive(QuestionPaperPattern.get().getQuestionPaperType().getId(), false, true );
	 if (!QuestionPaperType.isPresent()) {
		 mcqvalue.put("status", "2");
		 mcqvalue.put("message", "QuestionPaper Type");
			return mcqvalue;	
		}

     List<QuestionPaper> questionList = new ArrayList<QuestionPaper>();
	int num = 0;
	int incrementor = 2;
	QuestionPaper qut = null;
	QuestionOptionMapping ans = null;
	QuestionOptionMapping ans1 = null;
	QuestionOptionMapping ans2 = null;
	QuestionOptionMapping ans3 = null;
	int count = 0;
	
	for (int i = 1; i <= sheet.getPhysicalNumberOfRows()/3; i++) {
		if (incrementor >= i) {
			qut = new QuestionPaper();
			ans = new QuestionOptionMapping();
			ans1 = new QuestionOptionMapping();
			ans2 = new QuestionOptionMapping();
			ans3 = new QuestionOptionMapping();
			if (i == 2) {
				count = i;
			} else {
				count = incrementor;
			}
			num = 0;
		}
		for (int row = count - 1; row <=count + 1; row++) {
			Row record = sheet.getRow(row);
			num++;

			// Question
			if (num == 1) {
				for (int col = 0; col <= 2; col++) {
					if (col == 0) {
						Cell cell = record.getCell(col);
								qut.setExQuestion(cell.getStringCellValue());
					}
					if (col == 2) {
						Cell cell = record.getCell(col);
						Date date =new Date();
							qut.setExkeyAnswer(cell.getStringCellValue());
							qut.setAcademicYear(academicYearid.get());
							qut.setCourses(course.get());
							qut.setDegree(degree.get());
							qut.setDepartment(departments.get());
							qut.setExamAnnouncement(examannouncement.get());
							qut.setProgrammes(prog.get());

							qut.setQuestionPaperPattern(QuestionPaperPattern.get());
							qut.setExIsActive(true);
							qut.setExIsDelete(false);
							qut.setExCreateDate(date);
							qut.setExversion("Version-1");
							qut.setExtype("1");
							qut.setExQuestionType(sheet.getSheetName());
							qut.setExQuestionNum(qpnum);
							qut.setExCourseCodeNo(request.getExCourseCodeNo());
							qut.setQuestionPaperType(QuestionPaperType.get());
							QuestionpaperRepository.save(qut);
					}
				}qpnum++;
				
			}

			// option cell 2
			if (num == 2) {
				for (int col = 0; col < 2; col++) {
					if (col == 0) {
						System.out.println("Record..........." + record);
						Cell cell = record.getCell(col);
								System.out.println("num 2 col 0------" + cell);
							ans.setExOptionValue(cell.getStringCellValue());
							// ans.setOption1(ans.getOption1()+" "+cell.getStringCellValue());
					}
					if (col == 1) {
						Cell cell = record.getCell(col);
								System.out.println("num 2 col 1------" + cell);
							ans1.setExOptionValue(cell.getStringCellValue());
							// ans.setOption1(ans.getOption1()+" "+cell.getStringCellValue());
					}
				}
			}

			// option Cell 3
			if (num == 3) {
				for (int col = 0; col < 2; col++) {
					if (col == 0) {
						Cell cell = record.getCell(col);
								System.out.println("num 3 col 0------" + cell);
							ans2.setExOptionValue(cell.getStringCellValue());
							// ans.setOption1(ans.getOption1()+" "+cell.getStringCellValue());
					}
					if (col == 1) {
						Cell cell = record.getCell(col);
								System.out.println("num 3 col 1------" + cell);
							ans3.setExOptionValue(cell.getStringCellValue());
							// ans.setOption1(ans.getOption1()+" "+cell.getStringCellValue());
					}
				}
			}
			incrementor++;
		}
		ans.setExQuestionType(sheet.getSheetName());
		ans.setQuestionPaperPattern(QuestionPaperPattern.get());
		ans.setQuestionPaper(qut);
		QuestionOptionMappingRepository.save(ans);
		
		ans1.setExQuestionType(sheet.getSheetName());
		ans1.setQuestionPaperPattern(QuestionPaperPattern.get());
		ans1.setQuestionPaper(qut);
		QuestionOptionMappingRepository.save(ans1);

		ans2.setExQuestionType(sheet.getSheetName());
		ans2.setQuestionPaperPattern(QuestionPaperPattern.get());
		ans2.setQuestionPaper(qut);
		QuestionOptionMappingRepository.save(ans2);

		ans3.setExQuestionType(sheet.getSheetName());
		ans3.setQuestionPaperPattern(QuestionPaperPattern.get());
		ans3.setQuestionPaper(qut);
		QuestionOptionMappingRepository.save(ans3);

		questionList.add(qut);	
	}			
	for (int j = 0; j <questionList.size(); j++) {
		System.out.println(j + 1 + "\t" + questionList.get(j));
	}
	mcqvalue.put("success", questionList.size() );
	return mcqvalue;

}catch (Exception e) {
	logger.error("Exception occured" + e);
	StringWriter errors = new StringWriter();
	e.printStackTrace(new PrintWriter(errors));
	logger.error(errors.toString());
	mcqvalue.put("status", "0");
	mcqvalue.put("message", "something went wrong");
	return mcqvalue;

}
}

@Override
public Map<String, Object> saveJumble(QuestionpaperRequest request) {
	Map<String, Object> info = new LinkedHashMap<>();
	try {
		System.out.println("???????????????????????????????"+request);
			
			  if (request.getExVersion() == null|| request.getExVersion().equals("")||
			  request.getExVersion().equals("NA")) { info.put("status", "2");
			  info.put("message", "Please1 select Versions "); return info; }
			 

		Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
				request.getAcademicYear());
		if (!academicYearid.isPresent()) {
			info.put("status", "2");
			info.put("message", "AcademicYear id not present");
			return info;
		}
		Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
				request.getProgrammes());
		if (!Prog.isPresent()) {
			info.put("status", "2");
			info.put("message", "Programmes not present");
			return info;
		}
		Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActiveAndAcademicYearId(
				request.getCourses(), false, true, request.getAcademicYear());
		if (!courses.isPresent()) {
			info.put("status", "2");
			info.put("message", "courses not  present");
			return info;

		}
		Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
		if (!degree.isPresent()) {
			info.put("status", "2");
			info.put("message", "Degree not present");
			return info;
		}
		Optional<Department> departments = super.department.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDepartment());
		if (!departments.isPresent()) {
			info.put("status", "2");
			info.put("message", "department not present");
			return info;
		}
		Optional<ExamAnnouncement> examann = super.examAnnouncement.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
		if (!examann.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncement id not present");
			return info;
		}
		
			
	   List<QuestionPaper> Questionpapercheck = QuestionpaperRepository.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndProgrammesIdAndDepartmentId( false , true ,request.getAcademicYear(),request.getCourses(),request.getDegree(),request.getExamAnnouncement(),request.getProgrammes(),request.getDepartment());
			 if (Questionpapercheck.size()<=0) {
					info.put("status", "2");
					info.put("message", "Questionpaper not present");
					return info;
				}
			 
			 User userresult=null ;
				if(request.getUser()== null || request.getUser().equals("")) {
					userresult=null;
				}else {
					List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false,true);		
					if (user.size() <= 0) {
						info.put("status", "2");
						info.put("message", "User id not present");
						return info;
					}
					userresult=user.get(0);
				}	 
			 
	    String listgetVersion[] = request.getExVersion().split(",");	
	    List<String> versionList = Arrays.asList(listgetVersion);  
	    List<QuestionPaperVersion> versions = super.QuestionPaperVersion.findByAcademicYearIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndExVersionInAndProgrammesIdAndDepartmentId(request.getAcademicYear(),request.getCourses(),request.getDegree(),request.getExamAnnouncement(),versionList,request.getProgrammes(),request.getDepartment());	
		  if (versions.size()>0) {
				info.put("status", "2");
				info.put("message", versions.get(0).getClass()+":versions present for particular:"+versions.get(0).getCourses().getExCoursesCode());
				return info;
			}

		for(int i =0 ;i<listgetVersion.length ; i++){	
      
//---------------------------------Jumbling for TOF------------------------------//	 
		 List<QuestionPaper> TOF = QuestionpaperRepository.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndExQuestionTypeAndExversion( false , true ,request.getAcademicYear(),request.getCourses(),request.getDegree(),request.getExamAnnouncement(),"TOF","Version-1");
		 if (TOF.size()<=0) {
				info.put("status", "2");
				info.put("message", "TOF Question not present");
				return info;
			}
		 
		 Collections.shuffle(TOF); 
	      List<QuestionPaperVersion> TOFquestionList = new ArrayList<QuestionPaperVersion>();

		int countvalue= 1;
	      System.out.println("\nShuffled List : \n" +  TOF);
	       for(QuestionPaper e: TOF){
	    	   Optional<QuestionPaper> Questionpaperid = super.QuestionPaper.findByExQuestionAndCoursesIdAndAcademicYearIdAndExamAnnouncementId(e.getExQuestion(),request.getCourses(),request.getAcademicYear(),request.getExamAnnouncement());
				if (!Questionpaperid.isPresent()) {
					info.put("status", "2");
					info.put("message", "Question not present ");
					return info;
				}
			QuestionPaperVersion Questionpaper =new QuestionPaperVersion();
	        Questionpaper.setAcademicYear(e.getAcademicYear());
		    Questionpaper.setExQuestion(e.getExQuestion());
		    Questionpaper.setExkeyAnswer(e.getExkeyAnswer());
		    Questionpaper.setQuestionPaperPattern(e.getQuestionPaperPattern());
			Questionpaper.setCourses(courses.get());
			Questionpaper.setAcademicYear(academicYearid.get());
			Questionpaper.setDegree(degree.get());
			Questionpaper.setExVersion(listgetVersion[i]);
			Questionpaper.setExType("1");
			Questionpaper.setProgrammes(Prog.get());
			Questionpaper.setDepartment(departments.get());
			Questionpaper.setExamAnnouncement(examann.get());
			Questionpaper.setExQuestionType(e.getExQuestionType());
			Questionpaper.setExQuestionNum(countvalue);
			Questionpaper.setQuestionPaper(Questionpaperid.get());
			Questionpaper.setExCourseCodeNo(e.getExCourseCodeNo());

			super.QuestionPaperVersion.save(Questionpaper);
			TOFquestionList.add(Questionpaper);
			countvalue++;
			
	}
		
	//---------------------------------Jumbling for MTF------------------------------//	 

		
		 List<QuestionPaper> MTF = super.QuestionPaper.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndExQuestionTypeAndExversion( false , true ,request.getAcademicYear(),request.getCourses(),request.getDegree(),request.getExamAnnouncement(),"FIB","Version-1");
		 if (MTF.size()<=0) {
				info.put("status", "2");
				info.put("message", "MTF Question not present");
				return info;
			}
	      List<QuestionPaperVersion> MTFquestionList = new ArrayList<QuestionPaperVersion>();

		 Collections.shuffle(MTF); 
			int value= TOFquestionList.size()+1;

	      System.out.println("\nShuffled List : \n" + MTF);
	       for(QuestionPaper e: MTF){
	    	   Optional<QuestionPaper> Questionpaperid = super.QuestionPaper.findByExQuestionAndCoursesIdAndAcademicYearIdAndExamAnnouncementId(e.getExQuestion(),request.getCourses(),request.getAcademicYear(),request.getExamAnnouncement());
				if (!Questionpaperid.isPresent()) {
					info.put("status", "2");
					info.put("message", "Question not present ");
					return info;
				}
	    	   
	    	   
	     QuestionPaperVersion Questionpaper =new QuestionPaperVersion();
	        Questionpaper.setAcademicYear(e.getAcademicYear());
		    Questionpaper.setExQuestion(e.getExQuestion());
		    Questionpaper.setExkeyAnswer(e.getExkeyAnswer());
		    Questionpaper.setQuestionPaperPattern(e.getQuestionPaperPattern());
			Questionpaper.setCourses(courses.get());
			Questionpaper.setAcademicYear(academicYearid.get());
			Questionpaper.setDegree(degree.get());
			Questionpaper.setExVersion(listgetVersion[i]);
			Questionpaper.setExType("1");
			Questionpaper.setProgrammes(Prog.get());
			Questionpaper.setDepartment(departments.get());
			Questionpaper.setExQuestionType(e.getExQuestionType());
			Questionpaper.setExamAnnouncement(examann.get());
			Questionpaper.setQuestionPaper(Questionpaperid.get());
			Questionpaper.setExQuestionNum(value);
			Questionpaper.setExCourseCodeNo(e.getExCourseCodeNo());

			super.QuestionPaperVersion.save(Questionpaper);
			MTFquestionList.add(Questionpaper);
			value++;
		
			
		}
	       
/////////////////////////////////////////////jumble MCQ////////////////////////////////////////////	       
	       List<QuestionPaper> MCQ = QuestionpaperRepository.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndExQuestionTypeAndExversionAndProgrammesIdAndDepartmentId( false , true ,request.getAcademicYear(),request.getCourses(),request.getDegree(),request.getExamAnnouncement(),"MCQ","Version-1",request.getProgrammes(),request.getDepartment());

			 if (MCQ.size()<=0) {
					info.put("status", "2");
					info.put("message", "MCQ Question not present");
					return info;
				}
			 
			 Collections.shuffle(MCQ); 
			 
		      System.out.println("\nShuffled List : \n" +  MCQ);
		      int count =TOFquestionList.size()+MTFquestionList.size()+1;
		      List<QuestionPaperVersion> MCQquestionList = new ArrayList<QuestionPaperVersion>();
		       for(QuestionPaper e: MCQ){
		    	 //  Optional<QuestionPaper> Questionpaperid = super.QuestionPaper.findByExQuestionAndCoursesIdAndAcademicYearIdAndExamAnnouncementId(e.getExQuestion(),request.getCourses(),request.getAcademicYear(),request.getExamAnnouncement());
					//if (!Questionpaperid.isPresent()) {
					//	info.put("status", "2");
					//	info.put("message", "Question not present. ");
						//return info;
					//}
		    	   
		    	QuestionPaperVersion Questionpaper =new QuestionPaperVersion();
		        Questionpaper.setAcademicYear(e.getAcademicYear());
			    Questionpaper.setExQuestion(e.getExQuestion());
			    Questionpaper.setExkeyAnswer(e.getExkeyAnswer());
			    Questionpaper.setQuestionPaperPattern(e.getQuestionPaperPattern());
				Questionpaper.setCourses(courses.get());
				Questionpaper.setAcademicYear(academicYearid.get());
				Questionpaper.setDegree(degree.get());
				Questionpaper.setExVersion(listgetVersion[i]);
				Questionpaper.setExType("1");
				Questionpaper.setExamAnnouncement(examann.get());
				Questionpaper.setExQuestionType(e.getExQuestionType());
				Questionpaper.setQuestionPaper(e);
				Questionpaper.setExQuestionNum(count);
				Questionpaper.setProgrammes(Prog.get());
				Questionpaper.setDepartment(departments.get());
				Questionpaper.setExCourseCodeNo(e.getExCourseCodeNo());
				super.QuestionPaperVersion.save(Questionpaper);
				MCQquestionList.add(Questionpaper);	
				count++;       
		}
	       
	 /////////////////////////////////jumble SAQ////////////////////////////////////////      
		       List<QuestionPaper> SAQ = QuestionpaperRepository.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndExQuestionTypeAndExversionAndProgrammesIdAndDepartmentId( false , true ,request.getAcademicYear(),request.getCourses(),request.getDegree(),request.getExamAnnouncement(),"SAQ","Version-1",request.getProgrammes(),request.getDepartment());

				 if (SAQ.size()<=0) {
						info.put("status", "2");
						info.put("message", "SAQ Question not present");
						return info;
					}
				 
				 Collections.shuffle(SAQ); 
				 
			      System.out.println("\nShuffled List : \n" +  SAQ);
			      int countSAQ =MCQquestionList.size()+TOFquestionList.size()+MTFquestionList.size()+1;
			      List<QuestionPaperVersion> SAQquestionList = new ArrayList<QuestionPaperVersion>();
			       for(QuestionPaper e: SAQ){

			    	   Optional<QuestionPaper> Questionpaperid = super.QuestionPaper.findByExQuestionAndCoursesIdAndAcademicYearIdAndExamAnnouncementId(e.getExQuestion(),request.getCourses(),request.getAcademicYear(),request.getExamAnnouncement());
						if (!Questionpaperid.isPresent()) {
							info.put("status", "2");
							info.put("message", "Question not present. ");
							return info;
						}
			    	   
			    	QuestionPaperVersion Questionpaper =new QuestionPaperVersion();
			        Questionpaper.setAcademicYear(e.getAcademicYear());
				    Questionpaper.setExQuestion(e.getExQuestion());
				    Questionpaper.setExkeyAnswer(e.getExkeyAnswer());
				    Questionpaper.setQuestionPaperPattern(e.getQuestionPaperPattern());
					Questionpaper.setCourses(courses.get());
					Questionpaper.setAcademicYear(academicYearid.get());
					Questionpaper.setDegree(degree.get());
					Questionpaper.setExVersion(listgetVersion[i]);
					Questionpaper.setExType("1");
					Questionpaper.setExamAnnouncement(examann.get());
					Questionpaper.setExQuestionType(e.getExQuestionType());
					Questionpaper.setQuestionPaper(Questionpaperid.get());
					Questionpaper.setExQuestionNum(countSAQ);
					Questionpaper.setProgrammes(Prog.get());
					Questionpaper.setDepartment(departments.get());
					Questionpaper.setExCourseCodeNo(e.getExCourseCodeNo());
					super.QuestionPaperVersion.save(Questionpaper);
					SAQquestionList.add(Questionpaper);	
					countSAQ++;       
			}   
			///////////////////////////////////////////////////MAQ////////////////////////////////////////
			       
			       
			       List<QuestionPaper> MAQ = QuestionpaperRepository.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndExQuestionTypeAndExversionAndProgrammesIdAndDepartmentId( false , true ,request.getAcademicYear(),request.getCourses(),request.getDegree(),request.getExamAnnouncement(),"MAQ","Version-1",request.getProgrammes(),request.getDepartment());

					 if (MAQ.size()<=0) {
							info.put("status", "2");
							info.put("message", "MAQ Question not present");
							return info;
						}
					 
					 Collections.shuffle(MAQ); 
					 
				      System.out.println("\nShuffled List : \n" +  MAQ);
				      int countMAQ =SAQquestionList.size()+MCQquestionList.size()+TOFquestionList.size()+MTFquestionList.size()+1;
				      List<QuestionPaperVersion> MAQquestionList = new ArrayList<QuestionPaperVersion>();
				       for(QuestionPaper e: MAQ){

				    	   Optional<QuestionPaper> Questionpaperid = super.QuestionPaper.findByExQuestionAndCoursesIdAndAcademicYearIdAndExamAnnouncementId(e.getExQuestion(),request.getCourses(),request.getAcademicYear(),request.getExamAnnouncement());
							if (!Questionpaperid.isPresent()) {
								info.put("status", "2");
								info.put("message", "Question not present. ");
								return info;
							}
				    	   
				    	QuestionPaperVersion Questionpaper =new QuestionPaperVersion();
				        Questionpaper.setAcademicYear(e.getAcademicYear());
					    Questionpaper.setExQuestion(e.getExQuestion());
					    Questionpaper.setExkeyAnswer(e.getExkeyAnswer());
					    Questionpaper.setQuestionPaperPattern(e.getQuestionPaperPattern());
						Questionpaper.setCourses(courses.get());
						Questionpaper.setAcademicYear(academicYearid.get());
						Questionpaper.setDegree(degree.get());
						Questionpaper.setExVersion(listgetVersion[i]);
						Questionpaper.setExType("1");
						Questionpaper.setExamAnnouncement(examann.get());
						Questionpaper.setExQuestionType(e.getExQuestionType());
						Questionpaper.setQuestionPaper(Questionpaperid.get());
						Questionpaper.setExQuestionNum(countMAQ);
						Questionpaper.setProgrammes(Prog.get());
						Questionpaper.setDepartment(departments.get());
						Questionpaper.setExCourseCodeNo(e.getExCourseCodeNo());
						super.QuestionPaperVersion.save(Questionpaper);
                        MAQquestionList.add(Questionpaper);	
                        countMAQ++;       
				}   		       
			       
			////////////////////////////////LAQ///////////////////////////////////////////
				       
				       List<QuestionPaper> LAQ = QuestionpaperRepository.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndCoursesIdAndDegreeIdAndExamAnnouncementIdAndExQuestionTypeAndExversionAndProgrammesIdAndDepartmentId( false , true ,request.getAcademicYear(),request.getCourses(),request.getDegree(),request.getExamAnnouncement(),"LAQ","Version-1",request.getProgrammes(),request.getDepartment());

						 if (LAQ.size()<=0) {
								info.put("status", "2");
								info.put("message", "LAQ Question not present");
								return info;
							}
						 
						 Collections.shuffle(LAQ); 
						 
					      System.out.println("\nShuffled List : \n" +  LAQ);
					      int countLAQ =MAQquestionList.size() +SAQquestionList.size()+MCQquestionList.size()+TOFquestionList.size()+MTFquestionList.size()+1;
					      List<QuestionPaperVersion>LAQquestionList = new ArrayList<QuestionPaperVersion>();
					       for(QuestionPaper e: LAQ){
					    	   
					    	   Optional<QuestionPaper> Questionpaperid = super.QuestionPaper.findByExQuestionAndCoursesIdAndAcademicYearIdAndExamAnnouncementId(e.getExQuestion(),request.getCourses(),request.getAcademicYear(),request.getExamAnnouncement());
								if (!Questionpaperid.isPresent()) {
									info.put("status", "2");
									info.put("message", "Question not present. ");
									return info;
								}
					    	   
					    	QuestionPaperVersion Questionpaper =new QuestionPaperVersion();
					        Questionpaper.setAcademicYear(e.getAcademicYear());
						    Questionpaper.setExQuestion(e.getExQuestion());
						    Questionpaper.setExkeyAnswer(e.getExkeyAnswer());
						    Questionpaper.setQuestionPaperPattern(e.getQuestionPaperPattern());
							Questionpaper.setCourses(courses.get());
							Questionpaper.setAcademicYear(academicYearid.get());
							Questionpaper.setDegree(degree.get());
							Questionpaper.setExVersion(listgetVersion[i]);
							Questionpaper.setExType("1");
							Questionpaper.setExamAnnouncement(examann.get());
							Questionpaper.setExQuestionType(e.getExQuestionType());
							Questionpaper.setQuestionPaper(Questionpaperid.get());
							Questionpaper.setExQuestionNum(countLAQ);
							Questionpaper.setProgrammes(Prog.get());
							Questionpaper.setDepartment(departments.get());
							Questionpaper.setExCourseCodeNo(e.getExCourseCodeNo());
							super.QuestionPaperVersion.save(Questionpaper);
	                        MAQquestionList.add(Questionpaper);	
	                        countLAQ++;       
					}   		      
			       
	       
	       
		}
		
		for(int i =0 ;i<listgetVersion.length ; i++){	

		Date date =new Date();
		QuestionPaperLog QuestionPaperLog =new QuestionPaperLog();
		QuestionPaperLog.setAcademicYear(academicYearid.get());
		QuestionPaperLog.setCourses(courses.get());
		QuestionPaperLog.setDegree(degree.get());
		QuestionPaperLog.setExamAnnouncement(examann.get());
		QuestionPaperLog.setExCreateDate(date);
		QuestionPaperLog.setExIsActive(true);
		QuestionPaperLog.setExIsDelete(false);
		QuestionPaperLog.setExReportType("Jumble");
		QuestionPaperLog.setUser(userresult);
		QuestionPaperLog.setProgrammes(Prog.get());
		QuestionPaperLog.setDepartment(departments.get());
		QuestionPaperLog.setExVersion(listgetVersion[i]);
		QuestionPaperLog.setExQuestionType(Questionpapercheck.get(0).getQuestionPaperType().getExQpType());
		super.questionPaperLog.save(QuestionPaperLog);	
		
		}
		
		info.put("status", "1");
		info.put("message", "jumble successfully");
		return info;
		
	} catch (Exception e) {
		logger.error("Exception occured" + e);
		StringWriter errors = new StringWriter();
		e.printStackTrace(new PrintWriter(errors));
		logger.error(errors.toString());
		info.put("status", "0");
		info.put("message", "something went wrong");
		return info;
	}
}

@Override
public Map<String, Object> getStudentListForHostel(SemesterRegistrationRequest request) {
	Map<String, Object> info = new LinkedHashMap<>();
	try {					
	
		
		 Optional<ProgrammeYear> programyear =super.programmeYear.findByIdAndExIsActiveAndExIsDelete(request.getProgrammeYear(),true ,false );
		  if(!programyear.isPresent()) {
		  info.put("status", "2"); 
		  info.put("message", "ProgrammeYear not present");
		  return info; 
		  }
		  
		Optional<Semster> Semster = super.semester.findByIdAndExIsActiveAndExIsDelete(request.getSemester(),true,false);
		if (!Semster.isPresent()) {
			info.put("status", "2");
			info.put("message", "Semster not present");
			return info;
		}		
		
		List<Studentadmission> task = super.studentadmission.findByProgrammesIdAndCollegesIdAndDegreeIdAndExIsActiveAndExIsDeleteAndBatchId( request.getProgrammes(),request.getColleges(),request.getDegree() , true , false , request.getBatch());
		System.out.println(">>..check srtudent"+task);
		if(task.size() <=0) {
			info.put("status", "2");
			info.put("message", "No Records found");
			return info;
			}
			boolean hostelAllocated = false;
			boolean hostelApproved=false;
			boolean is_present = false;
		List dataList = new LinkedList();
		for (Studentadmission e : task) {
			Map<Object, Object> datalist = new HashMap<Object, Object>();			
			List<SemesterRegistration> student = super.semesterRegistration.findByExIsDeleteAndAcademicYearIdAndProgrammeYearIdAndProgrammesIdAndSemesterIdAndStudentadmissionId( false,request.getAcademicYear(), request.getProgrammeYear(), request.getProgrammes(), request.getSemester(),e.getId());			
			if(student.size() >0) {
				is_present = true;
				datalist.put("id", e.getId());
				//datalist.put("categoryName", e.getCategory().getExName());
				datalist.put("hostelName", e.getHostel()  == null ?"NA" : e.getHostel().getExName());
				datalist.put("hostelCode", e.getHostel() == null?"NA" : e.getHostel().getExHostelCode());
				datalist.put("programmeYearId", student.get(0).getProgrammeYear().getId());
				datalist.put("programmeYear", student.get(0).getProgrammeYear().getExName());
				datalist.put("semesterId", student.get(0).getSemester().getId());
				datalist.put("semester", student.get(0).getSemester().getExName());
				datalist.put("studentId", e.getExRollNo());
				datalist.put("exIsAllocated", e.getHostel() ==null?hostelAllocated==true : hostelAllocated==false);
				datalist.put("exIsHostelApproved", student.get(0).getExIsHostelApprove());						
			    dataList.add(datalist);  				
			}
		}	
		if(is_present == true) {
			info.put("details", dataList); 
			info.put("status","1"); 
			info.put("message", "success");
			return info;
		}else {
			info.put("status","1"); 
			info.put("message", "Student Not Present");
			return info;
		}
	}
			catch (Exception e) {
		e.printStackTrace();
		logger.error("Exception occured" + e);
		StringWriter errors = new StringWriter();
		e.printStackTrace(new PrintWriter(errors));
		logger.error(errors.toString());
		info.put("status", "0");
		info.put("message", "something went wrong");
		return info;
			}
}

@Override
public Map<String, Object> getRegStudentListForHostel(SemesterRegistrationRequest request) {
	Map<String, Object> info = new LinkedHashMap<>();
	try {					
		ArrayList<Object[]> task = super.semesterRegistration.getAllStudentList(request.getAcademicYear(),request.getProgrammes(), request.getProgrammeYear(),request.getSemester(), request.getColleges(), request.getDegree());
	System.out.println(">>>>>>.task array "+task);
		if(task.size() <=0) {
		info.put("status", "2");
		info.put("message", "No Records found");
		return info;
		}
	boolean isApproved=false;
	List dataList = new LinkedList();
	for (Object[] e : task) {
		Map<Object, Object> datalist = new HashMap<Object, Object>();	
		datalist.put("exRollNo", e[0]);
		datalist.put("exName", e[1]);
		datalist.put("libraryApprove", e[2].equals(true)?isApproved==false: isApproved==true );
		datalist.put("hostelApprove", e[3].equals(true)?isApproved==false: isApproved==true );
		dataList.add(datalist);
	}
	info.put("details", dataList); 
	info.put("status","1"); 
	info.put("message", "success");
	return info;
}
		catch (Exception e) {
	e.printStackTrace();
	logger.error("Exception occured" + e);
	StringWriter errors = new StringWriter();
	e.printStackTrace(new PrintWriter(errors));
	logger.error(errors.toString());
	info.put("status", "0");
	info.put("message", "something went wrong");
	return info;
		}
}

@Override
public Map<String, String> updateHostelForStudent(CreateStudentRequest request) {
	Map<String, String> info = new LinkedHashMap<>();
	try {
		
	if (request.getExRollNo() == null|| request.getExRollNo().equals("")|| request.getExRollNo().equals("NA")) {
		info.put("status", "2");
		info.put("message", "Student id is required");
		return info;
	}
	
	
	
	if (request.getHostel()== null|| request.getHostel().equals("")||request.getHostel().equals("NA")) {
		info.put("status", "2");
		info.put("message", "HostelId is required");
		return info;
	}
	
	
	Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId( false, true , request.getAcademicYear());
	if (!academicYearid.isPresent()) {
		info.put("status", "2");
		info.put("message", "AcademicYear id not present");
		return info;
	}	
	Optional<Colleges> clgid = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(),false,true);
	if (!clgid.isPresent()) {
		info.put("status", "2");
		info.put("message", "Colleges not present");
		return info;
	}
	Optional<Hostel> hostel = super.hostel.findByIdAndExIsDeleteAndExIsActive(request.getHostel(),false,true);
	if (!hostel.isPresent()) {
		info.put("status", "2");
		info.put("message", "HostelId not present");
		return info;
	}
	
	Optional<Programmes> uid = super.programmes.findByExIsDeleteAndExIsActiveAndId(false, true, request.getProgrammes());
	if (!uid.isPresent()) {
		info.put("status", "2");
		info.put("message", "Programmes not present");
		return info;
	}
	Optional<Degree> Degree = super.degree.findByExIsDeleteAndExIsActiveAndId( false , true ,request.getDegree());
	if (!Degree.isPresent()) {
		info.put("status", "2");
		info.put("message", "Degree not present");
		return info;
	}
	Optional<Studentadmission> studid = super.studentadmission.findByExRollNo(request.getExRollNo());
	if (!studid.isPresent()) {
		info.put("status", "2");
		info.put("message", "StudentId id not present");
		return info;
	}
	
	
    int updatresult = super.studentadmission.updateStudentforHostel(request.getHostel() , request.getColleges(),request.getProgrammes(),request.getDegree(),request.getExRollNo());
	if (updatresult == 0) {
		info.put("status", "2");
		info.put("message", "Student not present");
		return info;
	}
	
	info.put("status", "1");
	info.put("message", "Successfully Hostel assigned to student");
	return info;
} catch (Exception e) {
	logger.error("Exception occured" + e);
	StringWriter errors = new StringWriter();
	e.printStackTrace(new PrintWriter(errors));
	logger.error(errors.toString());
	e.printStackTrace();
	info.put("status", "0");
	info.put("message", "Something went wrong");
	return info;
}
}

@Override
public Map<String, String> deleteHostelForStudent(CreateStudentRequest request) {
	Map<String, String> info = new LinkedHashMap<>();
	try {
		Optional<Studentadmission> task = super.studentadmission.findByExRollNo(request.getExRollNo());
		if (task.isPresent()) {
			
			if(task.get().getHostel() == null) {
				info.put("status", "2");
				info.put("message", "Hostel already deleted");
				return info;										
			}
			Long hostel = null;
			int result = super.studentadmission.updateHostelfordelete(hostel, task.get().getExRollNo());
	
			 if (result == 0) {
			 info.put("status", "0"); 
			 info.put("message","Something went wrong ");
			 return info;
			 }
			
			 
			info.put("status", "1");
			info.put("message", "Hostel for this student deleted successfully");
			return info;
		}
		info.put("status", "2");
		info.put("message", "StudentId not present");
		return info;
	} catch (Exception e) {
		logger.error("Exception occured" + e);
		StringWriter errors = new StringWriter();
		e.printStackTrace(new PrintWriter(errors));
		logger.error(errors.toString());
		info.put("status", "0");
		info.put("message", "Something went wrong");
		return info;
	}
}

@Override
public Map<String, Object> getHostelPenalty(HostelConfigureDetailRequest request) {
	Map<String, Object> info = new LinkedHashMap<>();
	Double amount=0.0;
	try {					
						
		 Optional<Programmes> programme =super.programmes.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
		  if (!programme.isPresent()) { 
		  info.put("status","2"); 
		  info.put("message", "Programmes not present"); 
		  return info;
		  }
		  
		  Optional<Semster> Semester = super.semester.findByExIsDeleteAndExIsActiveAndId( false, true , request.getSemester());
				if (!Semester.isPresent()) {
					info.put("status", "2");
					info.put("message", "Semester id not present");
					return info;
				}	
		
		  Optional<AcademicYear> academicYear =super.academicYear.findByIdAndExIsDeleteAndExIsActive(request.getAcademicYear(),false,true); 
				  if (!academicYear.isPresent()) {
				  info.put("status", "2"); 
				  info.put("message", "AcademicYear not present");
				  return info;
				  }
			Optional<Colleges> clgid = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getCollege() , false , true);
					if (!clgid.isPresent()) {
						info.put("status", "2");
						info.put("message", "Colleges not present");
						return info;
					}
		List<Studentadmission> Studentadmission = super.studentadmission.findByExRollNoAndExIsActiveAndExIsDelete(request.getStudent(),true,false);
					if (Studentadmission.size()<=0) {
						info.put("status", "2");
						info.put("message", "student not present");
						return info;
					}
		List<HostelConfiguration> task = super.HostelConfigurationRepository.findByExIsDeleteAndExIsActiveAndProgrammesIdAndAcademicYearIdAndSemesterIdAndCollegesIdAndExRollNo(false, true, request.getProgrammes(), request.getAcademicYear(), request.getSemester(), request.getCollege(), request.getStudent());
		System.out.println(">>>>task>>"+task.size());
		
		if(task.size() <=0) {
			info.put("status", "2");
			info.put("message", "No Records found");
			return info;
			}
		SimpleDateFormat myFormat = new SimpleDateFormat("dd/MM/yyyy");
		Date date = new Date();
		float penalty = 0f;
		// Get All the record 
		for(HostelConfiguration e :task) {
			// check is paid 0/1
			if(e.getExIsPaid() !=true) {
				// check what is the diffrence b/w  end date and current date 
				Date dateBefore = e.getExEndDate();
				 long difference = date.getTime() - dateBefore.getTime();
				 float daysBetween = (difference / (1000*60*60*24));
				
				 Calendar cal = Calendar.getInstance();
				 cal.setTime(e.getExStartDate());
				 int month = cal.get(Calendar.MONTH);
				 
				 if(getMonthDays(month+1) < daysBetween) {
					 penalty = penalty+125;							 
				 }else if(daysBetween >8 && daysBetween<getMonthDays(month+1)) {
					 penalty = penalty+30;
				 }else if(daysBetween >5 && daysBetween<=8) {
					 penalty = penalty+(daysBetween*10);
				 }
				 logger.info("Date diffrence : "+daysBetween);
				 logger.info("Month Name : "+(month+1));
				
			}
		}
		logger.info("penalty: "+penalty);
		
		List<Studentadmission> student = super.studentadmission.findByExRollNoAndExIsActiveAndExIsDelete(request.getStudent(),true,false);
		if((task.get(0).getExIsPaid()==false || task.get(0).getExIsPaid()==true) && student.get(0).getCategory().getExName().equals("SC")|| student.get(0).getCategory().getExName().equals("ST")) {
			info.put("status", "2");
			info.put("message", "penalty amount is zero");
			return info;
		}
		if(student.get(0).getCategory().getExName().equals("CAT-I")) {
			Double Amount= task.get(0).getExAmount()-200;
			info.put("status", "2");
			info.put("Hostel Bill", Amount);
			info.put("message", "Hostel Fee for Cat-1 is "+"hostel bill:"+task.get(0).getExAmount()+"-200="+Amount);
			return info;
		}
		
		Date edate=task.get(0).getExEndDate();
		 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); 
		
		 Calendar cal = Calendar.getInstance();
		 String dt=sdf.format(cal.getTime());
		 Date today=new Date();
		 today=sdf.parse(dt);
		 System.out.println(">>>today date>>>"+today);
					 long duration  = today.getTime() - edate.getTime();
					 long Days = TimeUnit.MILLISECONDS.toDays(duration);
					 long months = today.getMonth()- edate.getMonth();
							long i=0;
							i=i++;
					 for(task.get(0).getId().compareTo((long) 1);task.get(0).getId()>1;task.get(0).getId().compareTo(i)) {
					
					 System.out.println(">>>>>>diff>>>"+Days);
					 System.out.println(">>>>>diffmonth>>>>"+months);
					 
					     if(task.get(0).getExIsPaid()==false && (Days>=6 && Days<=8 ) ) {
					    amount= amount+10;
				
					     }
					     else if(task.get(0).getExIsPaid()==false && (Days>=9 && months<=1 && (Days<=29 || Days<=30 || Days<=31))) {
					    	 amount=amount+30;
					 
					     }
					     
					     else if(task.get(0).getExIsPaid()==false && ( (Days>=29 || Days>=30 || Days>=31)) && months>=1 && months<=6) {
					    	 if(months==1) {
						    		amount=amount+125;
						    	 }
						    	 else if(months==2) {
						    		 amount=amount+250;
						    	 }
						    	 else if(months==3) {
						    		 amount=amount+375;
						    	  }
						    	 else if(months==4) {
						    		 amount=amount+500;
						    	 }
						    	 else if(months==5) {
						    		 amount=amount+625;
						    	 }else if(months==6) {
						    		 amount=amount+750;
						    	 }
						     }
					     
					     else if(task.get(0).getExIsPaid()==false && (months>6)) {
					    	 info.put("status", "2");
						     info.put("message", "Registration cancelled for next semester");
						     return info;
					     }
		
		List dataList = new LinkedList();
		for (HostelConfiguration e : task) {
			Map<Object, Object> HostelConfigurationdata = new HashMap<Object, Object>();
			HostelConfigurationdata.put("id", e.getId());
			HostelConfigurationdata.put("exFeeName", e.getExFeename());
			HostelConfigurationdata.put("hostelName", e.getHostel().getExName());
			HostelConfigurationdata.put("exRollNo", e.getExRollNo());
			HostelConfigurationdata.put("monthname",e.getExMonthName());				
			HostelConfigurationdata.put("amount", e.getExAmount());
			HostelConfigurationdata.put("hostelPenalty",amount);
			HostelConfigurationdata.put("Category", student.get(0).getCategory().getExName());
			HostelConfigurationdata.put("is_paid", e.getExIsPaid());
			dataList.add(HostelConfigurationdata);
		}
    		info.put("HostelPenalty", dataList);
			info.put("status", "1");
			info.put("message", "success");		
			return info;
					 }
	} catch (Exception e) {
		e.printStackTrace();
		logger.error("Exception occured" + e);
		StringWriter errors = new StringWriter();
		e.printStackTrace(new PrintWriter(errors));
		logger.error(errors.toString());
		info.put("status", "0");
		info.put("message", "something went wrong");
		return info;
	}
	return info;
}
private int getMonthDays(int month) {
	if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12 )
	{
		return 31;
	}else if ( month == 4 || month == 6 || month == 9 || month == 11 )
	{
		return 30;
	}else if ( month == 2 )
	{
		return 28;	
	} else {
		return 0;	
	}  
}

@Override
public Map<String, Object> getPaybleAmount(HostelConfigureDetailRequest request) {
	Map<String, Object> info = new LinkedHashMap<>();
	Map<String, Object> hostelpenaltyamount = new LinkedHashMap<>();
	try {
		
		Double hostelpenalty = 0.0;
		
		 Optional<AcademicYear> academicYear =super.academicYear.findByIdAndExIsDeleteAndExIsActive(request.getAcademicYear(),false,true); 
		  if (!academicYear.isPresent()) {
		  info.put("status", "2"); 
		  info.put("message", "AcademicYear not present");
		  return info;
		  }
		
		Optional<Semster> sem = super.semester.findByIdAndExIsActiveAndExIsDelete(request.getSemester() ,true ,false);
		if (!sem.isPresent()){
			info.put("status", "2");
			info.put("message", "Semster not present");
			return info;
		}
		Optional<ProgrammeYear> programyear = super.programmeYear.findByIdAndExIsActiveAndExIsDelete(request.getProgrammeYear() ,true ,false );
		if(!programyear.isPresent()) {
			info.put("status", "2");
			info.put("message", "ProgrammeYear not present");
			return info;
		}	
		
								
		Optional<Programmes> Prog = super.programmes.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
		if (!Prog.isPresent()) {
			info.put("status", "2");
			info.put("message", " Programe not present");
			return info;
		}
		Optional<Colleges> col = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getCollege(), false,	true);
		 if (!col.isPresent()) {
				info.put("status", "2");
				info.put("message", "college id not present");
				return info;
		}
		 List <Studentadmission> details = super.studentadmission.findByExRollNoAndProgrammesIdAndCollegesIdAndExIsActiveAndExIsDelete(request.getStudent() , request.getProgrammes() , request.getCollege() , true , false);
		 if(details.size() <=0) {
				info.put("status", "2");
				info.put("message", "student not found");
				return info;
		 }			 
		 // Check Student semester registration 			 
		 List<SemesterRegistration> tasks = super.semesterRegistration.findByAcademicYearIdAndSemesterIdAndProgrammeYearIdAndStudentadmissionExRollNoAndProgrammesIdAndExIsActiveAndExIsDelete(request.getAcademicYear(),request.getSemester(),request.getProgrammeYear(),request.getStudent(), request.getProgrammes() , true , false);				    
			if(tasks.size() <= 0) {
				info.put("status", "2");
				info.put("message", "Student semester registration are pending");
				return info;
			}
			List dataList = new LinkedList();
		List<HostelConfiguration> task = super.HostelConfigurationRepository.findByExIsDeleteAndExIsActiveAndProgrammesIdAndAcademicYearIdAndSemesterIdAndCollegesIdAndExRollNo(false, true,request.getProgrammes(), request.getAcademicYear(), request.getSemester(), request.getCollege(),request.getStudent());
			for(HostelConfiguration hostel :task) {
				Map<Object, Object> studentinfo = new HashMap<Object, Object>();
				studentinfo.put("exFeeName", hostel.getExFeename());
				studentinfo.put("exAmount", hostel.getExAmount());
				studentinfo.put("FeeTypeName", hostel.getHostelfeetype().getExName());
				studentinfo.put("feeId", hostel.getId());
				studentinfo.put("feeTypeId", hostel.getHostelfeetype().getId());
				studentinfo.put("exMonthName", hostel.getExMonthName());
				studentinfo.put("exStartName", hostel.getExStartDate());
				studentinfo.put("exEndDate", hostel.getExEndDate());
				studentinfo.put("exIsPaid", hostel.getExIsPaid());
				dataList.add(studentinfo);
			}		
			
			info.put("feedetails", dataList);
			info.put("programmes", Prog.get().getExName());
			info.put("ProgramYear", programyear.get().getExName());
			info.put("semester", sem.get().getExName());
			info.put("category",details.get(0).getCategory().getExName());
			info.put("programmesId", Prog.get().getId());
			info.put("ProgramYearId", programyear.get().getId());
			info.put("semesterId", sem.get().getId());
			info.put("hostelpenalty", hostelpenalty);
			info.put("status", "1");
			info.put("message", "success");
			return info;
			
	}catch(Exception e) {
		e.printStackTrace();
		logger.error("Exception occured" + e);
		StringWriter errors = new StringWriter();
		e.printStackTrace(new PrintWriter(errors));
		logger.error(errors.toString());
		info.put("status", "0");
		info.put("message", "something went wrong");
		return info;
	}
}

@Override
public Map<String, Object> checkApprove(SemesterRegistrationRequest request) {
	Map<String, Object> info = new LinkedHashMap<>();
	try {
		
		List<SemesterRegistration> task = super.semesterRegistration.findByExIsDeleteAndAcademicYearIdAndProgrammeYearIdAndProgrammesIdAndSemesterIdAndStudentadmissionId(false, request.getAcademicYear(), request.getProgrammeYear(),request.getProgrammes(),request.getSemester(),request.getStudent());
	System.out.println(">>>>>.sem resg"+request.getStudent());
		if(task.size() <=0 ) {
			info.put("status", "2");
			info.put("message", "No Records Found");
			return info;
		}
		
		List<Studentadmission> list =super.studentadmission.findByIdAndProgrammesIdAndExIsActiveAndExIsDelete(request.getStudent() , request.getProgrammes(),true , false);			
		if(list.size() <=0) {
			info.put("status", "2");
			info.put("message", "No Records Found");
			return info;
		}
		// check Student having hostel
		// check what is enable in settings table for Hostel and Library approve
		String checkhostel = commonHelper.getSettingValue("HOSTEL_APPROVAL");	
		String checklibrary = commonHelper.getSettingValue("LIBRARY_APPROVAL");				
		if(checkhostel.equalsIgnoreCase("1") && checklibrary.equalsIgnoreCase("1")) {				
			if(list.get(0).getHostel() !=null) {
				if((task.get(0).getExIsHostelApprove()!=null && task.get(0).getExIsHostelApprove() == false) && (task.get(0).getExIsLibraryApprove()!=null && task.get(0).getExIsLibraryApprove() == false)) {
					info.put("status", "4");
					info.put("message", "Librarian and Hostel Warden Approval is pending, please contact concerned department");
				}else if((task.get(0).getExIsHostelApprove()!=null && task.get(0).getExIsHostelApprove() == true) && (task.get(0).getExIsLibraryApprove()!=null && task.get(0).getExIsLibraryApprove() == false)) {
					info.put("status", "3");
					info.put("message", "Librarian Approval not done, please contact Librarian ");
				}else if((task.get(0).getExIsHostelApprove()!=null && task.get(0).getExIsHostelApprove() == false) && (task.get(0).getExIsLibraryApprove()!=null && task.get(0).getExIsLibraryApprove() == true)) {
					 info.put("status", "2");
					info.put("message", "Hostel Approval not done, please contact Hostel Warden");
				}else if((task.get(0).getExIsHostelApprove()!=null && task.get(0).getExIsHostelApprove() == true) && (task.get(0).getExIsLibraryApprove()!=null && task.get(0).getExIsLibraryApprove() == true)) {
					info.put("status", "1");
					info.put("message", "Library and Hostel Approval done");
				}else {
					info.put("status", "2");
					info.put("message", "No Records Found");
					return info;
				}			
		}else {				
			// if Student not having hostel than need to check only library
			if((task.get(0).getExIsLibraryApprove()!=null && task.get(0).getExIsLibraryApprove() == false)) {					
				info.put("status", "3");
				info.put("message", "Librarian Approval not done, please contact Librarian ");
			}else if((task.get(0).getExIsLibraryApprove()!=null && task.get(0).getExIsLibraryApprove() == true)) {	
				info.put("status", "1");
				info.put("message", "Library Approval done");
			}else {
				info.put("status", "2");
				info.put("message", "No Records Found");
				return info;
			}					
			
		}				
	} else if(checklibrary.equalsIgnoreCase("1") && checkhostel.equalsIgnoreCase("0")) {				
			if((task.get(0).getExIsLibraryApprove()!=null && task.get(0).getExIsLibraryApprove() == false)) {		
				info.put("status", "3");
				info.put("message", "Librarian Approval not done, please contact Librarian");
				

			}else if((task.get(0).getExIsLibraryApprove()!=null && task.get(0).getExIsLibraryApprove() == true)) {	
				info.put("status", "1");
				info.put("message", "Library Approval done");
			}else {
				info.put("status", "2");
				info.put("message", "No Records Found");
				return info;
			}				
		}else if(checklibrary.equalsIgnoreCase("0") && checkhostel.equalsIgnoreCase("1")) {			
			if(list.get(0).getHostel() !=null) {					
				if((task.get(0).getExIsHostelApprove()!=null && task.get(0).getExIsHostelApprove() == false)) {					
				    info.put("status", "2");
					info.put("message", "Hostel Approval not done, please contact Hostel Warden");
				}else if((task.get(0).getExIsHostelApprove()!=null && task.get(0).getExIsHostelApprove() == true)) {	
					info.put("status", "1");
					info.put("message", "Hostel Approval done");
				}else {
					info.put("status", "2");
					info.put("message", "No Records Found");
					return info;
				}		
		}else {
			info.put("status", "1");
			info.put("message", "Hostel Approval done");
		}			
	}else{
		info.put("status", "1");
		info.put("message", "Library and Hostel Approval done");
	}				
}catch(Exception e) {
		e.printStackTrace();
		logger.error("Exception occured" + e);
		StringWriter errors = new StringWriter();
		e.printStackTrace(new PrintWriter(errors));
		logger.error(errors.toString());
		info.put("status", "0");
		info.put("message", "something went wrong");
		return info;				
	}
	return info;
	}

	@Override
	public Map<String, Object> qpSetterUpload(QuestionpaperRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		String extention = FilenameUtils.getExtension(request.getExQuestionpaperFile().getOriginalFilename());
		if (extention.equalsIgnoreCase("xls") || extention.equalsIgnoreCase("xlsx")) {
			Map<String, Object> result = qpSetterUploadExcel(request.getExQuestionpaperFile(),request);
			return result;
		}
		info.put("status", "2");
		info.put("message", "File should be xls / xlsx extention");
		return info;
	}

	private Map<String, Object> qpSetterUploadExcel(MultipartFile exquestionpaperFile,QuestionpaperRequest request) {
	Map<String, Object> info = new LinkedHashMap<>();
	try {
		Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
		if (!academicYearid.isPresent()) {
			info.put("status", "2");
			info.put("message", "AcademicYear id not present");
			return info;
		}
		Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
		if (!Prog.isPresent()) {
			info.put("status", "2");
			info.put("message", "Programmes not present");
			return info;
		}
		Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActiveAndAcademicYearId(request.getCourses(), false, true, request.getAcademicYear());
		if (!courses.isPresent()) {
			info.put("status", "2");
			info.put("message", "courses not  present");
			return info;

		}
		Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
		if (!degree.isPresent()) {
			info.put("status", "2");
			info.put("message", "Degree not present");
			return info;
		}
		Optional<Department> departments = super.department.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDepartment());
		if (!departments.isPresent()) {
			info.put("status", "2");
			info.put("message", "department not present");
			return info;
		}
		Optional<ExamAnnouncement> examann = super.examAnnouncement.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
		if (!examann.isPresent()) {
			info.put("status", "2");
			info.put("message", "ExamAnnouncement id not present");
			return info;
		}

		List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false,true);		
				if (user.size() <= 0) {
					info.put("status", "2");
					info.put("message", "User id not present");
					return info;
			}
				
				String  UPLOADED_FOLDER =  createFolder(academicYearid.get().getExYear() , courses.get().getExCoursesCode(), user.get(0).getExName() ,"qpsetter" );			
				if(UPLOADED_FOLDER.equals("NA")) {
					info.put("status", "0");
					info.put("message", "something went wrong");
					return info;
				}	
				Random random = new Random();
				String id = String.format("%04d", random.nextInt(10000));	
	            byte[] bytes = request.getExQuestionpaperFile().getBytes();
	            String newfilename = id+"-"+request.getExQuestionpaperFile().getOriginalFilename();
	            Path path = Paths.get(UPLOADED_FOLDER+newfilename);
	            Files.write(path, bytes);
	           String imagepath = "/"+academicYearid.get().getExYear()+"/"+courses.get().getExCoursesCode()+"/qpsetter/"+user.get(0).getExName()+"/";
		
	           String photopath = imagepath+newfilename;
			
				Date date =new Date();
			  QpSetterLog QuestionPaperLog =new QpSetterLog();
			  QuestionPaperLog.setAcademicYear(academicYearid.get());
			  QuestionPaperLog.setCourses(courses.get());
			  QuestionPaperLog.setDegree(degree.get());
			  QuestionPaperLog.setExUrl(photopath);
			  QuestionPaperLog.setExamAnnouncement(examann.get());
			  QuestionPaperLog.setExCreateDate(date); 
			  QuestionPaperLog.setDepartment(departments.get());
			  QuestionPaperLog.setProgrammes(Prog.get());
			  QuestionPaperLog.setExIsActive(true);
			  QuestionPaperLog.setExIsDelete(false);
			  QuestionPaperLog.setExFileName(exquestionpaperFile.getOriginalFilename());
			  QuestionPaperLog.setUser(user.get(0));
			  qplog.save(QuestionPaperLog);
			 
		
		info.put("status", "1");
		info.put("message", exquestionpaperFile.getOriginalFilename() + "Excel Uploaded Succesfully ");
		return info;
	} catch (Exception e) {
		logger.error("Exception occured" + e);
		StringWriter errors = new StringWriter();
		e.printStackTrace(new PrintWriter(errors));
		logger.error(errors.toString());
		info.put("status", "0");
		info.put("message", "something went wrong");
		return info;
	}
}
	public String createFolder(  String academicyear , String collegename,String studentid , String usertype) {
		try {
			
			String UPLOADED_FOLDER = commonHelper.getSettingValue("DOCUMENT_PATH");		
			File file1 = new File(UPLOADED_FOLDER+"/"+academicyear);	
			if (file1.mkdir()) {
	            file1.setExecutable(true , false); 
	            file1.setReadable(true , false); 
	            file1.setWritable(true , false); 
		     }			
			String academicyearname= file1.getPath();
			File file2 = new File(academicyearname+"/"+collegename);			
			if (file2.mkdir()) {
	            file2.setExecutable(true , false); 
	            file2.setReadable(true , false); 
	            file2.setWritable(true , false); 
				
			}
			String collegenames= file2.getPath();	
			File file3 = new File(collegenames+"/"+usertype+"/");	
			if (file3.mkdir()) {
				file3.setExecutable(true , false); 
				file3.setReadable(true , false); 
				file3.setWritable(true , false); 
				
			}			
			String student= file3.getPath();			
			File file4 = new File(student+"/"+studentid);
			if (file4.mkdir()) {	
	            file4.setExecutable(true , false); 
	            file4.setReadable(true , false); 
	            file4.setWritable(true , false); 
			}	
			
			return UPLOADED_FOLDER+academicyear+"/"+collegename+"/"+usertype+"/"+studentid+"/";
		}catch(Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
		}
		return "NA";
	}

	@Override
	public Map<String, Object> getQuestionPaper(QuestionpaperRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActiveAndAcademicYearId(request.getCourses(), false, true, request.getAcademicYear());
			if (!courses.isPresent()) {
				info.put("status", "2");
				info.put("message", "courses not  present");
				return info;

			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}
		
			Optional<ExamAnnouncement> examann = super.examAnnouncement.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!examann.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}

			List<QpSetterLog> log = qplog.findByExIsDeleteAndAcademicYearIdAndProgrammesIdAndExamAnnouncementIdAndDegreeIdAndCoursesId(false,
							request.getAcademicYear(), request.getProgrammes(), request.getExamAnnouncement(),
							request.getDegree() , request.getCourses());
			if (log.size() <=0) {
				info.put("status", "2");
				info.put("message", "No Record found");
				return info;
			}
		
			List dataList = new LinkedList();
			for (QpSetterLog e : log) {
				Map<Object, Object> timetabledata = new HashMap<Object, Object>();
				timetabledata.put("id", e.getId());
				timetabledata.put("courses", e.getCourses().getExName());
				timetabledata.put("programmes", e.getProgrammes().getExName());
				timetabledata.put("programmes", e.getProgrammes().getId());
				timetabledata.put("academicYear", e.getAcademicYear().getExYear());
				timetabledata.put("examAnnouncement", e.getExamAnnouncement().getExName());
				timetabledata.put("programmesId", e.getProgrammes().getId());
				timetabledata.put("academicYearId", e.getAcademicYear().getId());
				timetabledata.put("examAnnouncementId", e.getExamAnnouncement().getId());
				timetabledata.put("coursesId", e.getCourses().getId());
				timetabledata.put("coursesCode", e.getCourses().getExCoursesCode());
				timetabledata.put("uplodedByUser", e.getUser().getExName());
				timetabledata.put("uplodedByUserId", e.getUser().getId());
				timetabledata.put("exUrl", e.getExUrl());
				dataList.add(timetabledata);
			}
			
			info.put("status", "1");
			info.put("message", "success");
			info.put("details", dataList);
			return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> verifyQuestionpaper(QuestionpaperRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			
			Optional<QpSetterLog> examann = qplog.findById(request.getId());
			if (!examann.isPresent()) {
				info.put("status", "2");
				info.put("message", "id not present");
				return info;
			}			
			String DIRECTORY = commonHelper.getSettingValue("DOCUMENT_PATH");			
			File tempFile = new File(DIRECTORY+examann.get().getExUrl());
			FileItem fileItem = new DiskFileItem("mainFile", Files.probeContentType(tempFile.toPath()), false, tempFile.getName(), (int) tempFile.length(), tempFile.getParentFile());
			
			InputStream input = new FileInputStream(tempFile);
			    OutputStream os = fileItem.getOutputStream();
			    IOUtils.copy(input, os);
			
			MultipartFile multipartFile = new CommonsMultipartFile(fileItem);
			request.setExQuestionpaperFile(multipartFile);
			request.setAcademicYear(examann.get().getAcademicYear().getId());
			request.setCourses(examann.get().getCourses().getId());
			request.setDegree(examann.get().getDegree().getId());
			request.setDepartment(examann.get().getDepartment().getId());
			request.setExamAnnouncement(examann.get().getExamAnnouncement().getId());
			request.setProgrammes(examann.get().getProgrammes().getId());
			
			return readDataFromQuestionExcel(request.getExQuestionpaperFile(),request);
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}

	@Override
	public Map<String, Object> uploadQPKeyAnswer(QuestionpaperRequest request) {
		Map<String, Object> info = new LinkedHashMap<>();
		try {
			
			if (request.getExQpFile()  == null || request.getExQpFile().isEmpty() ) {
				info.put("status", "2");
				info.put("message", "please select question paper");		
				return info;
			} 
			
			Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getAcademicYear());
			if (!academicYearid.isPresent()) {
				info.put("status", "2");
				info.put("message", "AcademicYear id not present");
				return info;
			}
			Optional<Programmes> Prog = super.programme.findByExIsDeleteAndExIsActiveAndId(false, true,
					request.getProgrammes());
			if (!Prog.isPresent()) {
				info.put("status", "2");
				info.put("message", "Programmes not present");
				return info;
			}
			Optional<Courses> courses = super.courses.findByIdAndExIsDeleteAndExIsActiveAndAcademicYearId(
					request.getCourses(), false, true, request.getAcademicYear());
			if (!courses.isPresent()) {
				info.put("status", "2");
				info.put("message", "courses not  present");
				return info;

			}
			Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
			if (!degree.isPresent()) {
				info.put("status", "2");
				info.put("message", "Degree not present");
				return info;
			}
			Optional<Department> departments = super.department.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDepartment());
			if (!departments.isPresent()) {
				info.put("status", "2");
				info.put("message", "department not present");
				return info;
			}
			Optional<ExamAnnouncement> examann = super.examAnnouncement
					.findByIdAndExIsDeleteAndExIsActive(request.getExamAnnouncement(), false, true);
			if (!examann.isPresent()) {
				info.put("status", "2");
				info.put("message", "ExamAnnouncement id not present");
				return info;
			}
			
				User userresult=null ;
				if(request.getUser()== null || request.getUser().equals("")) {
					userresult=null;
				}else {
					List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false,true);		
					if (user.size() <= 0) {
						info.put("status", "2");
						info.put("message", "User id not present");
						return info;
					}
					userresult=user.get(0);
				}
				
	            List<QuestionPaperUpload> QuestionPaperUpload = QuestionPaperUploadRepository.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndExamAnnouncementIdAndProgrammesIdAndCoursesIdAndDegreeIdAndDepartmentId(false, true,request.getAcademicYear(),request.getExamAnnouncement(),request.getProgrammes(),request.getCourses(),request.getDegree() , request.getDepartment());
				if (QuestionPaperUpload.size()>0) {
					info.put("status", "2");
					info.put("message", "QuestionPaper alredy uploaded for particular courses");
					return info;
				}
	            
				String UPLOADED_FOLDER =  createFolder(academicYearid.get().getExYear() ,Prog.get().getExIdentifier(), courses.get().getExCoursesCode());

				
				  if(UPLOADED_FOLDER.equals("NA"))
				  { 
					  info.put("status", "0");
				      info.put("message", "something went wrong");
				      return info; 
				      
				  }
				 
				
				  String imagepath = "/"+academicYearid.get().getExYear()+"/"+"QuestionPaperUpload"+"/"+Prog.get().getExIdentifier()+"/"+courses.get().getExCoursesCode()+"/";
		          			
				Date date = new Date();
				String exQpUrl = saveQpFile(request,UPLOADED_FOLDER);		
				String exAnswerKeyFile = saveAnswerKeyFile(request,UPLOADED_FOLDER);
				SimpleDateFormat date1 = new SimpleDateFormat("dd/MM/yyyy");
				SimpleDateFormat time = new SimpleDateFormat("HH:MM");							
														
				QuestionPaperUpload selection = new QuestionPaperUpload();				
				selection.setAcademicYear(academicYearid.get());
				selection.setExamAnnouncement(examann.get());
				selection.setExIsActive(true);
				selection.setExIsDelete(false);
				selection.setUser(userresult);
				selection.setExCreateDate(date);
				selection.setCourses(courses.get());
				selection.setProgrammes(Prog.get());
				selection.setDegree(degree.get());
				selection.setDepartment(departments.get());
				
				  if(!exAnswerKeyFile.equalsIgnoreCase("NA")) {
				 selection.setExAnswerKeyUrl(imagepath+exAnswerKeyFile);
					  }
				  if(!exQpUrl.equalsIgnoreCase("NA")) {
				 selection.setExQpUrl(imagepath+exQpUrl); 
					  }
				 
				QuestionPaperUploadRepository.save(selection);
				
				info.put("status", "1");
				info.put("message", "QuestionPaper uploaded successfully");
				return info;
		} catch (Exception e) {
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			info.put("status", "0");
			info.put("message", "something went wrong");
			return info;
		}
	}
	
	  public static String saveAnswerKeyFile(QuestionpaperRequest request , String UPLOADED_FOLDER) {
		  try { 
			  if(request.getExAnswerKeyFile() == null || request.getExAnswerKeyFile().isEmpty()) {
				  return "NA"; } 
			  Random random = new Random(System.nanoTime() % 100000); 
			  int randomInt = random.nextInt(1000000000); 
			  byte[] bytes = request.getExAnswerKeyFile().getBytes(); 
			  String newfilename =  randomInt+"-"+request.getExAnswerKeyFile().getOriginalFilename(); 
			  Path path =Paths.get(UPLOADED_FOLDER+newfilename); 
			  Files.write(path, bytes);
	  logger.info("saveAnswerKeyFile Path :"+UPLOADED_FOLDER + newfilename); 
	  File filenew = new File(path.toString()); 
	  if(filenew.exists()){
	  filenew.setExecutable(true , false ); 
	  filenew.setReadable(true,false);
	  filenew.setWritable(true,false); 
	  }
	  
	  return newfilename;
	  }catch(Exception e) {
			  e.printStackTrace();
	 logger.error("Exception occured" + e); 
	 StringWriter errors = new StringWriter(); 
	 e.printStackTrace(new PrintWriter(errors));
	  logger.error(errors.toString()); return "NA"; } }
	
	 public static String saveQpFile(QuestionpaperRequest request , String UPLOADED_FOLDER) 
	 { 
		 try {
			 if(request.getExQpFile() == null || request.getExQpFile().isEmpty()) {
				 return "NA"; 
				 } 
			 Random random = new Random(System.nanoTime() % 100000); 
			 int randomInt = random.nextInt(1000000000); 
			 byte[] bytes = request.getExQpFile().getBytes();
	         String newfilename =randomInt+"-"+request.getExQpFile().getOriginalFilename();
	         Path path =  Paths.get(UPLOADED_FOLDER+newfilename);
	         Files.write(path, bytes);
	         logger.info("saveQpFile Path :"+UPLOADED_FOLDER + newfilename); 
	         File filenew= new File(path.toString()); 
	         if(filenew.exists()){
	        	 filenew.setExecutable(true , false );
	        	 filenew.setReadable(true,false); 
	        	 filenew.setWritable(true,false);
	           } 
	         return newfilename; 
	         }catch(Exception e) {
	        	 e.printStackTrace();
	         logger.error("Exception occured" + e); 
	         StringWriter errors = new StringWriter();
	         e.printStackTrace(new PrintWriter(errors));
	         logger.error(errors.toString()); return "NA"; 
	         }
		 }
	 
	 
		private String createFolder(String academicyear, String program  , String courses) {
			try {
				String UPLOADED_FOLDER = commonHelper.getSettingValue("DOCUMENT_PATH");
			
				File file2 = new File(UPLOADED_FOLDER+"/"+academicyear);			
				if (file2.mkdir()) {
		            file2.setExecutable(true , false); 
		            file2.setReadable(true , false); 
		            file2.setWritable(true , false); 
					
				}
				String academic= file2.getPath();			
				File file3 = new File(academic+"/"+"/QuestionPaperUpload/");
				if (file3.mkdir()) {	
		            file3.setExecutable(true , false); 
		            file3.setReadable(true , false); 
		            file3.setWritable(true , false); 
				}
				String student= file3.getPath();	
				File file4 = new File(student+"/"+program);	
				if (file4.mkdir()) {
		            file4.setExecutable(true , false); 
		            file4.setReadable(true , false); 
		            file4.setWritable(true , false); 
				}			
				String pro= file4.getPath();			
				File file5 = new File(pro+"/"+courses);
				if (file5.mkdir()) {	
		            file5.setExecutable(true , false); 
		            file5.setReadable(true , false); 
		            file5.setWritable(true , false); 
				}			
				return UPLOADED_FOLDER+academicyear+"/"+"QuestionPaperUpload"+"/"+program+"/"+courses+"/";
			}catch(Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
			}
			return "NA";
		}

		@Override
		public Map<String, Object> getQPKeyAnswer(QuestionpaperRequest request) {
			Map<String, Object> info = new LinkedHashMap<>();
			try {
				List<QuestionPaperUpload> QuestionPaperUpload = QuestionPaperUploadRepository.findByExIsDeleteAndExIsActiveAndAcademicYearIdAndExamAnnouncementIdAndProgrammesIdAndCoursesIdAndDegreeIdAndDepartmentId(false, true,request.getAcademicYear(),request.getExamAnnouncement(),request.getProgrammes(),request.getCourses(),request.getDegree(), request.getDepartment());
				if (QuestionPaperUpload.size()<=0) {
					info.put("status", "2");
					info.put("message", "QuestionPaper not present for particular courses");
					return info;
				}
				List dataList = new LinkedList();
				String serverurl = commonHelper.getSettingValue("SERVER_IP");
				for(QuestionPaperUpload e: QuestionPaperUpload){			
				Map<Object, Object> selection = new HashMap<Object, Object>();
				selection.put("academicYear",e .getAcademicYear().getExYear());
				selection.put("academicYearId",e .getAcademicYear().getId());

				selection.put("examAnnouncement",e .getExamAnnouncement().getExName());
				selection.put("examAnnouncementId",e .getExamAnnouncement().getId());

				selection.put("exIsActive",e .getExIsActive());
				selection.put("courses",e .getCourses().getExName());
				
				selection.put("departmentId", e.getDepartment().getId());
				selection.put("department", e.getDepartment().getExName());
				
				selection.put("coursesId",e .getCourses().getId());
				selection.put("coursesCode",e .getCourses().getExCoursesCode());


				selection.put("programmes",e .getProgrammes().getExName());
				selection.put("programmesId",e .getProgrammes().getId());
				
				selection.put("programmes",e .getProgrammes().getExName());
				selection.put("programmesId",e .getProgrammes().getId());
				

				selection.put("degree",e .getDegree().getExName());	
				selection.put("degreeId",e .getDegree().getId());	

				selection.put("exAnswerKeyUrl", (e.getExAnswerKeyUrl() == null || e.getExAnswerKeyUrl().equals("NA"))?"NA" :serverurl+e.getExAnswerKeyUrl());															
				selection.put("exQpUrl", (e.getExQpUrl() == null || e.getExQpUrl().equals("NA"))?"NA" :serverurl+e.getExQpUrl());															
			    dataList.add(selection);
				 
				}
				info.put("status", "1");
				info.put("message", "success");
				info.put("details", dataList);

				return info;
			}catch(Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}
		}

		@Override
		public Map<String, String> updateStudentEnrollementNo(@Valid StudentEnrollementNoRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {

				Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
						true);
				if (!collage.isPresent()) {
					info.put("status", "2");
					info.put("message", "College Id not Present");
					return info;
				}
				Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
				if (!degree.isPresent()) {
					info.put("status", "2");
					info.put("message", "degree Id not Present");
					return info;
				}
				/*Optional<StudentRollNo> duplicates = super.studentRollNo
						.findByExIsDeleteAndExIsActiveAndCollegesIdAndDegreeIdAndExIdStartWith(false, true, request.getColleges(),
								request.getDegree(),request.getExIdStartWith());
				if (duplicates.isPresent() && duplicates.getId() != request.getId()) {
					info.put("status", "2");
					info.put("message", duplicates.get().getExName() + ": StudentRollNo format already Present");
					return info;
				}*/
				Long privailageid = 12L;
				User userid = super.commonHelper.getuser(request.getUser());
				String Description = request.toString();
				Boolean audit = super.commonHelper.saveauditlogdetails(false, Description, userid, privailageid);
					Date date = new Date();
				int retval = super.studentEnrollment.updateStudentEnrollementNo(request.getExIdStartWith(), request.getExIsActive(),
						request.getExName(), date,request.getColleges() ,request.getDegree(), request.getId());
				if (retval == 1) {
					info.put("status", "1");
					info.put("message", "Student EnrollementNo updated successfully");
					return info;
				} else {
					info.put("status", "2");
					info.put("message", "Student EnrollementNo id not present");
					return info;
				}

			} catch (Exception e) {
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}
		}

		@Override
		public Map<String, String> deleteStudentEnrollementNo(StudentEnrollementNoRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {
				Optional<StudentEnrollementNo> task = super.studentEnrollment.findById(request.getId());
				if (task.isPresent()) {
					if (task.get().isExIsDelete()) {
						info.put("status", "2");
						info.put("message", "StudentEnrollementNo already deleted");
						return info;
					}
					Boolean exIsDelete = true;
					Boolean is_active = false;
					int result = super.studentEnrollment.deleteStudentEnrollment(exIsDelete, is_active, task.get().getId());
					if (result == 0) {
						info.put("status", "2");
						info.put("message", "Something went wrong");
						return info;
					}
					info.put("status", "1");
					info.put("message", "StudentEnrollementNo deleted successfully");
					return info;
				}
				info.put("status", "2");
				info.put("message", "StudentEnrollementNo id not present");
				return info;
			} catch (Exception e) {
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "Something went wrong");
				return info;
			}
		}

		@Override
		public Map<String, String> updateStudentRollNo(@Valid StudentEnrollementNoRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {

				Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,
						true);
				if (!collage.isPresent()) {
					info.put("status", "2");
					info.put("message", "College Id not Present");
					return info;
				}
				Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
				if (!degree.isPresent()) {
					info.put("status", "2");
					info.put("message", "degree Id not Present");
					return info;
				}
				/*Optional<StudentRollNo> duplicates = super.studentRollNo
						.findByExIsDeleteAndExIsActiveAndCollegesIdAndDegreeIdAndExIdStartWith(false, true, request.getColleges(),
								request.getDegree(),request.getExIdStartWith());
				if (duplicates.isPresent() && duplicates.getId() != request.getId()) {
					info.put("status", "2");
					info.put("message", duplicates.get().getExName() + ": StudentRollNo format already Present");
					return info;
				}*/
				Long privailageid = 25L;
				User userid = super.commonHelper.getuser(request.getUser());
				String Description = request.toString();
				Boolean audit = super.commonHelper.saveauditlogdetails(false, Description, userid, privailageid);
					Date date = new Date();
				int retval = super.studentRollNo.updateStudentRollNo(request.getExIdStartWith(), request.getExIsActive(),
						request.getExName(), date,request.getColleges() ,request.getDegree(), request.getId());
				if (retval == 1) {
					info.put("status", "1");
					info.put("message", "Student RollNo updated successfully");
					return info;
				} else {
					info.put("status", "2");
					info.put("message", "Student RollNo id not present");
					return info;
				}

			} catch (Exception e) {
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}

		}

		@Override
		public Map<String, String> deleteStudentRollNo(StudentEnrollementNoRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {
				Optional<StudentRollNo> task = super.studentRollNo.findById(request.getId());
				if (task.isPresent()) {
					if (task.get().isExIsDelete()) {
						info.put("status", "2");
						info.put("message", "StudentRollNo already deleted");
						return info;
					}
					Boolean exIsDelete = true;
					Boolean is_active = false;
					int result = super.studentRollNo.deleteStudentRollNo(exIsDelete, is_active, task.get().getId());
					if (result == 0) {
						info.put("status", "2");
						info.put("message", "Something went wrong");
						return info;
					}
					info.put("status", "1");
					info.put("message", "StudentRollNo deleted successfully");
					return info;
				}
				info.put("status", "2");
				info.put("message", "StudentRollNo id not present");
				return info;
			} catch (Exception e) {
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "Something went wrong");
				return info;
			}
		}

		@Override
		public Map<String, String> updateProfileByStudent(StudentProfile request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {
				Optional<Studentadmission> task = super.studentadmission.findById(request.getId());
				if (!task.isPresent()) {
						info.put("status", "2");
						info.put("message", "Student not present");
						return info;
					}
			
				StudentadmissionLog studentpersonal =  new StudentadmissionLog();				
				studentpersonal.setExIsApprove(0);						
				studentpersonal.setExName(request.getExName());
				studentpersonal.setExNameInHindi(request.getExNameInHindi());
				Date date = new Date();			
				// studentpersonal.setExIsActive(request.getExIsActive());
				// studentpersonal.setExIsDelete(false);
				studentpersonal.setExCreateDate(date);
				studentpersonal.setStudentadmission(task.get());
				studentpersonal.setExContactDetails(request.getExContactDetails());
				studentpersonal.setExGender(request.getExGender());
				studentpersonal.setExNationality(request.getExNationality());
				studentpersonal.setExNativeState(request.getExNativeState());
				studentpersonal.setExReligion(request.getExReligion());
				studentpersonal.setExMotherName(request.getExMotherTounge());
				studentpersonal.setExWeight(request.getExWeight());
				studentpersonal.setExHeight(request.getExHeight());
				studentpersonal.setExBloodGroup(request.getExBloodGroup());
				studentpersonal.setExEmailId(request.getExEmailId());
				studentpersonal.setExAdhaarNumber(request.getExAdhaarNumber());
				studentpersonal.setExIdentificationMark(request.getExIdentificationMark());
				studentpersonal.setExFatherName(request.getExFatherName());
				studentpersonal.setExFatherNameInHindi(request.getExFatherName());
				studentpersonal.setExParentContactDetails(request.getExParentContactDetails());
				studentpersonal.setExAnnualIncome(request.getExAnnualIncome());
				studentpersonal.setExFatherOccupation(request.getExFatherOccupation());
				studentpersonal.setExMotherName(request.getExMotherName());
				studentpersonal.setExMotherNameInHindi(request.getExMotherNameInHindi());
				studentpersonal.setExLocalGurdian(request.getExLocalGurdian());
				studentpersonal.setExlocalGurdianInHindi(request.getExlocalGurdianInHindi());
				studentpersonal.setExPermanentAddress(request.getExPermanentAddress());
				studentpersonal.setExDateOfBirth(request.getExDateOfBirth());
				studentpersonal.setExMotherTounge(request.getExMotherTounge());
				studentpersonal.setExPresentAddress(request.getExPresentAddress());
				super.studentadmissionLog.save(studentpersonal);
				info.put("status", "1");
				info.put("message", "studentprofile created successfully");

				return info;

			} catch (Exception e) {
				logger.error("Exception occured" + e);
				e.printStackTrace();
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "Something went wrong");
				return info;

			}
		}

		@Override
		public Map<String, String> updateStudentProfile(CreateStudentRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {
				
			if (request.getId() == null|| request.getId().equals("")|| request.getId().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Student id is required");
				return info;
			}
			// Personal details 
			
			if (request.getExName()== null|| request.getExName().trim().isEmpty()|| request.getExName().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Name is required");
				return info;
			}
			
			
			if (request.getExEmailId() == null|| request.getExEmailId().trim().isEmpty()||request.getExEmailId().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Email is required");
				return info;
			}
			
			if (request.getExContactDetails() == null|| request.getExContactDetails().trim().isEmpty()||request.getExContactDetails().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Mobile is required");
				return info;
			}
			
			
			if (request.getExNameInHindi() == null|| request.getExNameInHindi().trim().isEmpty()|| request.getExNameInHindi().equals("NA")) {
				info.put("status", "2");
				info.put("message", "LocalLangName is required");
				return info;
			}
			
			

			if (request.getExDateOfBirth() == null|| request.getExDateOfBirth().trim().isEmpty()|| request.getExDateOfBirth().equals("NA")) {
				info.put("status", "2");
				info.put("message", "DateOfBirth is required");
				return info;
			}
			
			if (request.getExGender() == null|| request.getExGender().trim().isEmpty()|| request.getExGender().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Gender is required");
				return info;
			}
			//admission details
			
			if (request.getExIsActive() == null|| request.getExIsActive().equals(" ")|| request.getExIsActive().equals("NA")) {
				info.put("status", "2");
				info.put("message", "ExIsActive is required");
				return info;
			}
			
			
			
			if (request.getCategory() == null|| request.getCategory().equals(" ")|| request.getCategory().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Category is required");
				return info;
			}
			
			if (request.getAllocatedCategory() == null|| request.getAllocatedCategory().equals(" ")|| request.getAllocatedCategory().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Actualcategory is required");
				return info;
			}
			
			if (request.getColleges() == null|| request.getColleges().equals(" ")|| request.getColleges().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Colleges is required");
				return info;
			}
			
			//Parent details
			
			if (request.getExFatherName()== null|| request.getExFatherName().trim().isEmpty()|| request.getExFatherName().equals("NA")) {
				info.put("status", "2");
				info.put("message", "FatherName is required");
				return info;
			}
			
			Optional<Studentadmission> Studentadmission = super.studentadmission.findById(request.getId());
			if (!Studentadmission.isPresent()) {
				info.put("status", "2");
				info.put("message", "Studentadmission id not present");
				return info;
			}
			
			Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(),false,true);
			if (!collage.isPresent() ||  !collage.get().getExIsActive()) {
				info.put("status", "2");
				info.put("message", "College not present");
				return info;			
			}
			
			
			Optional<Category> actualcategory = super.category.findByIdAndExIsDeleteAndExIsActive(request.getAllocatedCategory(),false,true);			
			if(!actualcategory.isPresent() || !actualcategory.get().getExIsActive()){				 
				info.put("status", "2");
				info.put("message", "Actualcategory not present");
				return info;
			}
			
			Optional<Category> category = super.category.findByIdAndExIsDeleteAndExIsActive(request.getCategory(),false,true);			
			if(!category.isPresent() || !category.get().getExIsActive()){				 
				info.put("status", "2");
				info.put("message", "Category not present");
				return info;
			}
			
			
			int updatresult = super.studentadmission.updateStudentadmist(request.getExName(),request.getExStudyStatus(),request.getExNameInHindi(),request.getColleges(),request.getCategory(),request .getAllocatedCategory(),request.getSection(),request.getExIsActive(),request.getId(),request.getExDetailsQualification(),request.getExAllIndiaRank());
			if (updatresult == 0) {
				info.put("status", "2");
				info.put("message", "Something went wrong Studentadmission details update.");
				return info;
			}
			
		
			int updateresult = super.studentpersonal.updateStudentpersonal(request.getExContactDetails(), request.getExEmailId() ,request.getExAdhaarNumber(),request.getExBloodGroup(),request.getExDateOfBirth(),request.getExMotherTounge(),request.getExReligion(),request.getExNativeState(),request.getExNationality(),request.getId(),request.getExFatherName(),request.getExFatherNameInHindi(),request.getExFatherOccupation(),request.getExAnnualIncome(),request.getExMotherName(),request.getExMotherNameInHindi(),request.getExLocalGurdian(),request.getExPermanentAddress(),request.getExPresentAddress(),request.getExParentContactDetails(),request.getExGender());
			if (updateresult == 0) {
				info.put("status", "2");
				info.put("message", "Something went wrong Studentpersonal details update");
				return info;
			}
			

			
		
			info.put("status", "1");
			info.put("message", "Student  details updated successfully");
			return info;
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			e.printStackTrace();
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	}
//update student profile by student
		@Override
		public Map<String, String> updateStudentProfileByStudent(CreateStudentRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {
				
			if (request.getId() == null|| request.getId().equals("")|| request.getId().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Student id is required");
				return info;
			}
			// Personal details 

			if (request.getExEmailId() == null|| request.getExEmailId().trim().isEmpty()||request.getExEmailId().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Email is required");
				return info;
			}
			
			if (request.getExContactDetails() == null|| request.getExContactDetails().trim().isEmpty()||request.getExContactDetails().equals("NA")) {
				info.put("status", "2");
				info.put("message", "Mobile is required");
				return info;
			}
			
			Optional<Studentadmission> Studentadmission = super.studentadmission.findById(request.getId());
			if (!Studentadmission.isPresent()) {
				info.put("status", "2");
				info.put("message", "Studentadmission id not present");
				return info;
			}
			
			
			
			Date date = new Date();
			List<StudentadmissionLog> studentadmissionLog = super.studentadmissionLog.findByStudentadmissionId(request.getId());
			List<StudentBankDetails> bankdetails = studentBankDetailsRepository.findByExRollNo(Studentadmission.get().getExRollNo());
			
			if (studentadmissionLog.isEmpty() || bankdetails.isEmpty()) {	
				
				int updateresult = super.studentadmissionLog.updateStudentpersonalbystudent(request.getExEmailId(),request.getExContactDetails(),Studentadmission.get().getId(),request.getExAdhaarNumber(),request.getExBloodGroup(),request.getExDateOfBirth(),request.getExFatherName(),request.getExFatherNameInHindi(),request.getExMotherName(),request.getExMotherNameInHindi(),request.getExLocalGurdian(),request.getExlocalGurdianInHindi(),request.getExPermanentAddress(),request.getExPresentAddress(),request.getExGender(),request.getExHeight(),request.getExMotherTounge(),request.getExNationality(),request.getExWeight(),request.getExNativeState(),request.getExReligion(),request.getExName(),request.getExNameInHindi(),date,Studentadmission.get().getExRollNo(),request.getExAnnualIncome(),request.getExParentContactDetails(),Studentadmission.get().getExEnrollementNo(),
						request.getExPermanentcity(),request.getExPermanentstate(),request.getExpostalcode(),request.getExcounrty(),
						request.getExPresentcity(),request.getExPresentstate(),request.getExPresentpostalcode(),request.getExPresentcounrty(),
						request.getExTenthYearOfPass(),request.getExTenthSchollName(),request.getExTenthPercentageOfMarks(),
						request.getExTenthMedium(),request.getExTenthBoardOfPass(),
						request.getExTwelvethYearOfPass(),request.getExTwelvethPercentageOfMarks(),request.getExTwelvethMedium(),
						request.getExTwelvethCollageName(),request.getExTwelvethBoardOfPass(),
						request.getExUgYearOfPass(),request.getExUgPercentageOfMarks(),request.getExUgMedium(),request.getExUgCollageName(),
						request.getExUgBoardOfPass(),
						request.getExPgBoardOfPass(),request.getExPgCollageName(),request.getExPgMedium(),request.getExPgPercentageOfMarks(),
						request.getExPgYearOfPass(),
						request.getExMinorityCategory(),request.getExPersonwithDisability(),
						request.getExOthersBoardOfPass(),request.getExOthersCollageName(),request.getExOthersMedium(),request.getExOthersPercentageOfMarks(),request.getExOthersYearOfPass(),
						request.getExGuardianEmailId(),request.getExGuardianConatct(),request.getExGuardiaPincode(),request.getExGuardianAddress(),
						request.getExFatherContact(),request.getExFatherEmailId(),request.getExFatherOfficeAddress(),
						request.getExMotherAnnualIncome(),request.getExMotherContact(),request.getExMotherEmailId(),request.getExMotherOccupation(),request.getExMotherOfficeAddress(),
						request.getExGateScore(),request.getExStudiedIsbiology());
				if(bankdetails.size()==0) {
					int insertbankdetails = studentBankDetailsRepository.insertdetails(Studentadmission.get().getId(),Studentadmission.get().getExRollNo(),Studentadmission.get().getExName(),request.getExAccountNumber(),request.getExAccountType(),request.getExBankAddress(),request.getExBranch(),date,request.getExIfscCode(),request.getExStudentAddress());
				}
			if (updateresult == 0) {//|| insertbankdetails == 0) {
				info.put("status", "2");
				info.put("message", "Something went wrong in inserting Studentpersonal details ");
				return info;
			}
			
			info.put("status", "1");
			info.put("message", "Student personal details inserted successfully");
			return info;
		}	
		else {
			if(request.getExName() != "" && request.getExNameInHindi() != "" ) {
			int updatename = super.studentadmission.updatename(request.getExName(),request.getExNameInHindi(),request.getId());
			}
			int updateresults = super.studentadmissionLog.updateStudent(request.getExEmailId(),request.getExContactDetails(),request.getId(),request.getExAdhaarNumber(),request.getExBloodGroup(),request.getExDateOfBirth(),request.getExFatherName(),request.getExFatherNameInHindi(),request.getExMotherName(),request.getExMotherNameInHindi(),request.getExLocalGurdian(),request.getExlocalGurdianInHindi(),request.getExPermanentAddress(),request.getExPresentAddress(),request.getExGender(),request.getExHeight(),request.getExMotherTounge(),request.getExNationality(),request.getExWeight(),request.getExNativeState(),request.getExReligion(),request.getExName(),request.getExNameInHindi(),date,Studentadmission.get().getExRollNo(),request.getExAnnualIncome(),request.getExParentContactDetails(),Studentadmission.get().getExEnrollementNo(),
					request.getExPermanentcity(),request.getExPermanentstate(),request.getExpostalcode(),request.getExcounrty(),
					request.getExPresentcity(),request.getExPresentstate(),request.getExPresentpostalcode(),request.getExPresentcounrty(),
					request.getExTenthYearOfPass(),request.getExTenthSchollName(),request.getExTenthPercentageOfMarks(),
					request.getExTenthMedium(),request.getExTenthBoardOfPass(),
					request.getExTwelvethYearOfPass(),request.getExTwelvethPercentageOfMarks(),request.getExTwelvethMedium(),
					request.getExTwelvethCollageName(),request.getExTwelvethBoardOfPass(),
					request.getExUgYearOfPass(),request.getExUgPercentageOfMarks(),request.getExUgMedium(),request.getExUgCollageName(),
					request.getExUgBoardOfPass(),
					request.getExPgBoardOfPass(),request.getExPgCollageName(),request.getExPgMedium(),request.getExPgPercentageOfMarks(),
					request.getExPgYearOfPass(),
					request.getExMinorityCategory(),request.getExPersonwithDisability(),
					request.getExOthersBoardOfPass(),request.getExOthersCollageName(),request.getExOthersMedium(),request.getExOthersPercentageOfMarks(),request.getExOthersYearOfPass(),
					request.getExGuardianEmailId(),request.getExGuardianConatct(),request.getExGuardiaPincode(),request.getExGuardianAddress(),
					request.getExFatherContact(),request.getExFatherEmailId(),request.getExFatherOfficeAddress(),
					request.getExMotherAnnualIncome(),request.getExMotherContact(),request.getExMotherEmailId(),request.getExMotherOccupation(),request.getExMotherOfficeAddress(),
					request.getExGateScore(),request.getExStudiedIsbiology());
			
			
			
			int insertbankdetailss = studentBankDetailsRepository.updatedetails(Studentadmission.get().getId(),Studentadmission.get().getExRollNo(),Studentadmission.get().getExName(),request.getExAccountNumber(),request.getExAccountType(),request.getExBankAddress(),request.getExBranch(),date,request.getExIfscCode(),request.getExStudentAddress());
			
			if (updateresults == 0 || insertbankdetailss == 0 ) {
				info.put("status", "2");
				info.put("message", "Something went wrong Studentpersonal details update");
				return info;
			}
			info.put("status", "1");
			info.put("message", "Student Personal details and Bank Details updated successfully");
			return info;
		}
			
			
		} catch (Exception e) {
			e.printStackTrace();
			logger.error("Exception occured" + e);
			StringWriter errors = new StringWriter();
			e.printStackTrace(new PrintWriter(errors));
			logger.error(errors.toString());
			e.printStackTrace();
			info.put("status", "0");
			info.put("message", "Something went wrong");
			return info;
		}
	
		
}

		@Override
		public Map<String, Object> approveStudentPersonalDetails(CreateStudentRequest request) {
			Map<String, Object> info = new LinkedHashMap<>();
			try {
				User userresult = null;
			
				if (request.getUser() == null || request.getUser().equals("")) {
					userresult = null;
				} else {
					List<User> user = super.user.findByIdAndExIsDeleteAndExIsActive(request.getUser(), false, true);
					if (user.size() <= 0) {
						info.put("status", "2");
						info.put("message", "User id not present");
						return info;
					}
					userresult = user.get(0);
				}
			
				Date date = new Date();
				List dataList = new LinkedList();
		List<Studentadmission> 	Studentadmission = 	super.studentadmission.findid(request.getId());
		List<StudentadmissionLog> semesterreportchcek7 = super.studentadmissionLog
				.findByStudentadmissionId(request.getId());
		List<StudentBankDetails> bankdetails = studentBankDetailsRepository.findByExRollNo(Studentadmission.get(0).getExRollNo());
		
		if(request.getApproveType().equalsIgnoreCase("1")) {
					int i = super.studentpersonal.updateApproval( request.getId(),semesterreportchcek7.get(0).getExAdhaarNumber(),semesterreportchcek7.get(0).getExBloodGroup(),userresult,semesterreportchcek7.get(0).getExContactDetails(),semesterreportchcek7.get(0).getExDateOfBirth(),semesterreportchcek7.get(0).getExEmailId(),semesterreportchcek7.get(0).getExFatherName(),semesterreportchcek7.get(0).getExFatherNameInHindi(),semesterreportchcek7.get(0).getExFatherOccupation(),semesterreportchcek7.get(0).getExGender(),semesterreportchcek7.get(0).getExHeight(),semesterreportchcek7.get(0).getExLocalGurdian(),semesterreportchcek7.get(0).getExlocalGurdianInHindi(),semesterreportchcek7.get(0).getExMotherName(),semesterreportchcek7.get(0).getExMotherNameInHindi(),semesterreportchcek7.get(0).getExMotherTounge(),semesterreportchcek7.get(0).getExNationality(),semesterreportchcek7.get(0).getExNativeState(),semesterreportchcek7.get(0).getExParentContactDetails(),semesterreportchcek7.get(0).getExPermanentAddress(),semesterreportchcek7.get(0).getExPresentAddress(),semesterreportchcek7.get(0).getExReligion(),semesterreportchcek7.get(0).getExWeight());	
			
					int updateresult = super.studentadmissionLog.updateStudentbyadmin(semesterreportchcek7.get(0).getExEmailId(),semesterreportchcek7.get(0).getExContactDetails(),semesterreportchcek7.get(0).getId(),semesterreportchcek7.get(0).getExAdhaarNumber(),semesterreportchcek7.get(0).getExBloodGroup(),semesterreportchcek7.get(0).getExDateOfBirth(),semesterreportchcek7.get(0).getExFatherName(),semesterreportchcek7.get(0).getExFatherNameInHindi(),semesterreportchcek7.get(0).getExMotherName(),semesterreportchcek7.get(0).getExMotherNameInHindi(),semesterreportchcek7.get(0).getExLocalGurdian(),semesterreportchcek7.get(0).getExlocalGurdianInHindi(),semesterreportchcek7.get(0).getExPermanentAddress(),semesterreportchcek7.get(0).getExPresentAddress(),semesterreportchcek7.get(0).getExGender(),semesterreportchcek7.get(0).getExHeight(),request.getExMotherTounge(),request.getExNationality(),request.getExWeight(),request.getExNativeState(),request.getExReligion(),request.getExName(),request.getExNameInHindi(),date,Studentadmission.get(0).getExRollNo(),request.getExAnnualIncome(),request.getExParentContactDetails(),Studentadmission.get(0).getExEnrollementNo(),
							semesterreportchcek7.get(0).getExPermanentcity(),semesterreportchcek7.get(0).getExPermanentstate(),semesterreportchcek7.get(0).getExpostalcode(),semesterreportchcek7.get(0).getExcounrty(),
							semesterreportchcek7.get(0).getExPresentcity(),semesterreportchcek7.get(0).getExPresentstate(),semesterreportchcek7.get(0).getExPresentpostalcode(),semesterreportchcek7.get(0).getExPresentcounrty(),
							semesterreportchcek7.get(0).getExTenthYearOfPass(),semesterreportchcek7.get(0).getExTenthSchollName(),semesterreportchcek7.get(0).getExTenthPercentageOfMarks(),
							semesterreportchcek7.get(0).getExTenthMedium(),semesterreportchcek7.get(0).getExTenthBoardOfPass(),
							semesterreportchcek7.get(0).getExTwelvethYearOfPass(),semesterreportchcek7.get(0).getExTwelvethPercentageOfMarks(),semesterreportchcek7.get(0).getExTwelvethMedium(),
							semesterreportchcek7.get(0).getExTwelvethCollageName(),semesterreportchcek7.get(0).getExTwelvethBoardOfPass(),
							semesterreportchcek7.get(0).getExUgYearOfPass(),semesterreportchcek7.get(0).getExUgPercentageOfMarks(),semesterreportchcek7.get(0).getExUgMedium(),semesterreportchcek7.get(0).getExUgCollageName(),
							semesterreportchcek7.get(0).getExUgBoardOfPass(),
							semesterreportchcek7.get(0).getExPgBoardOfPass(),semesterreportchcek7.get(0).getExPgCollageName(),semesterreportchcek7.get(0).getExPgMedium(),semesterreportchcek7.get(0).getExPgPercentageOfMarks(),
							semesterreportchcek7.get(0).getExPgYearOfPass(),
							request.getExMinorityCategory(),request.getExPersonwithDisability(),
							request.getExOthersBoardOfPass(),request.getExOthersCollageName(),request.getExOthersMedium(),request.getExOthersPercentageOfMarks(),request.getExOthersYearOfPass(),
							request.getExGuardianEmailId(),request.getExGuardianConatct(),request.getExGuardiaPincode(),request.getExGuardianAddress(),
							request.getExFatherContact(),request.getExFatherEmailId(),request.getExFatherOfficeAddress(),
							request.getExMotherAnnualIncome(),request.getExMotherContact(),request.getExMotherEmailId(),request.getExMotherOccupation(),request.getExMotherOfficeAddress(),
							request.getExGateScore(),request.getExStudiedIsbiology());
					
					int insertbankdetails = studentBankDetailsRepository.updatedetails(Studentadmission.get(0).getId(),Studentadmission.get(0).getExRollNo(),Studentadmission.get(0).getExName(),bankdetails.get(0).getExAccountNumber(),bankdetails.get(0).getExAccountType(),bankdetails.get(0).getExBankAddress(),bankdetails.get(0).getExBranch(),date,bankdetails.get(0).getExIfscCode(),bankdetails.get(0).getExStudentAddress());
					
					
					if(i>0 || updateresult > 0 || insertbankdetails>0 ) {
					
					info.put("status", "1");
					info.put("message", "Student approved and student details updated successfully");
					return info;
				}
		}
		if(request.getApproveType().equalsIgnoreCase("2")) {			
			int i = super.studentpersonal.updateApproval( request.getId(),2);		
			info.put("status", "2");
			info.put("message", "student has been rejected");
		}
			return info;
		

			} catch (Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "Something went wrong");
				return info;
			}
		
		}

		@Override
		public Map<String, Object> getstudentupdatedprofile(CreateStudentRequest request) {
			Map<String, Object> info = new LinkedHashMap<>();
			try {
				
				List<StudentadmissionLog> tasks = super.studentadmissionLog.findByExIsDelete(false);
	//		List<Studentpersonal> task123 = super.studentpersonal.findByExIsPersonalDetailsApproveAndStudentadmissionId(2,tasks.get(0).getStudentadmission().getId());
	//			List<StudentadmissionLog> tasks4 = super.studentadmissionLog.findByStudentadmissionId(task123.get(0).getStudentadmission().getId());
		//	System.out.println("JJJJJJJJJJJJJJ"+task123.get(0).getStudentadmission().getId());
			
				
				if (tasks.size() <= 0) {
					info.put("status", "2");
					info.put("message", "student admission log not created");
					return info;
						}
					
				else {
						List dataList = new LinkedList();
						for (StudentadmissionLog e : tasks) {
							List<Studentpersonal> task2 = super.studentpersonal.findByExIsPersonalDetailsApproveAndStudentadmissionId(0,e.getStudentadmission().getId());
							 if(task2.size() >0){
							Map<Object, Object> RoomMasterdata = new HashMap<Object, Object>();
							RoomMasterdata.put("id", e.getId());
							RoomMasterdata.put("exName", e.getExName());
							RoomMasterdata.put("exAdhaarNumber", e.getExAdhaarNumber());
							RoomMasterdata.put("exAnnualIncome", e.getExAnnualIncome());
							RoomMasterdata.put("exBloodGroup", e.getExBloodGroup());
							RoomMasterdata.put("exIsActive", e.getExIsActive());
							RoomMasterdata.put("exIsDelete", e.getExIsDelete());
							RoomMasterdata.put("exContactDetails", e.getExContactDetails());
							RoomMasterdata.put("exDateOfBirth", e.getExDateOfBirth());
							RoomMasterdata.put("exEmailId", e.getExEmailId());
							RoomMasterdata.put("exFatherName", e.getExFatherName());
							RoomMasterdata.put("exFatherNameInHindi", e.getExFatherNameInHindi());
							RoomMasterdata.put("exFatherOccupation", e.getExFatherOccupation());
							RoomMasterdata.put("exEnrollementNo", e.getExEnrollementNo());
							RoomMasterdata.put("exGender", e.getExGender());
							RoomMasterdata.put("exHeight", e.getExHeight());
							RoomMasterdata.put("exLocalGuardian", e.getExLocalGurdian());
							RoomMasterdata.put("exLocalGuardianInHindi", e.getExlocalGurdianInHindi());
							RoomMasterdata.put("exMotherName", e.getExMotherName());
							RoomMasterdata.put("exMotherNameInHindi", e.getExMotherNameInHindi());
							RoomMasterdata.put("exMotherTounge", e.getExMotherTounge());
							RoomMasterdata.put("exName", e.getExName());
							
							RoomMasterdata.put("exNameInHindi", e.getExNameInHindi());
							
							RoomMasterdata.put("exRollNo", e.getExRollNo());
							RoomMasterdata.put("exNationality", e.getExNationality());
							RoomMasterdata.put("exNativeState", e.getExNativeState());
							RoomMasterdata.put("exParentContact", e.getExParentContactDetails());
							RoomMasterdata.put("exPermanentAddress", e.getExPermanentAddress());
							
							RoomMasterdata.put("exPresentAddress", e.getExPresentAddress());
							RoomMasterdata.put("exWeight", e.getExWeight());
							RoomMasterdata.put("studentAdmissionId", e.getStudentadmission().getId());
							dataList.add(RoomMasterdata);
							 }
						}
						info.put("status", "1");
						info.put("message", "success");
						info.put("details", dataList);
						return info;
					}
				} catch (Exception e) {
					e.printStackTrace();
					logger.error("Exception occured" + e);
					StringWriter errors = new StringWriter();
					e.printStackTrace(new PrintWriter(errors));
					logger.error(errors.toString());
					info.put("status", "0");
					info.put("message", "Something went wrong");
					return info;
				}
			}

		@Override
		public Map<String, String> createseatArrangement(SeatArrangementRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {	
				SimpleDateFormat date = new SimpleDateFormat("dd/mm/yyyy");
				DateFormat dateFormat = new SimpleDateFormat("yyyy-mm-dd 00:00:00");
			
				SimpleDateFormat date123 = new SimpleDateFormat("dd/MM/yyyy hh:mm:ss");
				
				
				for(int i =0; i<request.getExamDate().size() ; i++) {
				String sDate = dateFormat.format(date.parse(request.getExamDate().get(i)));
				// for loop based on date
				for(int n = 0 ;n< request.getSeatList().size() ;n++) {							
					List<ExamTimeTable> validate = super.examtimetable.getCoursesId(request.getAcademicYear(), request.getSeatList().get(n).getProgrammes(), request.getRegistrationType(), request.getSeatList().get(n).getDegree(), request.getExExamType(),request.getSeatList().get(n).getDepartment(), sDate ,request.getSeatList().get(n).getProgrammeYear() ,request.getSeatList().get(n).getSemester(),request.getSeatList().get(n).getBatch());
					if(validate.size() <=0) {	
						Optional<Department> department = super.department.findByExIsDeleteAndExIsActiveAndId(false, true, request.getSeatList().get(n).getDepartment());
						if (!department.isPresent()) {
							info.put("status", "2");
							info.put("message", "Department not present");
							return info;
						}
						
						info.put("status", "2");
						info.put("message", "Exam time table not present for : "+department.get().getExName()+ " Department for "+sDate );
						return info;						
					}
				}
			}
				Optional<Colleges> collage = super.colleges.findByIdAndExIsDeleteAndExIsActive(request.getColleges(), false,true);
				if (!collage.isPresent()) {
					info.put("status", "2");
					info.put("message", "College Id not Present");
					return info;
				}
				
				
				Optional<RoomMaster> room = super.roomMaster.findByExIsDeleteAndExIsActiveAndId(false, true,request.getRoomId());
				if (!room.isPresent()) {
					info.put("status", "2");
					info.put("message", "room not present");
					return info;
				}
				
				Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,request.getAcademicYear());
				if (!academicYearid.isPresent()) {
					info.put("status", "2");
					info.put("message", "AcademicYear id not present");
					return info;
				}
				
				List<Long> listvalue = new ArrayList();
				if(request.getSemeserType().equalsIgnoreCase("odd")) {
					listvalue.add(1L);
					listvalue.add(3L);
					listvalue.add(5L);
					listvalue.add(7L);
				}else {
					listvalue.add(2L);
					listvalue.add(4L);
					listvalue.add(6L);
					listvalue.add(8L);
				}
				
				
				// get the no of exam 
				List<RoomMaster> roomtoatl = super.roomMaster.findByExIsDeleteAndExIsActive(false, true);
				int noofroom = roomtoatl.size();
		
				List<Integer> totalexam = super.examtimetable.getTotalExam(request.getAcademicYear() , request.getExExamType() , listvalue);	
				Integer totalnoofexam = noofroom *totalexam.size();
				// get the total no of safff
				Integer totoalinvicount = super.staffpersonal.getInviGilatorCount();
				float  perexaminvigilator =  totalnoofexam.floatValue()/totoalinvicount.floatValue();
				boolean isInt = isInt(String.valueOf(perexaminvigilator)); 
				int noofduty = 0;
				if(isInt) {
					noofduty = (int) perexaminvigilator;
				}else {
					noofduty = (int) perexaminvigilator + 1;
					
				}
				// for loop based on date
				// check room already allocated
				for(int   i = 0; i<request.getExamDate().size() ; i++) {
					String sDate1 = dateFormat.format(date.parse(request.getExamDate().get(i)));
					
				List<SeatArrangement> vlidatee  = seatArrangement.validation(request.getAcademicYear() , sDate1,request.getExExamType() , request.getSemeserType() , request.getRoomId());
						if(vlidatee.size() >0) {
							info.put("status", "2");
							info.put("message", "Exam Hall already allocated for the selected date");
							return info;							
				}
			}		
				// check validation all the Student prsent or not 
				for(int  i =0 ; i<request.getExamDate().size() ; i++) {
					String sDate2 = dateFormat.format(date.parse(request.getExamDate().get(i)));
					
				int seatcapecity1 = 0;
				for(int r = 0 ;r< request.getSeatList().size() ; r++) {						
				List<ExamTimeTable> getcourses = super.examtimetable.getCoursesId(request.getAcademicYear(), request.getSeatList().get(r).getProgrammes(), request.getRegistrationType(), request.getSeatList().get(r).getDegree(), request.getExExamType(),request.getSeatList().get(r).getDepartment(), sDate2 ,request.getSeatList().get(r).getProgrammeYear() ,request.getSeatList().get(r).getSemester(),request.getSeatList().get(r).getBatch());						
					seatcapecity1 = seatcapecity1+request.getSeatList().get(r).getTotalStudent();
				}
				
				if(seatcapecity1 > room.get().getExNumberOfStudent()) {
					info.put("status", "2");
					info.put("message", "Exam Hall capacity is "+room.get().getExNumberOfStudent());
					return info;
					
				}
				}
					List<User> user = super.user.findByIdAndExIsDelete(request.getUser(), false);
					if (user.size() <= 0) {
						info.put("status", "2");
						info.put("message", "User id not present");
						return info;
					}
					Date date1 = new Date();			
					
					for(int z =0 ; z<request.getExamDate().size() ; z++) {
						String sDate23 = dateFormat.format(date.parse(request.getExamDate().get(z)));
						
					int seatcapecity = 0;
					for(int r = 0 ;r< request.getSeatList().size() ; r++) {						
					List<ExamTimeTable> getcourses = super.examtimetable.getCoursesId(request.getAcademicYear(), request.getSeatList().get(r).getProgrammes(), request.getRegistrationType(), request.getSeatList().get(r).getDegree(), request.getExExamType(),request.getSeatList().get(r).getDepartment(), sDate23 ,request.getSeatList().get(r).getProgrammeYear() ,request.getSeatList().get(r).getSemester(),request.getSeatList().get(r).getBatch());						
						seatcapecity = seatcapecity+request.getSeatList().get(r).getTotalStudent();
					}
				
					
					
					InvigilatorDuty duty = new InvigilatorDuty();
					duty.setAcademicYear(academicYearid.get());
					duty.setExCreateDate(date1);
					duty.setExExamType(request.getExExamType());
					duty.setRoom(room.get());
					duty.setNoOfStudent(seatcapecity);
					duty.setExSemesterType(request.getSemeserType());
					// get the validation 
					
					List<InvigilatorDuty> validate = invigilatorduty.getInvigilator(sDate23,request.getAcademicYear(), request.getExExamType(), request.getSemeserType());
				
					List<Long> list1 = new ArrayList();
					//List<Long> listtest = new ArrayList();
					
					
					List<InvigilatorDuty> getInvigilator1duty = invigilatorduty.getInvigilator1duty(request.getAcademicYear(), request.getExExamType(), request.getSemeserType(),noofduty);					
					List<InvigilatorDuty> getInvigilator2duty = invigilatorduty.getInvigilator2duty(request.getAcademicYear(), request.getExExamType(), request.getSemeserType(),noofduty);
					
					for(InvigilatorDuty k :getInvigilator1duty) {
						list1.add(k.getInvigilator1().getId());
						//listtest.add(k.getInvigilator1().getId());
					}
					for(InvigilatorDuty l :getInvigilator2duty) {
						list1.add(l.getInvigilator2().getId());
						//listtest.add(l.getInvigilator2().getId());
					}
					
					
					for(InvigilatorDuty e :validate) {
						list1.add(e.getInvigilator1().getId());
						list1.add(e.getInvigilator2().getId());
						list1.add(e.getReserved().getId());
					}
					// get the number of invigilator noofduty id
				
					//get the 3 invigilator who not allocated 
					List<Staffpersonal> Staffpersonal = null;
					if(validate.size() <=0) {
						Staffpersonal = super.staffpersonal.getAllstaffforallocation();
					}else {						
						Staffpersonal = super.staffpersonal.getstaffforallocation(list1);
					}
					
					if(Staffpersonal.size() <=0) {
						info.put("status", "2");
						info.put("message", "Staff id not present");
						return info;
					}
					
					duty.setExStartDate(date123.parse(request.getExamDate().get(z)+" 00:00:00"));
					duty.setInvigilator1(Staffpersonal.get(0));
					duty.setInvigilator2(Staffpersonal.get(1));
					duty.setReserved(Staffpersonal.get(2));					
					invigilatorduty.save(duty);
						
				int u = 1; 
				for(int i = 0 ;i< request.getSeatList().size() ;i++) {				
					Optional<Programmes> Programmes = super.programmes.findByIdAndExIsDeleteAndExIsActive(request.getSeatList().get(i).getProgrammes() , false,true);
					if (!Programmes.isPresent()) {
						info.put("status", "2");
						info.put("message", "Programmes Id not Present");
						return info;
					}
									
					Optional<Department> department = super.department.findByExIsDeleteAndExIsActiveAndId(false, true, request.getSeatList().get(i).getDepartment());
					if (!department.isPresent()) {
						info.put("status", "2");
						info.put("message", "Department not present");
						return info;
					}
					Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getSeatList().get(i).getDegree());
					if (!degree.isPresent()) {
						info.put("status", "2");
						info.put("message", "degree not present");
						return info;
					}
					Optional<ProgrammeYear> programyear = super.programmeYear.findByIdAndExIsDeleteAndExIsActive(request.getSeatList().get(i).getProgrammeYear(), false, true);
					if (!programyear.isPresent()) {
						info.put("status", "2");
						info.put("message", "programyear not  present");
						return info;

					}
					Optional<Semster> sem = super.semester.findByExIsDeleteAndExIsActiveAndId(false, true,request.getSeatList().get(i).getSemester());
					if (!sem.isPresent()) {
						info.put("status", "2");
						info.put("message", "semester not present");
						return info;
					}					
					Optional<Batch> batch = super.batch.findByExIsDeleteAndExIsActiveAndId(false, true, request.getSeatList().get(i).getBatch());
					if (!batch.isPresent()) {
						info.put("status", "2");
						info.put("message", "batch not present");
						return info;
					}
				
				List<ExamTimeTable> getcourses = super.examtimetable.getCoursesId(request.getAcademicYear(), request.getSeatList().get(i).getProgrammes(), request.getRegistrationType(), request.getSeatList().get(i).getDegree(), request.getExExamType(),request.getSeatList().get(i).getDepartment(), sDate23 ,request.getSeatList().get(i).getProgrammeYear() ,request.getSeatList().get(i).getSemester(),request.getSeatList().get(i).getBatch());
					
				
				List<CoursesRegistration> task = super.coursesRegistration.getStudentForSeat(request.getSeatList().get(i).getProgrammes(), request.getAcademicYear(), request.getSeatList().get(i).getDepartment(),request.getSeatList().get(i).getSemester(),request.getSeatList().get(i).getProgrammeYear(), request.getSeatList().get(i).getTotalStudent() , getcourses.get(0).getCourses().getId());
					if(task.size() <=0 ) {
						// delete from inviduty and seat allarangment 
						seatArrangement.deleteSeatArrangment(duty.getId());
						invigilatorduty.deleteInviDuty(duty.getId());
						
						info.put("status", "2");
						info.put("message", "Student registration are pending");
						return info;
					}						
					//get the courses List
					
				
					//if(i == 1) {
					//	u = 25;
					//}
					//if(i == 2) {
					///	u = 49;
					//}
					
				List dataList = new LinkedList();
				for (int m = 0; m < task.size(); m++) {											
						SeatArrangement allocation = new SeatArrangement();
						allocation.setExSemesterType(request.getSemeserType());
						allocation.setInvigilatorduty(duty);
						allocation.setUser(user.get(0));
						allocation.setRoom(room.get());
						allocation.setAcademicYear(academicYearid.get());
						allocation.setExRollNo(task.get(m).getStudentadmission().getExRollNo());
						allocation.setExStartDate(getcourses.get(0).getExStartDate());
						allocation.setExExamType(request.getExExamType());
						allocation.setBatch(batch.get());
						allocation.setColleges(collage.get());
						allocation.setCourses(getcourses.get(0).getCourses());
						allocation.setExCreateDate(date1);
						allocation.setExIsActive(true);
						allocation.setExIsDelete(false);
						allocation.setDepartment(department.get());
						allocation.setProgrammeYear(programyear.get());
						allocation.setSemester(sem.get());
						allocation.setDegree(degree.get());
						allocation.setStudentAdmission(task.get(m).getStudentadmission());
						allocation.setProgrammes(Programmes.get());						
								int row  = commonHelper.getRow(i, u);
								allocation.setRow(row);
								u++;				
				dataList.add(allocation);
			
				}				
				super.seatArrangement.saveAll(dataList);
			
				}	
	   }	
				info.put("status", "1");
				info.put("message", "seat arrangement Allocated successfully");
				return info;
			}	
			 catch (Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}
			

		}

		@Override
		public Map<String, Object> approveStatus(CreateStudentRequest request) {
			Map<String, Object> info = new LinkedHashMap<>();
			try {
				
		
	
			List<StudentadmissionLog> tasks = super.studentadmissionLog.findByExIsDeleteAndStudentadmissionId(false,request.getStudentadmission());
			List<Studentpersonal> task2 = super.studentpersonal.findByStudentadmissionId(request.getStudentadmission());
		//	Optional<Studentpersonal> degree = super.studentpersonal.findByStudentadmissionId());
			Optional<StudentadmissionLog> degree = super.studentadmissionLog.findByStudentadmissionIdAndExIsDelete(request.getStudentadmission(),false);
			if (!degree.isPresent()) {
				info.put("status", "4");
				info.put("message", "No Profile update done by Student");
				return info;
			}
			if(task2.get(0).getExIsPersonalDetailsApprove() == 0) {
					info.put("status", "2");
					info.put("message", "Waiting for Approval");
					return info;	
										
				}
				if(task2.get(0).getExIsPersonalDetailsApprove() == 1) {
					info.put("status", "1");
					info.put("message", "Approved successfully");
					return info;	
									
				}
				if(task2.get(0).getExIsPersonalDetailsApprove() == 2) {
					info.put("status", "3");
					info.put("message", "Approval Rejected");
					return info;									
				}
			} catch (Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
			
			}
			return info;
			

		}

		@Override
		public Map<String, Object> getUpdatedStudentPersonalDetails(CreateStudentRequest request) {
			List dataList = new LinkedList();
			Map<String, Object> info = new LinkedHashMap<>();
			System.out.println("K"+request.getStudentadmission());
			try {
				List<StudentadmissionLog> tasks = super.studentadmissionLog.findByExIsDeleteAndStudentadmissionId(false,request.getStudentadmission());
				System.out.println("LLLLL"+tasks);
				if (tasks.size() <= 0) {
					info.put("status", "2");
					info.put("message", "student not Updated personal details");
					return info;
						}
					
				else {
						
						for (StudentadmissionLog e : tasks) {
							List<Studentpersonal> task2 = super.studentpersonal.findByExIsPersonalDetailsApproveAndStudentadmissionId(0,tasks.get(0).getStudentadmission().getId());
							 if(task2.size() >0){
							Map<Object, Object> RoomMasterdata = new HashMap<Object, Object>();
							RoomMasterdata.put("id", e.getId());
							RoomMasterdata.put("exName", e.getExName());
							RoomMasterdata.put("exAdhaarNumber", e.getExAdhaarNumber());
							RoomMasterdata.put("exAnnualIncome", e.getExAnnualIncome());
							RoomMasterdata.put("exBloodGroup", e.getExBloodGroup());
							RoomMasterdata.put("exIsActive", e.getExIsActive());
							RoomMasterdata.put("exIsDelete", e.getExIsDelete());
							RoomMasterdata.put("exContactDetails", e.getExContactDetails());
							RoomMasterdata.put("exDateOfBirth", e.getExDateOfBirth());
							RoomMasterdata.put("exEmailId", e.getExEmailId());
							RoomMasterdata.put("exFatherName", e.getExFatherName());
							RoomMasterdata.put("exFatherNameInHindi", e.getExFatherNameInHindi());
							RoomMasterdata.put("exFatherOccupation", e.getExFatherOccupation());
							RoomMasterdata.put("exEnrollementNo", e.getExEnrollementNo());
							RoomMasterdata.put("exGender", e.getExGender());
							RoomMasterdata.put("exHeight", e.getExHeight());
							RoomMasterdata.put("exLocalGuardian", e.getExLocalGurdian());
							RoomMasterdata.put("exLocalGuardianInHindi", e.getExlocalGurdianInHindi());
							RoomMasterdata.put("exMotherName", e.getExMotherName());
							RoomMasterdata.put("exMotherNameInHindi", e.getExMotherNameInHindi());
							RoomMasterdata.put("exMotherTounge", e.getExMotherTounge());
							RoomMasterdata.put("exName", e.getExName());
							
							RoomMasterdata.put("exNameInHindi", e.getExNameInHindi());
							
							RoomMasterdata.put("exRollNo", e.getExRollNo());
							RoomMasterdata.put("exNationality", e.getExNationality());
							RoomMasterdata.put("exNativeState", e.getExNativeState());
							RoomMasterdata.put("exParentContact", e.getExParentContactDetails());
							RoomMasterdata.put("exPermanentAddress", e.getExPermanentAddress());
							
							RoomMasterdata.put("exPresentAddress", e.getExPresentAddress());
							RoomMasterdata.put("exWeight", e.getExWeight());
							RoomMasterdata.put("studentAdmissionId", e.getStudentadmission().getId());
							dataList.add(RoomMasterdata);
							 }
						}
						info.put("status", "1");
						info.put("message", "success");
						info.put("details", dataList);
						return info;
					}
			} catch (Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
			}

			return info;

		
		}

		@Override
		public Map<String, Object> updateExamTimeSlot(ExamTimeTableRequest request) {
			Map<String, Object> info = new LinkedHashMap<>();
			try {
				if (request.getExTimeTableId() == null || request.getExTimeTableId().equals("")) {
					info.put("status", "2");
					info.put("message", "ExTimeTableId is required");
					return info;
				}

				if (request.getExTimeSlot() == null || request.getExTimeSlot().equals("")) {
					info.put("status", "2");
					info.put("message", "ExStartDate is required");
					return info;
				}

				Optional<ExamTimeTable> task = super.examtimetable.findById(request.getExTimeTableId());
				if (!task.isPresent()) {
					info.put("status", "2");
					info.put("message", "ExTimeTableId not present");
					return info;
				}
				String timeslot = request.getExTimeSlot();
				if(!timeslot.contains("-")) {
					
					info.put("status", "2");
					info.put("message", "Please send time with - (10:00-11:00)");
					return info;
				}
				String[] words= timeslot.split("-");
		
			       SimpleDateFormat time = new SimpleDateFormat("hh:mm");
				//SimpleDateFormat time = new SimpleDateFormat("HH:MM");
				Boolean is_update = true;
				Date modifieddate = new Date();

				User userid = super.commonHelper.getuser(request.getUser());
				String Description = request.toString();
				Boolean audit = super.commonHelper.saveauditlogdetails(true, Description, userid, 39L);
				int updatresult = super.examtimetable.updateExamTimeSlot(time.parse(words[0]), time.parse(words[1]),request.getExTimeTableId());
				if (updatresult == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}
				info.put("status", "1");
				info.put("message", "ExamTimeTable updated successfully");
				return info;
			} catch (Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;

			}
		}

		@Override
		public Map<String, String> PublishTimetable(ExternalMarksRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
				try {
					Optional<AcademicYear> academicYearid = super.academicYear.findByExIsDeleteAndExIsActiveAndId(false, true,
							request.getAcademicYear());
					if (!academicYearid.isPresent()) {
						info.put("status", "2");
						info.put("message", "AcademicYear id not present");
						return info;
					}
					Optional<Degree> degree = super.degree.findByExIsDeleteAndExIsActiveAndId(false, true, request.getDegree());
					if (!degree.isPresent()) {
						info.put("status", "2");
						info.put("message", "Degree id not present");
						return info;
					}
					Optional<Programmes> Prog = super.programmes.findByExIsDeleteAndExIsActiveAndId(false, true,
							request.getProgrammes());
					if (!Prog.isPresent()) {
						info.put("status", "2");
						info.put("message", "Programmes id not present");
						return info;
					}
					List<ExamAnnouncement> result = super.examAnnouncement.findByIdAndExIsDelete(request.getExamAnnouncement(),
							false);
					if (result.size() <= 0) {
						info.put("status", "2");
						info.put("message", "ExamAnnouncement id not present");
						return info;
					}
					Optional<Department> dept = super.department.findByIdAndExIsDeleteAndExIsActive(request.getDepartment(),false, true);
					if (!dept.isPresent()) {
						info.put("status", "2");
						info.put("message", "department not  present");
						return info;

					}
					
					int retvalue = 0;
					RegistrationType regType =null;

					if (request.getExIdentifier().equalsIgnoreCase("timetable")) {
						if (request.getExExamType() == 0L || request.getRegistrationType().equals("0")) {
							
							regType=null;
							List<ExamAcademicYearProgrammes> examlist = super.examAcademicYearProgrammes.findByAcademicYearIdAndExamAnnouncementIdAndProgrammesIdAndExExamTypeAndDegreeIdAndDepartmentId(request.getAcademicYear(),request.getExamAnnouncement(),request.getProgrammes(), request.getExExamType(),request.getDegree(), request.getDepartment());
							if (examlist.size() <= 0) {
								info.put("status", "2");
								info.put("message", "time table Not Generated ");
								return info;
							}else {
							Boolean publish = true;
							retvalue = super.examAcademicYearProgrammes.publishresult(publish, request.getProgrammes(),
									request.getAcademicYear(), request.getExamAnnouncement(),
									request.getUser(),request.getExExamType(),request.getDepartment());
							System.out.println("aaaaaaa" + retvalue);

							if (retvalue >= 1) {
								info.put("status", "1");
								info.put("message", "Time table Published successfully");
								return info;
							} else {
								info.put("status", "2");
								info.put("message", "Time table Published successfully");
								return info;
							}
							}
						}
					
						if (request.getExExamType() == 1L || request.getExExamType().equals("1")) {
							List<RegistrationType> registration = super.registrationType
									.findByIdAndExIsDelete(request.getRegistrationType(), false);
							if (registration.size() <= 0) {
								info.put("status", "2");
								info.put("message", "RegistrationType id not present");
								return info;
							}
							
							regType=registration.get(0);
							
							
							List<ExamAcademicYearProgrammes> examlist = super.examAcademicYearProgrammes.findByAcademicYearIdAndExamAnnouncementIdAndProgrammesIdAndExExamTypeAndDegreeIdAndDepartmentIdAndRegistrationId(request.getAcademicYear(),request.getExamAnnouncement(),request.getProgrammes(), request.getExExamType(),request.getDegree(), request.getDepartment(),request.getRegistrationType());
							if (examlist.size() <= 0) {
								info.put("status", "2");
								info.put("message", "time table Not Generated ");
								return info;
							}else {
							Boolean publish = true;
							retvalue = super.examAcademicYearProgrammes.publishresultEndTerm(publish, request.getProgrammes(),
									request.getAcademicYear(), request.getExamAnnouncement(),
									request.getUser(),request.getExExamType(),request.getRegistrationType(),request.getDepartment());
							System.out.println("aaaaaaa" + retvalue);

							if (retvalue >= 1) {
								info.put("status", "1");
								info.put("message", "Time table Published successfully");
								return info;
							} else {
								info.put("status", "2");
								info.put("message", "Time table Published successfully");
								return info;
							}
							}
						
							
						}

					}
						return info;

				} catch (Exception e) {
					e.printStackTrace();
					logger.error("Exception occured" + e);
					StringWriter errors = new StringWriter();
					e.printStackTrace(new PrintWriter(errors));
					logger.error(errors.toString());
					info.put("status", "0");
					info.put("message", "something went wrong");
					return info;
				}

			}

		@Override
		public Map<String, String> createcoursescoverage(CoursesCoverageRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {
				
				Optional<Courses> course = super.courses.findByIdAndExIsDeleteAndExIsActive(request.getCourses(), false, true);
				if (!course.isPresent() || !course.get().getExIsActive()) {
					info.put("status", "2");
					info.put("message", "Course not present");
					return info;
				}
				
				Optional<Staffpersonal> staff = super.staffpersonal.findByIdAndExIsDeleteAndExIsActive(request.getStaff(), false, true);
				if (!staff.isPresent()) {
					info.put("status", "2");
					info.put("message", "Staff not present");
					return info;
				}
				Date date = new Date();

				CoursesCoverage courses = new CoursesCoverage();
				courses.setExCreateDate(date);
				courses.setCourses(course.get());
				courses.setStaffpersonal(staff.get());
				courses.setExUnitName(request.getExUnitName());
				courses.setExTopicsCovered(request.getExTopicsCovered());
				courses.setExTopicsNotCovered(request.getExTopicsNotCovered());
				courses.setExTotalTopics(request.getExTotalTopics());
				courses.setExIsDelete(false);
				courses.setExIsActive(request.getExIsActive());
								
				super.CourseCoverage.save(courses);
				info.put("status", "1");
				info.put("message", "CourseCoverage created successfully");
				info.put("id", courses.getId().toString());
				return info;

			} catch (Exception e) {
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "Something went wrong");
				return info;
			}
		}

		@Override
		public Map<String, String> updatecoursescoverage(CoursesCoverageRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {
				
				Date date = new Date();
				int updateresult = super.CourseCoverage.Update(request.getId(),request.getExUnitName(), request.getExTopicsCovered(),request.getExIsActive(), request.getExTopicsNotCovered(),request.getExTotalTopics());
				if (updateresult == 0) {
					info.put("status", "2");
					info.put("message", "Something went wrong");
					return info;
				}

				info.put("status", "1");
				info.put("message", "CoursesCoverageTopics updated successfully");
				return info;

			} catch (Exception e) {
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				e.printStackTrace();
				info.put("status", "0");
				info.put("message", "Something went wrong");
				return info;
			}
		}

		@Override
		public Map<String, Object> getcoursescoverage(CoursesCoverageRequest request) {
			Map<String, Object> info = new LinkedHashMap<>();
			try {

				List<CoursesCoverage> tasks = super.CourseCoverage.findByExIsDeleteAndStaffpersonalId(false, request.getStaff());

				if (tasks.size() <= 0) {
					info.put("status", "2");
					info.put("message", "CourseCoverage Units not created");
					return info;
				} else {
					List dataList = new LinkedList();
					for (CoursesCoverage e : tasks) {
						Map<Object, Object> Courses = new HashMap<Object, Object>();
						Courses.put("id", e.getId());
						Courses.put("exIsActive", e.getExIsActive());
						Courses.put("exIsDelete", e.getExIsDelete());
						Courses.put("exUnitName", e.getExUnitName());
						Courses.put("exTopicsCovered", e.getExTopicsCovered());
						Courses.put("exTopicsNotCovered", e.getExTopicsNotCovered());
						Courses.put("exTotalTopics", e.getExTotalTopics());
						Courses.put("exCourse", e.getCourses().getId());
						Courses.put("exCourseCode", e.getCourses().getExCoursesCode());

						dataList.add(Courses);
					}
					info.put("status", "1");
					info.put("message", "success");
					info.put("details", dataList);
					return info;
				}

			} catch (Exception e) {
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "Something went wrong");
				return info;
			}
		}

		@Override
		public Map<String, String> deletecoursescoverage(CoursesCoverageRequest request) {
			Map<String, String> info = new LinkedHashMap<>();
			try {
				Optional<CoursesCoverage> task = super.CourseCoverage.findById(request.getId());

				if (task.isPresent()) {
					int result = super.CourseCoverage.deleteCourseCoverage( task.get().getId());
					if (result == 0) {
						info.put("status", "2");
						info.put("message", "Something went wrong");
						return info;
					}
					info.put("status", "1");
					info.put("message", "CourseCoverageUnit deleted successfully");
					return info;
				}
				info.put("status", "2");
				info.put("message", "CourseCoverageUnit not present");
				return info;
			} catch (Exception e) {
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "Something went wrong");
				return info;
			}
		}

		@Override
		public Map<String, Object> getDate(SeatArrangementRequest request) {
			Map<String, Object> info = new LinkedHashMap<>();
			try {	
				
				List<ExamTimeTable> getdates = super.examtimetable.getDate(request.getAcademicYear(),  request.getExExamType());
				if(getdates.size() <=0) {
					info.put("status", "2");
					info.put("message", "Exam time table not present");
					return info;	
				}
				List dataList = new LinkedList();
				for(ExamTimeTable e :getdates) {
					Map<Object, Object> Courses = new HashMap<Object, Object>();
					Courses.put("id", e.getId());										
					Courses.put("examDate", e.getExStartDate() == null ? "NA": e.getExStartDate().toString().substring(0, 10));
					dataList.add(Courses);
					
				}
				info.put("details", dataList);
				info.put("status", "1");
				info.put("message", "success");
				return info;
			}	
			 catch (Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}

		}
				
		public static boolean isInt(String str) {
			System.out.println("ssssssssssssssss"+str);
		  	try {
		  		if( str.matches("^\\d+\\.\\d+") ) {
		  			return false;
		  		}else {
		  			return true;
		  		}
			} catch (NumberFormatException e) {
		    	return false; //String is not an Integer
			}
		  	
		}

		@Override
		public Map<String, Object> getExamDuty(SeatArrangementRequest request) {
			Map<String, Object> info = new LinkedHashMap<>();
			try {	
				
				List<InvigilatorDuty> getInvigilator2duty = invigilatorduty.gettheList(request.getAcademicYear(),request.getId());		
				if(getInvigilator2duty.size() <=0) {
					info.put("status", "2");
					info.put("message", "No Duty");
					return info;	
				}
				List dataList = new LinkedList();
				for(InvigilatorDuty e :getInvigilator2duty) {
					Map<Object, Object> Courses = new HashMap<Object, Object>();
					Courses.put("id", e.getId());		
					Courses.put("examHall", e.getRoom().getExName());	
					Courses.put("oddeven", e.getExSemesterType());	
					Courses.put("semestertype", e.getExExamType());	
					Courses.put("examDate", e.getExStartDate() == null ? "NA": e.getExStartDate().toString().substring(0, 10));
					dataList.add(Courses);
					
				}
				info.put("details", dataList);
				info.put("status", "1");
				info.put("message", "success");
				return info;
			}	
			 catch (Exception e) {
				e.printStackTrace();
				logger.error("Exception occured" + e);
				StringWriter errors = new StringWriter();
				e.printStackTrace(new PrintWriter(errors));
				logger.error(errors.toString());
				info.put("status", "0");
				info.put("message", "something went wrong");
				return info;
			}

		}		
		
		
}	
